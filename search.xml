<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mybatis]]></title>
    <url>%2F%2F2019%2F07%2F27%2F2019-07-27%2F</url>
    <content type="text"><![CDATA[Mybatis1、ORM(Object relational Mapping) 对象关系映射 Mybatis3 (ibatis 3.0之前) hibernate2、JDBC-DButils(工具) - JdbcTemplete 框架： 大的宏观的解决方案3、 Hibernate(全自动的映射框架) 目的： 就是让不懂SQL 的程序员 ，也能面向对象的思想操作数据库4、Mybatis(半自动的映射框架) 优点： 灵活性好，因为SQL语句是我们手动编写的。1)创建Connection 2)编写SQL语句 3)预编译 4)执行 5)resultSet save select5、 Mybatis 将java代码和 SQL语句分离。6、7、Mybatis 学好SQL语句8、操作数据库 API 1)SqlSessionFactory 2)SqlSession 9、 mybatis 中有两大配置文件 1)主配置文件 2)映射文件 10、 对于Mybatis来说，我们的映射文件就是一个Dao层实现。 pack test;12345678910111213141516public class MybatisTest &#123; public static void main(String[] args) throws IOException &#123; InputStream is = Resources.getResourceAsStream("mybatis-config.xml"); //代表的是一个SqlSession工厂 = 数据库 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is); SqlSession sqlSession = sqlSessionFactory.openSession(); User user = sqlSession.selectOne("org.mybatis.example.UserMapper.selectUser", 5); System.out.println(user); &#125;&#125; UserMapper.xml1234567&lt;mapper namespace="org.mybatis.example.UserMapper"&gt; &lt;select id="selectUser" resultType="com.neusoft.mybatis.entity.User"&gt; select * from t_user where id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; mybatis-config.xml1234567891011121314151617&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/neusoft" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="123456" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="com/neusoft/mybatis/mapping/UserMapper.xml" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; Setting 12345678910//1.不应该这样，应该面向接口// User user = sqlSession.selectOne("org.mybatis.example.UserMapper.selectUser", "user");//2.改为 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.selectUser(5);// System.out.println(userMapper.getClass().getName()); //com.sun.proxy.$Proxy2 动态代理第一种方式，改为"helloworld" 不报错，但返回值为空，不存在这个User第二种方式，1)不是基于文字的，更安全，2)IDE代码补全，利用它操作映射的SQL语句，3)不需要强制类型转换，UserMapper接口保持简洁，返回值类型安全(参数类型安全) 起别名 不同包下 有相同的类名 User 怎么解决？使用注解@Alias(“user1”) typeHandlers 类型处理器1234567&lt;!-- 目的就是在mybatis中支持多数据库 --&gt; &lt;databaseIdProvider type="DB_VENDOR"&gt; &lt;property name="Mysql" value="mysql"/&gt; &lt;property name="SQL Server" value="sqlserver"/&gt; &lt;property name="DB2" value="db2"/&gt; &lt;property name="Oracle" value="oracle"/&gt; &lt;/databaseIdProvider&gt; databasemetadata.getproductname 获取的就是name1234&lt;select id="selectUser" resultType="User" databaseId="oracle"&gt; select * from t_user where id = #&#123;id&#125; &lt;/select&gt; 获取的就是 value 123456789101112131415错误:MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。 MyBatis 会加载不带 databaseId 属性和带有匹配当前数据库 databaseId 属性的所有语句。 如果同时找到带有 databaseId 和不带 databaseId 的相同语句，则后者会被舍弃。 为支持多厂商特性只要像下面这样在 mybatis-config.xml 文件中加入 databaseIdProvider 即可. 我们经常会直接复制那段代码&lt;databaseIdProvider type="DB_VENDOR"&gt; &lt;property name="SQL Server" value="sqlserver"/&gt; &lt;property name="DB2" value="db2"/&gt; &lt;property name="Oracle" value="oracle" /&gt;&lt;/databaseIdProvider&gt;没有mysql手动添加时 name写成了Mysql ！！！！！注意na me属性值是MySQL,这个y一定要小写&lt;property name="MySQL" value="mysql" /&gt; 映射文件，把对象映射关系型数据库的一条数据，从主配置文件通过mappers1234&lt;mappers&gt; &lt;!-- &lt;mapper resource="com/neusoft/mybatis/mapping/UserMapper.xml" /&gt; --&gt; &lt;package name="com.neusoft.mybatis.dao.UserMapper"&gt;&lt;/package&gt;&lt;/mappers&gt; mybatis中 1、parameterType这样的输入参数的属性，通常情况下我们是可以省略的2、 事务默认是手动提交的，（在ORM框架下，大部分需要手动提交）sqlSession的openSession方法中，是autoCommit通过一句话sqlSession.commit();更新3、 如何返回 插入数据中生成的主键值通过useGeneratedKeys=”true” keyProperty=”id”生成的主键,再赋给user.id4、Mybatis对于参数的处理问题上 1)传递单个参数： mybatis会将这个参数不会做特殊的处理 2)多参数传递： 如果不按照参数mybatis 的参数处理的规则，会报一个错误Parameter '0' not found. Available parameters are [arg1, arg0, param1, param2]123456789 3.4.2版本之前org.apache.ibatis.binding.BindingException: Parameter &apos;arg0&apos; not found. Available parameters are [0, 1, param1, param2]mybatis将多个参数封装成一个Map： key默认的值 0,1,2,3,4 param1,param2,param3,param4 #&#123;&#125;=================================================================&lt;!-- select * from t_user where user_name = #&#123;param1&#125; and password = #&#123;param2&#125; --&gt;可以在dao接口中，加入注解@Param(&quot;~&quot;)public User selectUserByUsernameAndPassword(@Param(&quot;username&quot;)String username,@Param(&quot;password&quot;)String password);用下面代替select * from t_user where user_name = #&#123;username&#125; and password = #&#123;password&#125; 3)传递多参数@param 进行命名参数XML中可以使用@param命名的value的值作为Key 4)多个参数传递可以封装为Map: XML map key 5) 传递但参数，参数是Collection(List/Set)封装为Map map key:collection或者list，如果传递的是一个数组： array5、 对于mybatis中mapper映射文件中的参数命名 我们使用 #{} ${}作用都是相同的，区别在于1)#{}以预编译的形式进行参数赋值？ JDBC preparedStatement2)${}直接拼装SQL语句，JDBC statement SQL注入问题3)# 对默认的类型类支持在Mysql中 可以为Other类型，但是Oracle或SqlServer数据库中没有，需要指定类型比如#{username,javaType=string,jdbcType=NULL}123456789101112131415161718例如 Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("username", "wangwu"); map.put("password", "123456");// map.put("id", 27); map.put("tablename", "t_user"); User user = userMapper.selectUserByMap(map); System.out.println(user); 通过log4j打印控制台=========================================userMapper.xml中select * from $&#123;tablename&#125; where user_name = #&#123;username&#125; and password =#&#123;password&#125;需要先查询到 $&#123;tablename&#125;，继续预处理 Preparing: select * from t_user where user_name = ? and password =? =》 Parameters: wangwu(String), 123456(String) 《= 查询到 total：1 User [id=27, username=wangwu, password=123456] 一条记录封装为一个map时候 返回一个map所有记录封装成Map集合的时候，应该是每一条记录中数据的类型，即user 通过@MapKey() 注解 表明把哪个属性作为那个值，否则会报Expected one result (or null) to be returned by selectOne(), but found: 86、 在mybatis中两种类型的返回值结果 1)resultType： 查询结果的类型 2)resultMap： 自定义返回结果集的封装，resultMap 可以进行关联查询使用 Assoaction 和 collection 两个标签 比如：User关联的 班级 Classroom Assoaction 有两个属性，select用的比较多，javaType javaType 的话，需要用property 设置关联的类型，这个类型里面的第几列colum 表示数据库里的，property表示 对象里面属性的名字 多表查询 Association12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;select id="getUserByIdForResultMap" resultMap="myUser"&gt; select u.id id,u.user_name user_name,u.password password, t.id cid,t.className className from t_user u,t_classroom t where u.classroom_id = t.id and u.id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap type="com.neusoft.mybatis.entity.User" id="myUser"&gt; &lt;id column="id" property="id"/&gt; &lt;!-- 当前的主键 --&gt; &lt;result column="user_name" property="username"/&gt; &lt;result column="password" property="password"/&gt; &lt;result column="cid" property="classRoom.id"/&gt; &lt;!-- 级联查询--&gt; &lt;result column="className" property="classRoom.className"/&gt; &lt;!-- &lt;association property="classRoom" javaType="com.neusoft.mybatis.entity.ClassRoom"&gt; &lt;id column="cid" property="id"/&gt; &lt;result column="className" property="className"/&gt; &lt;/association&gt; --&gt; &lt;/resultMap&gt;============================================== User user = userMapper.getUserByIdForResultMap(30); System.out.println(user.getClassRoom().getClassName()); =============================================如果 select * from t_user u,t_classroom t where u.classroom_id = t.id and u.id = #&#123;id&#125; &lt;resultMap type="com.neusoft.mybatis.entity.User" id="myUser"&gt; &lt;id column="id" property="id"/&gt; &lt;!-- 当前的主键 --&gt; &lt;result column="user_name" property="username"/&gt; &lt;result column="password" property="password"/&gt; &lt;result column="id" property="classRoom.id"/&gt; &lt;!-- 级联查询--&gt; &lt;result column="className" property="classRoom.className"/&gt; &lt;/resultMap&gt; 或者 &lt;association property="classRoom" javaType="com.neusoft.mybatis.entity.ClassRoom"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="className" property="className"/&gt; &lt;/association&gt; 通过查询班级代号 =》1班，返回List select * from t_classroom c left JOIN t_user u on u.classroom_id=c.id where c.id=#{id}; select c.id id,c.classname classname,u.id uid,u.user_name user_name,u.password password from t_classroom c left JOIN t_user u on u.classroom_id=c.id where c.id=#{id} 1234567891011121314151617181920212223242526 ClassRoomMapper classRoomMapper = sqlSession.getMapper(ClassRoomMapper.class); ClassRoom classroom = classRoomMapper.selectByPrimaryKey(1); System.out.println(classroom.getClassname());====================================================================== &lt;select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap"&gt; select c.id id,c.classname classname,u.id uid,u.user_name user_name,u.password password from t_classroom c left JOIN t_user u on u.classroom_id=c.id where c.id=#&#123;id&#125; &lt;!-- select id,className from t_classroom where id = #&#123;id,jdbcType=INTEGER&#125; --&gt; &lt;/select&gt; &lt;resultMap id="BaseResultMap" type="com.neusoft.mybatis.entity.ClassRoom"&gt; &lt;id column="id" jdbcType="INTEGER" property="id" /&gt; &lt;result column="className" jdbcType="VARCHAR" property="classname" /&gt; &lt;collection property="users" ofType="com.neusoft.mybatis.entity.User"&gt; &lt;id column="uid" property="id"/&gt; //此处改为id1，select 后面可以为* &lt;result column="user_name" property="username"/&gt; &lt;result column="password" property="password"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; 若查询班级把查询到的结果1作为 查询班级其他所有人的索引？(Mybatis里面称为 分步查询)select from t_classroom where id = 1select from t_user t where t.classroom_id = 1;123456789&lt;select id="selectByPrimaryKey" parameterType="java.lang.Integer" resultMap="BaseResultMap"&gt; select * from t_classroom where id =#&#123;id&#125;&lt;/select&gt;&lt;select id="getUsersByClassRoomID" resultMap="myUser"&gt; select * from t_user where classroom_id = #&#123;id&#125;&lt;/select&gt;&lt;collection property="users" select="com.neusoft.mybatis.dao.UserMapper.getUsersByClassRoomID" column="id"&gt;&lt;/collection&gt; ==========================================项目总的mapper.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!-- 查找用户，mysql,id、ids都可以--&gt; &lt;select id="selectUser" resultType="user" databaseId="mysql"&gt; select * from t_user where id = #&#123;ids&#125; &lt;/select&gt; &lt;select id="selectUserByUsernameAndPassword" resultType="user" databaseId="mysql"&gt; &lt;!-- select * from t_user where user_name = #&#123;param1&#125; and password = #&#123;param2&#125; --&gt; select * from t_user where user_name = #&#123;username,javaType=string,jdbcType=NULL&#125; and password = #&#123;param2&#125; &lt;/select&gt; &lt;select id="selectUserByMap" resultType="user" databaseId="mysql"&gt; select * from $&#123;tablename&#125; where user_name = #&#123;username&#125; and password =#&#123;password&#125; &lt;/select&gt; &lt;select id="selectUserByUsername" resultType="user" databaseId="mysql"&gt; select * from t_user where user_name like #&#123;username&#125; &lt;/select&gt; &lt;select id="selectUserById" resultType="map" databaseId="mysql"&gt; select * from t_user where id = #&#123;id&#125; &lt;/select&gt; &lt;select id="selectUsers" resultType="user" databaseId="mysql"&gt; select * from t_user &lt;/select&gt; &lt;select id="getUsersByClassRoomID" resultMap="myUser"&gt; select * from t_user where classroom_id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 通过用户id查询到这个人，并查询到他所在的班级 --&gt; &lt;!-- &lt;select id="getUserByIdForResultMap" resultMap="myUser"&gt; select u.id id,u.user_name user_name,u.password password,t.id cid,t.className className from t_user u,t_classroom t where u.classroom_id = t.id and u.id = #&#123;id&#125; &lt;/select&gt; --&gt; &lt;select id="getUserByIdForResultMap" resultMap="myUser"&gt; select * from t_user where id = #&#123;id&#125; &lt;/select&gt; &lt;resultMap type="com.neusoft.mybatis.entity.User" id="myUser"&gt; &lt;id column="id" property="id"/&gt; &lt;!-- 当前的主键 --&gt; &lt;result column="user_name" property="username"/&gt; &lt;result column="password" property="password"/&gt; &lt;!-- &lt;result column="cid" property="classRoom.id"/&gt; &lt;result column="className" property="classRoom.className"/&gt; --&gt; &lt;!-- &lt;association property="classRoom" javaType="com.neusoft.mybatis.entity.ClassRoom"&gt; &lt;id column="cid" property="id"/&gt; &lt;result column="className" property="className"/&gt; &lt;/association&gt; --&gt; &lt;association property="classRoom" select="com.neusoft.mybatis.dao.ClassRoomMapper.selectByPrimaryKey" column="classroom_id"&gt;&lt;/association&gt; &lt;/resultMap&gt; &lt;!-- 查找用户，oracle --&gt; &lt;select id="selectUser" resultType="user" databaseId="oracle"&gt; select * from t_user where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 添加用户，需要sqlSession.commit();提交事务 --&gt; &lt;insert id="addUser" useGeneratedKeys="true" keyProperty="id"&gt; insert into t_user(user_name,password) values(#&#123;username&#125;,#&#123;password&#125;) &lt;/insert&gt; &lt;!-- 更新用户--&gt; &lt;update id="updateUser"&gt; update t_user set user_name=#&#123;username&#125;,password=#&#123;password&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;delete id="deleteUser"&gt; delete from t_user where id = #&#123;id&#125; &lt;/delete&gt;]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的十种数据结构]]></title>
    <url>%2F%2F2019%2F07%2F26%2F2019-07-26%2F</url>
    <content type="text"><![CDATA[Algorithm二分查找算法(非递归)二分查找的非递归实现代码 12345678910111213141516171819202122232425262728293031public class BinarySearchNoRecursion &#123; public static void main(String[] args) &#123; int arr[] = &#123; 1,3,8,10,11,67,100&#125;; int index = binarySearch(arr, 1); System.out.println("index :"+index); &#125; // 二分查找的非递归实现 /** * * @param arr 待查数组,arr是升序排列 * @param target 需要查找的数 * @return 返回对应的下标，-1表示没有找到 */ public static int binarySearch(int[] arr, int target) &#123; int left = 0; int right = arr.length - 1; while(left&lt;=right) &#123; //说明继续查找 int mid = (left+right)/2; if(arr[mid] ==target) &#123; return mid; &#125;else if (arr[mid] &gt; target)&#123; right = mid - 1;//需要向左边查找 &#125;else &#123; left = mid + 1 ;//需要向右边查找 &#125; &#125; return -1; &#125;&#125; 分治算法经典的问题：二分搜索 大整数乘法 棋盘覆盖 合并排序 快速排序 线性时间选择最接近点对问题 循环赛日程表 汉诺塔 分治算法的基本步骤1)分解： 将原问题分解为若干个 规模较小，相互独立，与原问题形式相同的子问题2)解决： 若子问题规模较小而容易被解决则直接解，否则递归地解决各个子问题3)合并： 将各个子问题的解合并为原问题的解 设计模式如下 分治算法的实践-汉诺塔思路分析1)如果只有 1 个盘 A-&gt;C2)如果有n&gt;=2情况，我们总是可以看做是 两个盘1.最下边的盘， 2.上面的盘 1)先把 最上面的盘 A-&gt;B2)把最下面的盘 A-&gt;C3) 把B塔的所有盘从 B-&gt;C代码123456789101112131415161718192021222324public class Hanoitower &#123; public static void main(String[] args) &#123; hanoiTower(5, 'A', 'B','C'); &#125; /** * * @param num 有几个盘 * @param a 'A' * @param b 'B' * @param c 'C' */ public static void hanoiTower(int num, char a, char b, char c) &#123; // 如果只有一个盘 if (num == 1) &#123; System.out.println("第1个盘从 " + a + "-&gt;" + c); &#125;else &#123; //n&gt;2的情况，可以看做两个盘，1.最下面一个盘，2.上面的所有盘 hanoiTower(num - 1, a, c, b);//1.最上面：A-&gt;B，用到C塔 System.out.println("第"+ num + "个盘从 "+a+"-&gt;"+c);//2.最下边的盘A-&gt;C hanoiTower(num - 1, b, a, c);//3.B所有 B-&gt;C，用到a塔 &#125; &#125;&#125; 动态规划算法应用场景-背包问题 01背包不能重复完全背包指的 有无限件可用]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图]]></title>
    <url>%2F%2F2019%2F07%2F25%2F2019-07-25-02%2F</url>
    <content type="text"><![CDATA[图邻接矩阵 邻接表 图的实现 123456789101112131415161718// 插入结点 public void insertVertex(String vertex) &#123; vertexList.add(vertex); &#125; // 添加边 /** * * @param v1 表示点的下标即使第几个顶点"A"-"B" "A" -&gt; 0 "B" -&gt; 1 * @param v2 第二个顶点对应的下标 * @param weight 表示 */ public void insertEdge(int v1, int v2, int weight) &#123; edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++; &#125; 图的遍历介绍图的遍历两种图的遍历，即是对结点的访问，一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略： 1)深度优先遍历 2) 广度优先遍历 深度优先遍历算法步骤 123456789101112131415161718192021222324252627282930313233// 深度优先遍历的算法 /** * * @param isVisited 传入的访问过的数组 * @param i 第一次就是0 */ private void dfs(int i) &#123; // 首先访问该结点 System.out.print(getValueByIndex(i) + "-&gt;"); // 将结点设置为已经访问 isVisited[i] = true; // 查找结点的i的第一个邻接节点w int w = getFirstNeighbor(i); while (w != -1) &#123;// 说明有 if (!isVisited[w]) &#123; dfs(w); &#125; // 如果w结点已经被访问过了 w = getNextNeighbor(i, w); &#125; &#125; // 对dfs进行一个重载，遍历所有的结点，并进行dfs public void dfs() &#123; isVisited = new boolean[vertexList.size()]; // 遍历所有的结点，进行dfs(回溯) for (int i = 0; i &lt; getNumofVertex(); i++) &#123; if (!isVisited[i]) &#123; dfs(i); &#125; &#125; &#125; 广度优先遍历的算法步骤 12345678910111213141516171819202122232425262728293031323334353637383940private void bfs(boolean[] isVisited, int i) &#123; int u; // 表示队列的头结点对应下标 int w; // 表示邻接节点w // 队列，记录结点访问的顺序 LinkedList queue = new LinkedList(); // 访问结点，输出结点信息 System.out.print(getValueByIndex(i) + "=&gt;"); // 标记为已访问 isVisited[i] = true; // 加入队列 queue.addLast(i); while (!queue.isEmpty()) &#123; // 取出队列的头结点下标 u = (Integer) queue.removeFirst(); // 得到第一个邻接节点的下标w w = getFirstNeighbor(u); while (w != -1) &#123;// 找到 // 是否访问过 if (!isVisited[w]) &#123; System.out.print(getValueByIndex(w) + "=&gt;"); isVisited[w] = true; // 入队 queue.addLast(w); &#125; // 以u，为结点，找w后面的下一个邻接点 w = getNextNeighbor(u, w); &#125; &#125; &#125; // 遍历所有的结点，都进行广度优先搜索 public void bfs() &#123; isVisited = new boolean[vertexList.size()]; for (int i = 0; i &lt; getNumofVertex(); i++) &#123; if (!isVisited[i]) &#123; bfs(isVisited, i); &#125; &#125; &#125; 源码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200public class Graph &#123; private ArrayList&lt;String&gt; vertexList; // 存储定点集合 private int[][] edges; // 存储图对应的邻接矩阵 private int numOfEdges; // 表示边的数目 public boolean[] isVisited; // 表示是否被访问 public static void main(String[] args) &#123; int n = 8;// String Vertexs[] = &#123; "A", "B", "C", "D", "E"&#125;; String Vertexs[] = &#123; "1", "2", "3", "4", "5", "6", "7", "8" &#125;; Graph graph = new Graph(n); // 循环添加顶点 for (String vertex : Vertexs) &#123; graph.insertVertex(vertex); &#125; // 添加边 // A-B A-C B-C B-D B-E /*graph.insertEdge(0, 1, 1); graph.insertEdge(0, 2, 1); graph.insertEdge(1, 2, 1); graph.insertEdge(1, 2, 1); graph.insertEdge(1, 3, 1); graph.insertEdge(1, 4, 1);*/ graph.insertEdge(0, 1, 1); graph.insertEdge(0, 2, 1); graph.insertEdge(1, 3, 1); graph.insertEdge(1, 4, 1); graph.insertEdge(3, 7, 1); graph.insertEdge(4, 7, 1); graph.insertEdge(2, 5, 1); graph.insertEdge(2, 6, 1); graph.insertEdge(5, 6, 1); graph.showGraph(); System.out.println("深度优先搜索"); graph.dfs(); System.out.println(); System.out.println("广度优先搜索"); graph.bfs(); &#125; // 构造器 public Graph(int n) &#123; // 初始化矩阵和vertexList edges = new int[n][n]; vertexList = new ArrayList&lt;&gt;(n); numOfEdges = 0; isVisited = new boolean[n]; &#125; // 得到第一个领接结点的下标w /** * * @param index * @return 如果存在就返回对应的下标，否则就返回-1 */ public int getFirstNeighbor(int index) &#123; for (int j = 0; j &lt; vertexList.size(); j++) &#123; if (edges[index][j] &gt; 0) &#123; return j; &#125; &#125; return -1; &#125; // 根据前一个邻接节点的下标得到下一个领接结点的下标w public int getNextNeighbor(int v1, int v2) &#123; for (int j = v2 + 1; j &lt; vertexList.size(); j++) &#123; if (edges[v1][j] &gt; 0) &#123; return j; &#125; &#125; return -1; &#125; // 深度优先遍历的算法 /** * * @param isVisited 传入的访问过的数组 * @param i 第一次就是0 */ private void dfs(int i) &#123; // 首先访问该结点 System.out.print(getValueByIndex(i) + "-&gt;"); // 将结点设置为已经访问 isVisited[i] = true; // 查找结点的i的第一个邻接节点w int w = getFirstNeighbor(i); while (w != -1) &#123;// 说明有 if (!isVisited[w]) &#123; dfs(w); &#125; // 如果w结点已经被访问过了 w = getNextNeighbor(i, w); &#125; &#125; // 对dfs进行一个重载，遍历所有的结点，并进行dfs public void dfs() &#123; isVisited = new boolean[vertexList.size()]; // 遍历所有的结点，进行dfs(回溯) for (int i = 0; i &lt; getNumofVertex(); i++) &#123; if (!isVisited[i]) &#123; dfs(i); &#125; &#125; &#125; private void bfs(boolean[] isVisited, int i) &#123; int u; // 表示队列的头结点对应下标 int w; // 表示邻接节点w // 队列，记录结点访问的顺序 LinkedList queue = new LinkedList(); // 访问结点，输出结点信息 System.out.print(getValueByIndex(i) + "=&gt;"); // 标记为已访问 isVisited[i] = true; // 加入队列 queue.addLast(i); while (!queue.isEmpty()) &#123; // 取出队列的头结点下标 u = (Integer) queue.removeFirst(); // 得到第一个邻接节点的下标w w = getFirstNeighbor(u); while (w != -1) &#123;// 找到 // 是否访问过 if (!isVisited[w]) &#123; System.out.print(getValueByIndex(w) + "=&gt;"); isVisited[w] = true; // 入队 queue.addLast(w); &#125; // 以u，为结点，找w后面的下一个邻接点 w = getNextNeighbor(u, w); &#125; &#125; &#125; // 遍历所有的结点，都进行广度优先搜索 public void bfs() &#123; isVisited = new boolean[vertexList.size()]; for (int i = 0; i &lt; getNumofVertex(); i++) &#123; if (!isVisited[i]) &#123; bfs(isVisited, i); &#125; &#125; &#125; // 图中常用的方法 // 显示图所对应的矩阵 public void showGraph() &#123; for (int[] link : edges) &#123; System.out.println(Arrays.toString(link)); &#125; &#125; // 返回结点的个数 public int getNumofVertex() &#123; return vertexList.size(); &#125; // 得到边的数目 public int getNumodEdges() &#123; return numOfEdges; &#125; // 返回结点i(下标) 对应的数据 0-&gt;"A" 1 -&gt; "B" 2 -&gt; "C" public String getValueByIndex(int i) &#123; return vertexList.get(i); &#125; // 返回v1 和 v2 的权值 public int getWeight(int v1, int v2) &#123; return edges[v1][v2]; &#125; // 插入结点 public void insertVertex(String vertex) &#123; vertexList.add(vertex); &#125; // 添加边 /** * * @param v1 表示点的下标即使第几个顶点"A"-"B" "A" -&gt; 0 "B" -&gt; 1 * @param v2 第二个顶点对应的下标 * @param weight 表示 */ public void insertEdge(int v1, int v2, int weight) &#123; edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平衡二叉树、B树]]></title>
    <url>%2F%2F2019%2F07%2F25%2F2019-07-25%2F</url>
    <content type="text"><![CDATA[平衡二叉树简介平衡二叉搜索树(Self-balancing binary search tree)又被称为AVL树，可以保证查询效率较高。针对于 存在一些问题。特点：它是一颗空树或它的左右子树的高度差的绝对值不超过1，并且 左右两个子树都是一颗平衡二叉树。平衡二叉树常用实现方法： 红黑树、AVL(算法)、替罪羊树、Treap、 伸展树刷题：补充 进行左旋转思路分析： 1、创建新的结点，以当前根结点的值 2、把新的结点的左子树设置成当前二级店的左子树 3、把新的结点的右子树设置成当前结点的右子树的左子树 4、把当前结点的值 替换为 右子树的值 5、把当前结点的右子树 设置成 当前结点的右子树的右子树 6、把当前结点的左子树(左子结点)设置成新的结点 123456789101112131415// 左旋转的方法private void leftRotate() &#123; // 1、创建新的结点，以当前根结点的值 Node newNode = new Node(value); // 2、把新的结点的左子树设置成当前二级店的左子树 newNode.left = left; // 3、把新的结点的右子树设置成当前结点的右子树的左子树 newNode.right = right.left; // 4、把当前结点的值 替换为 右子树的值 value = right.value; // 5、把当前结点的右子树 设置成 当前结点的右子树的右子树 right = right.right; // 6、把当前结点的左子树(左子结点)设置成新的结点 left = newNode;&#125; 进行右旋转思路分析：情况相反，不做赘述123456789右旋转的方法private void rightRotate() &#123; Node newNode = new Node(value); newNode.right = right; newNode.left = left.right; value = left.value; left = left.left; right = newNode;&#125; 出现了一个问题 12345678910111213141516171819202122232425 // 当添加完一个结点后，如果(右子树的高度比左子树的高度) &gt; 1，左旋转 if (rightHeight() - leftHeight() &gt; 1) &#123; // 它的右子树的 左子树的高度大于右子树高度 // 先对右子树结点进行右旋转，然后对当前结点左旋转 if (right != null &amp;&amp; right.rightHeight() &lt; right.leftHeight()) &#123; right.rightRotate(); leftRotate(); &#125; else &#123; leftRotate(); &#125; return; // 执行了一次，不用再判断了 ！！！ &#125; // 当添加完一个结点后，如果(左子树的高度比右子树的高度) &gt; 1，右旋转 if (leftHeight() - rightHeight() &gt; 1) &#123; // 如果左子树的 右子树高度大于它的左子树的高度 // 1、先对当前结点的左结点(左子树)-&gt;右旋转，2、再对当前结点右旋转 if (left != null &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123; left.leftRotate(); rightRotate(); &#125; else &#123; rightRotate(); &#125; return; &#125;&#125; 完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321public class AVLTreeDemo &#123; public static void main(String[] args) &#123;// int[] arr = &#123; 4, 3, 6, 5, 7, 8 &#125;; //左旋转测试// int[] arr = &#123; 10, 12, 8, 9, 7, 6 &#125;;//右旋转测试 int[] arr = &#123; 10, 11, 7, 6, 8, 9 &#125;; // 双旋测试 // 创建一个AVLTree对象 AVLTree avlTree = new AVLTree(); // 添加的结点 for (int i = 0; i &lt; arr.length; i++) &#123; avlTree.add(new Node(arr[i])); &#125; // 遍历 System.out.println("中序遍历"); avlTree.infixOrder(); System.out.println("原来的树~~"); System.out.println("树的高度" + avlTree.getRoot().height()); System.out.println("树的左子树高度" + avlTree.getRoot().leftHeight()); System.out.println("树的右子树高度" + avlTree.getRoot().rightHeight()); System.out.println("树的根结点" + avlTree.getRoot()); &#125;&#125;//创建AVLTreeclass AVLTree &#123; private Node root; // 查找要删除的结点 public Node search(int value) &#123; if (root == null) &#123; return null; &#125; else &#123; return root.search(value); &#125; &#125; // 查找父结点 public Node searchParent(int value) &#123; if (root == null) &#123; return null; &#125; else &#123; return root.searchParent(value); &#125; &#125; // 编写方法， // 1、返回的以node 为根结点的二叉排序树的最小结点的值 // 2、删除node 为根结点的二叉排序树的最小结点 /** * * @param node 传入的结点(当做二叉查找树的根结点) * @return 返回的以node 为根结点的二叉排序树的最小结点的值 */ public int delRightTreeMin(Node node) &#123; Node target = node; // 循环查找左节点，就会找到最小值 while (target.left != null) &#123; target = target.left; &#125; // 这是target 就指向了最小结点 // 删除最小结点 delNode(target.value); return target.value; &#125; // 删除结点 public void delNode(int value) &#123; if (root == null) &#123; return; &#125; else &#123; // 1. 需求先去找到 要删除的结点 targetNode Node targetNode = search(value); // 如果没有找到要删除的结点 if (targetNode == null) &#123; return; &#125; // 如果我们发现当前这颗二叉查找树 只有一个结点 if (root.left == null &amp;&amp; root.right == null) &#123; root = null; return; &#125; // 查找 targetNode的父结点 Node parent = searchParent(value); // 如果要删除的结点是叶子结点 if (targetNode.left == null &amp;&amp; targetNode.right == null) &#123; // 判断targetNode 是父结点的 左子结点 还是 右子结点 if (parent.left != null &amp;&amp; parent.left.value == value) &#123; parent.left = null; &#125; else if (parent.right != null &amp;&amp; parent.right.value == value) &#123; parent.right = null; &#125; &#125; else if (targetNode.left != null &amp;&amp; targetNode.right != null) &#123;// 删除有两颗子树的结点 int minVal = delRightTreeMin(targetNode.right); targetNode.value = minVal; &#125; else &#123;// 删除有一颗子树的结点 // 如果要删除的结点只有左子结点 if (targetNode.left != null) &#123; if (parent != null) &#123; // 如果targetNode 是 parent 的左子结点 if (parent.left.value == value) &#123; parent.left = targetNode.left; &#125; else &#123; // targetNode 是parent的右子结点 parent.right = targetNode.left; &#125; &#125; else &#123; root = targetNode.left; &#125; &#125; else &#123;// 如果要删除的结点有 右子结点 if (parent != null) &#123; // 如果targetNode 是parent 的右子结点 if (parent.left.value == value) &#123; parent.left = targetNode.right; &#125; else &#123; parent.right = targetNode.right; &#125; &#125; else &#123; root = targetNode.right; &#125; &#125; &#125; &#125; &#125; public Node getRoot() &#123; return root; &#125; // 添加结点的方法 public void add(Node node) &#123; if (root == null) &#123; root = node; &#125; else &#123; root.add(node); &#125; &#125; // 中序遍历 public void infixOrder() &#123; if (root != null) &#123; root.infixOrder(); &#125; else &#123; System.out.println("不能遍历"); &#125; &#125;&#125;//创建Node结点class Node &#123; int value; Node left; Node right; public Node(int value) &#123; this.value = value; &#125; // 返回左子树的高度 public int leftHeight() &#123; if (left == null) &#123; return 0; &#125; return left.height(); &#125; // 返回右子树的高度 public int rightHeight() &#123; if (right == null) &#123; return 0; &#125; return right.height(); &#125; // 返回当前结点的高度，以该结点为根结点的树的高度 public int height() &#123; return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height()) + 1; &#125; // 左旋转的方法 private void leftRotate() &#123; // 1、创建新的结点，以当前根结点的值 Node newNode = new Node(value); // 2、把新的结点的左子树设置成当前二级店的左子树 newNode.left = left; // 3、把新的结点的右子树设置成当前结点的右子树的左子树 newNode.right = right.left; // 4、把当前结点的值 替换为 右子树的值 value = right.value; // 5、把当前结点的右子树 设置成 当前结点的右子树的右子树 right = right.right; // 6、把当前结点的左子树(左子结点)设置成新的结点 left = newNode; &#125; // 右旋转的方法 private void rightRotate() &#123; Node newNode = new Node(value); newNode.right = right; newNode.left = left.right; value = left.value; left = left.left; right = newNode; &#125; // 查找要删除的结点 /** * * @param value 希望删除的结点的值 * @return 如果找到 返回该结点，否则返回null */ public Node search(int value) &#123; if (value == this.value) &#123;// 找到就是该结点 return this; &#125; else if (value &lt; this.value) &#123;// 如果查找的值小于当前结点，向左子树递归查找 // 如果左子结点为空 if (this.left == null) &#123; return null; &#125; return this.left.search(value); &#125; else &#123; // 如果查找的值不小于当前结点，向右子树递归查找 if (this.right == null) &#123; return null; &#125; return this.right.search(value); &#125; &#125; // 查找要删除的父结点 /** * * @param value 要找到的结点的值 * @return 返回的是要删除的结点的父结点，如果没有就返回null */ public Node searchParent(int value) &#123; // 如果当前结点 就是要删除的结点的父结点， 就返回 if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) &#123; return this; &#125; else &#123; // 如果查找的值小于当前 结点的值，并且当前结点的左子结点不为空 if (value &lt; this.value &amp;&amp; this.left != null) &#123; return this.left.searchParent(value); &#125; else if (value &gt;= this.value &amp;&amp; this.right != null) &#123; return this.right.searchParent(value); &#125; else &#123; return null; // 没有找到 父结点 &#125; &#125; &#125; @Override public String toString() &#123; return "Node [value=" + value + "]"; &#125; // 添加结点的方法 // 递归的形式添加结点 public void add(Node node) &#123; if (node == null) &#123; return; &#125; // 判断传入的结点的值，和当前子树的根结点的值的关系 if (node.value &lt; this.value) &#123; // 如果当前结点左子结点为null if (this.left == null) &#123; this.left = node; &#125; else &#123; // 递归的向左子树添加 this.left.add(node); &#125; &#125; else &#123; // 添加的结点的值大于当前结点的值 if (this.right == null) &#123; this.right = node; &#125; else &#123; // 递归的向右子树添加 this.right.add(node); &#125; &#125; // 当添加完一个结点后，如果(右子树的高度比左子树的高度) &gt; 1，左旋转 if (rightHeight() - leftHeight() &gt; 1) &#123; // 它的右子树的 左子树的高度大于右子树高度 // 先对右子树结点进行右旋转，然后对当前结点左旋转 if (right != null &amp;&amp; right.rightHeight() &lt; right.leftHeight()) &#123; right.rightRotate(); leftRotate(); &#125; else &#123; leftRotate(); &#125; return; // 执行了一次，不用再判断了 ！！！ &#125; // 当添加完一个结点后，如果(左子树的高度比右子树的高度) &gt; 1，右旋转 if (leftHeight() - rightHeight() &gt; 1) &#123; // 如果左子树的 右子树高度大于它的左子树的高度 // 1、先对当前结点的左结点(左子树)-&gt;右旋转，2、再对当前结点右旋转 if (left != null &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123; left.leftRotate(); rightRotate(); &#125; else &#123; rightRotate(); &#125; return; &#125; &#125; // 中序遍历 public void infixOrder() &#123; if (this.left != null) &#123; this.left.infixOrder(); &#125; System.out.println(this); if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125;&#125; B树简介二叉树需要加载到内存，如果二叉树的结点少，没有什么问题，二叉树的结点很多，(比如1亿)存在问题问题1：构建二叉树时，多次进行I/O操作(海量数据存在数据库或文件中),结点海量，构建二叉树时，速度有影响问题2：结点海量，也会造成二叉树的高度很大，会降低操作速度。 多叉树多叉树1)每个节点有数据项，最多有两个子结点，如果允许每个结点可以有更多的数据项和更多的子结点，就是多叉树2) 2-3树 2-3-4树就是多叉树，通过重新组织结点，减少树的高度，能对二叉树进行优化。 B树通过重新组织结点，降低树的高度，以减少I/O读写次数来提升效率。1) 降低树的高度2) 文件系统及数据库设计者 利用 磁盘于都原理，讲一个结点的大小设为等于一个页(页的大小通常为4K)，这样每个结点只需要一次I/O 就可以完全载入。3)树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素，B树，B+树，广泛应用在文件存储系统以及数据库系统中。B-tree Balanced 平衡的意思，Mysql的 某种类型的索引是基于B树或者B+树。1)B树的 阶 ： 结点的最多子结点个数 比如说2-3树 阶 是 3,2-3-4树的 阶 是 42)B树的搜索，从根结点开始，对结点内的关键字(有序)序列进行二分查找，如果命中则结束，否则进行查询关键字所属范围的儿子结点；重复，知道所对应的儿子指针为空，或已经为叶子结点。3)关键字集合分布在整颗树中，即叶子结点 和 非叶子结点都存放数据4)搜索有可能在非叶子结点结束5)其搜索性等价于 在关键字全集内做一次二分查找 B+树B+树的搜索与 1)B树基本相同，区别是B+树只有达到叶子结点才命中(B树可以在非叶子结点命中),其性能也等价于在关键字全集做一次二分查找2)所有关键字 都出现在叶子结点的链表中(即数据只能在叶子结点(也叫稠密索引))且链表找那个的关键字(数据)恰好是有序的。3) 不可能在非叶子结点命中4) 非叶子相当于是叶子结点的索引(稀疏索引)，叶子结点相当于是存储(关键字)数据的数据层5)更适合文件索引系统6)B树和B+树各有自己的应用场景，不能说B+树完全比B树好。 B*树1)B树定义了非叶子结点关键字个数至少为(2/3)M ,即块的最低使用率为2/3,而B+树的块最低使用率为B+树的1/2.2)从第一个特点看出，B*树分配新节点的概率比B+树要低，空间使用率更高 2-3树简介1) 2-3树的所有叶子结点都在同一层(B树的条件)2) 有两个 或者没有子结点 是二节点 3)有三个子结点 或者没有子结点 叫 三节点4) 2-3树是由二节点和三节点构成的树。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉排序树-BST]]></title>
    <url>%2F%2F2019%2F07%2F24%2F2019-07-24-02%2F</url>
    <content type="text"><![CDATA[二叉排序树BST： binary Sort(Serach) Tree 对于二叉排序树的任何一个非叶子结点，要求左子结点的值比当前结点的值小，右子结点的值比当前结点的值大。 二叉树的创建和遍历1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//创建二叉排序树class BinarySortTree &#123; private Node root; // 添加结点的方法 public void add(Node node) &#123; if (root == null) &#123; root = node; &#125; else &#123; root.add(node); &#125; &#125; // 中序遍历 public void infixOrder() &#123; if (root != null) &#123; root.infixOrder(); &#125; else &#123; System.out.println("不能遍历"); &#125; &#125;&#125;//创建Node结点class Node &#123; int value; Node left; Node right; public Node(int value) &#123; this.value = value; &#125; @Override public String toString() &#123; return "Node [value=" + value + "]"; &#125; // 添加结点的方法 // 递归的形式添加结点 public void add(Node node) &#123; if (node == null) &#123; return; &#125; // 判断传入的结点的值，和当前子树的根结点的值的关系 if (node.value &lt; this.value) &#123; // 如果当前结点左子结点为null if (this.left == null) &#123; this.left = node; &#125; else &#123; // 递归的向左子树添加 this.left.add(node); &#125; &#125; else &#123; // 添加的结点的值大于当前结点的值 if (this.right == null) &#123; this.right = node; &#125; else &#123; // 递归的向右子树添加 this.right.add(node); &#125; &#125; &#125; // 中序遍历 public void infixOrder() &#123; if (this.left != null) &#123; this.left.infixOrder(); &#125; System.out.println(this); if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125;&#125; 树的样子1234567 7 / \3 10 / \ / \1 5 9 12 \ 2 二叉排序树的删除比较复杂，分为三种： 情况一一)删除 叶子结点 比如(2,5,9,12)思路1) 需要先找到要删除的结点 targetNode2) 找到 targetNode 的父节点 parent3) 确定targetNode 是 parent的左子结点 还是 右子结点4) 根据前面的情况来对应删除左子结点 parent.left = null右子结点 parent.right = null 情况二二)删除 只有一颗子树的结点 比如 {1}思路1) 需求先去找到要删除的结点 targetNode2) 找到 targetNode 的父节点 parent3) 确定 targetNode 的子结点 是左子节点还是右子结点4) 确定 targetNode 是 parent的左子结点 还是 右子结点5) 如果 targetNode 是 parent的左子结点5.1 如果 targetNode 是 parent 的左子结点 parent.left = targetNode.left5.2 如果targetNode 是 parent 的右子结点(6)如果targetNode有右子结点 _6.1 如果targetNode 是 parent 的左子结点 parent.left = targetNode.right;6.2 如果targetNode 是 parent 的右子结点 parent.right = targetNode.right; 情况三思路删除两颗子树的结点 {7,3,10}1) 需求先去找到要删除的 结点 targetNode2) 找到targetNode 的父节点 parent3) 从 targetNode 的右子树 找到最小的结点4) 用 一个临时变量 将最小的结点的值 保存 temp5) 删 除该最小的结点6) targetNode.value = temp代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271结果 2、删除 1号 中序遍历二叉排序树Node [value=0]Node [value=1]Node [value=3]Node [value=5]Node [value=7]Node [value=9]Node [value=10]Node [value=12] 删除结点之后Node [value=0]Node [value=3]Node [value=5]Node [value=7]Node [value=9]Node [value=10]Node [value=12]3、删除10号 中序遍历二叉排序树Node [value=0]Node [value=1]Node [value=3]Node [value=5]Node [value=7]Node [value=9]Node [value=10]Node [value=12] 删除结点之后Node [value=0]Node [value=1]Node [value=3]Node [value=5]Node [value=7]Node [value=9]Node [value=12]==============================================public class BinarySortTreeDemo &#123; public static void main(String[] args) &#123; int arr[] = &#123; 7,3,10,12,5,1,9,0&#125;; BinarySortTree binarySortTree = new BinarySortTree(); //循环的添加结点到二叉排序树 for (int i = 0; i &lt; arr.length; i++) &#123; binarySortTree.add(new Node(arr[i])); &#125; //中序遍历二叉排序树 System.out.println("中序遍历二叉排序树"); binarySortTree.infixOrder(); //测试删除叶子结点 System.out.println("删除结点之后");// binarySortTree.delNode(2);// binarySortTree.delNode(5);// binarySortTree.delNode(9);// binarySortTree.delNode(12); //删除有一颗子树的结点// binarySortTree.delNode(1); //删除有两颗子树的结点 binarySortTree.delNode(10); binarySortTree.infixOrder(); &#125;&#125;//创建二叉排序树class BinarySortTree &#123; private Node root; //查找要删除的结点 public Node search(int value) &#123; if(root == null) &#123; return null; &#125;else &#123; return root.search(value); &#125; &#125; //查找父结点 public Node searchParent(int value) &#123; if(root == null) &#123; return null; &#125;else &#123; return root.searchParent(value); &#125; &#125; //编写方法， //1、返回的以node 为根结点的二叉排序树的最小结点的值 //2、删除node 为根结点的二叉排序树的最小结点 /** * * @param node 传入的结点(当做二叉查找树的根结点) * @return 返回的以node 为根结点的二叉排序树的最小结点的值 */ public int delRightTreeMin(Node node) &#123; Node target = node; //循环查找左节点，就会找到最小值 while(target.left != null) &#123; target = target.left; &#125; //这是target 就指向了最小结点 //删除最小结点 delNode(target.value); return target.value; &#125; //删除结点 public void delNode(int value) &#123; if(root == null) &#123; return; &#125;else &#123; //1. 需求先去找到 要删除的结点 targetNode Node targetNode = search(value); //如果没有找到要删除的结点 if(targetNode == null) &#123; return; &#125; //如果我们发现当前这颗二叉查找树 只有一个结点 if(root.left == null &amp;&amp; root.right == null) &#123; root = null; return; &#125; //查找 targetNode的父结点 Node parent = searchParent(value); // 如果要删除的结点是叶子结点 if (targetNode.left == null &amp;&amp; targetNode.right == null) &#123; // 判断targetNode 是父结点的 左子结点 还是 右子结点 if (parent.left != null &amp;&amp; parent.left.value == value) &#123; parent.left = null; &#125; else if (parent.right != null &amp;&amp; parent.right.value == value) &#123; parent.right = null; &#125; &#125; else if (targetNode.left != null &amp;&amp; targetNode.right != null) &#123;// 删除有两颗子树的结点 int minVal = delRightTreeMin(targetNode.right); targetNode.value = minVal; &#125; else &#123;// 删除有一颗子树的结点 // 如果要删除的结点只有左子结点 if (targetNode.left != null) &#123; // 如果targetNode 是 parent 的左子结点 if (parent.left.value == value) &#123; parent.left = targetNode.left; &#125; else &#123; // targetNode 是parent的右子结点 parent.right = targetNode.left; &#125; &#125; else &#123;// 如果要删除的结点有 右子结点 // 如果targetNode 是parent 的右子结点 if (parent.left.value == value) &#123; parent.left = targetNode.right; &#125; else &#123; parent.right = targetNode.right; &#125; &#125; &#125; &#125; &#125; // 添加结点的方法 public void add(Node node) &#123; if (root == null) &#123; root = node; &#125; else &#123; root.add(node); &#125; &#125; // 中序遍历 public void infixOrder() &#123; if (root != null) &#123; root.infixOrder(); &#125; else &#123; System.out.println("不能遍历"); &#125; &#125;&#125;//创建Node结点class Node &#123; int value; Node left; Node right; public Node(int value) &#123; this.value = value; &#125; /** * * @param value 希望删除的结点的值 * @return 如果找到 返回该结点，否则返回null */ public Node search(int value) &#123; if (value == this.value) &#123;// 找到就是该结点 return this; &#125; else if (value &lt; this.value) &#123;// 如果查找的值小于当前结点，向左子树递归查找 // 如果左子结点为空 if (this.left == null) &#123; return null; &#125; return this.left.search(value); &#125; else &#123; // 如果查找的值不小于当前结点，向右子树递归查找 if (this.right == null) &#123; return null; &#125; return this.right.search(value); &#125; &#125; //查找要删除的父结点 /** * * @param value 要找到的结点的值 * @return 返回的是要删除的结点的父结点，如果没有就返回null */ public Node searchParent(int value) &#123; //如果当前结点 就是要删除的结点的父结点， 就返回 if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) &#123; return this; &#125; else &#123; //如果查找的值小于当前 结点的值，并且当前结点的左子结点不为空 if(value &lt; this.value &amp;&amp; this.left != null) &#123; return this.left.searchParent(value); &#125;else if(value &gt;= this.value &amp;&amp; this.right != null) &#123; return this.right.searchParent(value); &#125;else &#123; return null; //没有找到 父结点 &#125; &#125; &#125; @Override public String toString() &#123; return "Node [value=" + value + "]"; &#125; // 添加结点的方法 // 递归的形式添加结点 public void add(Node node) &#123; if (node == null) &#123; return; &#125; // 判断传入的结点的值，和当前子树的根结点的值的关系 if (node.value &lt; this.value) &#123; // 如果当前结点左子结点为null if (this.left == null) &#123; this.left = node; &#125; else &#123; // 递归的向左子树添加 this.left.add(node); &#125; &#125; else &#123; // 添加的结点的值大于当前结点的值 if (this.right == null) &#123; this.right = node; &#125; else &#123; // 递归的向右子树添加 this.right.add(node); &#125; &#125; &#125; // 中序遍历 public void infixOrder() &#123; if (this.left != null) &#123; this.left.infixOrder(); &#125; System.out.println(this); if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125;&#125; 注意事项：删除的结点之后10为 根结点，需要判断 父结点是不是为空，不为空执行原来代码，为空需要让根结点指向 删除之后的值。12310 /1 优化后的部分代码1234567891011121314151617181920212223if (targetNode.left != null) &#123; if (parent != null) &#123; // 如果targetNode 是 parent 的左子结点 if (parent.left.value == value) &#123; parent.left = targetNode.left; &#125; else &#123; // targetNode 是parent的右子结点 parent.right = targetNode.left; &#125; &#125;else &#123; root = targetNode.left; &#125;&#125; else &#123;// 如果要删除的结点有 右子结点 if (parent != null) &#123; // 如果targetNode 是parent 的右子结点 if (parent.left.value == value) &#123; parent.left = targetNode.right; &#125; else &#123; parent.right = targetNode.right; &#125; &#125;else &#123; root = targetNode.right; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC对Json的支持、文件上传]]></title>
    <url>%2F%2F2019%2F07%2F24%2F2019-07-24%2F</url>
    <content type="text"><![CDATA[解 决 昨天的问题针对于昨天的问题进行一下总结：两种情况12345678910&lt;!-- 1、register json测试使用 访问的是 /user2 ,源文件访问static/lib/helloworld.js &lt;script src 中的路径是 相对于项目的路径 此时 /springmvc2/user2 2、test/testException?param=0 转到success.jsp,源文件访问 ../static/lib/helloworld.js &lt;script src 中的路径是相对于项目的路径 此时 /springmvc2/test/testException 所以前者访问时 直接可以访问， 后者匹配 /test/testException 需要 ../static/lib/helloworld.js, 两者 根路径 打印都是 /springmvc2 应该为 类前面的 @RequestMapping(value = "/test/")的问题 --&gt; 8、springMVC 对于JSON的数据格式有默认的支持，默认支持的JSON 框架 为Jackson Gson Springmvc Json@ResponseBody @RequestBody 前端转为对象 用的不多。默认以Json的字符串传输application/json，返回的是一个个对象。可以直接操作对象 配置：添加 lib包，这次以Jackson需要的jar包有 (maven中导入jackson-annotations-2.8.0.jar，他会自动加载与之关联的)jackson-annotations-2.8.0.jarjackson-core-2.8.0.jarjackson-databind-2.8.0.jar此时结合以前Jsonajax 用到的js/jquery-1.8.3.js1234567891011121314151617181920212223242526272829303132333435363738@ResponseBody /*@RequestBody*/ @RequestMapping(value="testJson") public Collection&lt;User&gt; testJson()&#123; Collection&lt;User&gt; users = new ArrayList&lt;User&gt;(); users.add(new User("zhangsan","123")); users.add(new User("lisi","456")); return users; &#125;===================================&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Json 测试&lt;/title&gt;&lt;script type="text/javascript" src="static/js/jquery1.8.3.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; $(function() &#123; $("#button").click(function() &#123; $.ajax(&#123; type : "POST", url : "test/testJson", success:function(returndata) &#123; var users = returndata; alert(returndata[1].username); &#125; &#125;); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="button" value = "get connection from server" id="button"&gt; &lt;div id="div1"&gt;&lt;/div&gt;&lt;/body&gt; 文件上传mutipart处理 mutipartResolverspringmvc的文件上传基于FileUpload，SpringMVC中使用MultipartFile 类代表你上传的文件，如果进行多文件上传需要进行数组的定义SpringMVC-servlet.xml中注释为 CommonsMultipartResolver 配置CommonsMultipartResolver需要commons-io.jar包也需要commons-FileUpload-1.4.jar12345678910111213141516171819202122232425springmvc-servlet.xml &lt;bean id ="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="102400"&gt;&lt;/property&gt; &lt;property name="defaultEncoding" value="UTF-8"&gt;&lt;/property&gt; &lt;/bean&gt;=======================================Controller @RequestMapping("testFileupload") public String testFileupload(@RequestParam(value = "username",required = false) String username, @RequestParam("file") MultipartFile file) &#123; System.out.println("username" + username); System.out.println("filename" + file.getOriginalFilename());//上传的文件的名字// System.out.println(file.getInputStream()); //以流的方式 try &#123; file.transferTo(new File("d:/test/"+username+"-file.txt")); &#125; catch (IllegalStateException e) &#123; e.getMessage(); &#125; catch (IOException e) &#123; e.getMessage(); &#125; return "success"; &#125;=======================================结果上传文件，生成username-file.txt======================================= 文件下载SpringMVC ResponseEntity[byte[]]最好用原始的 OutputStream123456789101112131415161718192021 @RequestMapping("testResponseEntity") public ResponseEntity&lt;byte[]&gt; downLoadFile(HttpServletRequest request) throws Exception&#123; byte[] body = null; ServletContext sc = request.getServletContext(); InputStream is = sc.getResourceAsStream("/download/timg.jpg"); if(is!=null) &#123; body = new byte[is.available()];// 下载的文件 is.read(body); &#125; HttpHeaders headers = new HttpHeaders(); headers.add("Content-Disposition", "attachment;filename=timg.jpg"); ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;byte[]&gt;(body, headers,HttpStatus.OK); return responseEntity; &#125;======================================以附件的形式下载 自定义的视图层123456789101112131415161718192021@Component public class HelloView implements View&#123; @Override public String getContentType() &#123; return "text/html"; &#125; @Override public void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; response.getWriter().print("&lt;html&gt;&lt;p style='color:red'&gt;Hello this is defined view &lt;/p&gt;&lt;/html&gt;"); &#125; &#125;==========================================需要&lt;!-- 定义个一个能解析自定义视图 解析器的类 --&gt; &lt;bean class = "org.springframework.web.servlet.view.BeanNameViewResolver"&gt; &lt;property name="order" value="100"&gt;&lt;/property&gt; &lt;/bean&gt; 默认的视图解析器为 Integer.MAX]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[赫夫曼树]]></title>
    <url>%2F%2F2019%2F07%2F23%2F2019-07-23-02%2F</url>
    <content type="text"><![CDATA[赫夫曼树重要概念 二叉树应用之二，一为堆排序 举例： 1. 路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根节点的层数为1，则从根节点到第L层结点的路径长度为L-1 2. 结点的权及带权路径长度： 若将树中结点赋值给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。 3. 树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length),权值越大的结点离根结点越近的二叉树才是最优二叉树。 4. WPL最小的就是赫夫曼树 权值最大的结点离根结点越近 思路分析构建赫夫曼树：1)从小到大进行排序，将每一个数据，每个数据都是一个结点，每个结点可以看成一颗最简单的二叉树2)取出根结点权值最小的两颗二叉树3)组成一颗新的二叉树，该新的二叉树的根结点的权值是前面两颗二叉树根结点权值的和4)再将这颗新的二叉树，以根结点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理，得到一颗赫夫曼树。 13,7,8,3,29,6,1排序1,3,6,7,8,13,29构建的赫夫曼树应为 实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class HuffmanTree &#123; public static void main(String[] args) &#123; int arr[] = &#123; 13, 7, 8, 3, 29, 6, 1 &#125;; Node root = createHuffmanTree(arr); // 测试 preOrder(root);// 67,29,38,15,7,8,23,10,4,1,3,6,13 &#125; public static void preOrder(Node root) &#123; if (root != null) &#123; root.preOrder(); &#125; else &#123; System.out.println("是空树，不能遍历~~"); &#125; &#125; /** * * @param arr 需要创建赫夫曼树的的数组 * @return 创建好后赫夫曼树的root结点 */ public static Node createHuffmanTree(int arr[]) &#123; // 1.遍历arr数组 // 2.将arr的每个元素构成成一个Node // 将Node放入到ArrayList中 List&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); for (int value : arr) &#123; nodes.add(new Node(value)); &#125; while (nodes.size() &gt; 1) &#123; // 排序 从小到大 Collections.sort(nodes); // 取出根结点权值最小的两颗二叉树,需要注意的是：如果从大到小，取的是最后一个，最后两个。CompareTo 变- // 1)取出权值最小的结点(二叉树) Node leftNode = nodes.get(0); // 2)取出权值第二小的结点(二叉树) Node rightNode = nodes.get(1); // 3)构建一颗新的二叉树 Node parentNode = new Node(leftNode.value + rightNode.value); parentNode.left = leftNode; parentNode.right = rightNode; // 4)从ArrayList中删除处理过的二叉树 nodes.remove(leftNode); nodes.remove(rightNode); // 5)将parentNode加入到ArrayList中 nodes.add(parentNode); &#125; // 返回root结点，处理最后只剩一个权值 return nodes.get(0); &#125;&#125;//为了让Node 对象支持排序Collections集合排序//让Node 实现Comparable 接口class Node implements Comparable&lt;Node&gt; &#123; int value;// 结点权值 Node left; Node right; public Node(int value) &#123; this.value = value; &#125; // 前序遍历 public void preOrder() &#123; System.out.println(this); if (this.left != null) &#123; this.left.preOrder(); &#125; if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; @Override public String toString() &#123; return "Node [value=" + value + "]"; &#125; // 从小到大进行排序 @Override public int compareTo(Node o) &#123; return this.value - o.value; &#125;&#125; 赫夫曼编码基本介绍1)赫夫曼编码翻译为 赫夫曼编码，是一种编码方式，属于程序算法。2)赫夫曼编码式赫夫曼树在电讯通信中最经典的应用之一。3)赫夫曼编码广泛用于 数据文件压缩。 压缩率20%~90%之间4) 可变字长编码(VLC)的一种。1)i like like like java do you like a java2)d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 (空格):9 //3)按照上面出现次数构建一颗赫夫曼树，次数作为权值注意事项：如果排序方法不同，也可能构建不一样，但WPL都是一样，都是最小。比如：如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个。构建的应该是如图编码如图向左的路径为0，向右的路径为1压缩率(359-133)/359=62.9%满足前缀编码，字符的编码都不能是其他字符编码的前缀，不会造成匹配的多义性。无损的压缩方式。 创建赫夫曼树思路1)Node{ data存放数据，weight权重，left，right}2)得到XX对应的 byte[]数组3)编写一个方法，将构建赫夫曼树的Node结点放到List中 形式[Node[data=97，weight5]，Node[data=32，weight=9]]4)通过List创建对应的赫夫曼树 生成的赫夫曼树已经完成123456789101112131415161718192021222324252627282930结果：40[Node [data=32, weight=9], Node [data=97, weight=5], Node [data=100, weight=1], Node [data=101, weight=4], Node [data=117, weight=1], Node [data=118, weight=2], Node [data=105, weight=5], Node [data=121, weight=1], Node [data=106, weight=2], Node [data=107, weight=4], Node [data=108, weight=4], Node [data=111, weight=2]]赫夫曼树Node [data=null, weight=40]Node [data=null, weight=17]Node [data=null, weight=8]Node [data=108, weight=4]Node [data=null, weight=4]Node [data=106, weight=2]Node [data=111, weight=2]Node [data=32, weight=9]Node [data=null, weight=23]Node [data=null, weight=10]Node [data=97, weight=5]Node [data=105, weight=5]Node [data=null, weight=13]Node [data=null, weight=5]Node [data=null, weight=2]Node [data=100, weight=1]Node [data=117, weight=1]Node [data=null, weight=3]Node [data=121, weight=1]Node [data=118, weight=2]Node [data=null, weight=8]Node [data=101, weight=4]Node [data=107, weight=4]生成的赫夫曼编码表=&#123;32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011&#125;******huffmanCodeBytes=[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28] 整合一个类整合成一个方法：123456789101112131415161718192021main函数 String content = "i like like like java do you like a java"; byte[] contentBytes = content.getBytes(); System.out.println(contentBytes.length); // 40 byte[] huffmanCodesBytes=huffmanZip(contentBytes); System.out.println("压缩后的结果是： "+Arrays.toString(huffmanCodesBytes)+" ,长度为"+huffmanCodesBytes.length);================================//编写一个方法，将前面的方法封装起来，便于调用 /** * * @param bytes 原始的字符串对应的数组 * @return 返回是经过 赫夫曼编码处理后的字节数组(压缩后) */ private static byte[] huffmanZip(byte[] bytes) &#123; List&lt;Node&gt; nodes = getNodes(bytes); Node huffmanTreeRoot = createHuffmanTree(nodes); Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot); byte[] huffmanCodeBytes =zip(bytes, huffmanCodes); return huffmanCodeBytes; &#125; 数据解压，解码数据解压，解码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889========================================main函数中： byte[] sourceBytes = decode(huffmanCodes,huffmanCodesBytes); System.out.println("解码- ："+new String(sourceBytes)); //i like like like java do you like a java ========================================//完成数据的解压 //思路 //1.将huffmanCodeBytes [-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28] ,长度为17 // 重写先转成对应的二进制的字符串 //2. 赫夫曼编码对应的字符串"1010100.."===&gt;按照赫夫曼编码 ===&gt;"i like like like java do you like a java" //编写一个方法，完成对压缩数据的解码 /** * @param huffmanCodes 赫夫曼编码表 map * @param huffmanBytes 赫夫曼编码得到的字节数组 * @return 就是原来的字符串对应的数组 */ private static byte[] decode(Map&lt;Byte, String&gt; huffmanCodes, byte[] huffmanBytes) &#123; // 1、先得到huffmanBytes 对应的二进制的 字符串，形如1010111.. StringBuilder stringBuilder = new StringBuilder(); // 将byte数组转成 二进制的字符串 for (int i = 0; i &lt; huffmanBytes.length; i++) &#123; byte b = huffmanBytes[i]; // 判断是不是最后一个字节 boolean flag = (i == huffmanBytes.length - 1); stringBuilder.append(byteToBitString(!flag, b)); &#125; // 2、把字符串按照指定的赫夫曼编码进行解码 // 进行调换，因为反向查询a-&gt;100,100-&gt;a Map&lt;String, Byte&gt; map = new HashMap&lt;&gt;(); for (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123; map.put(entry.getValue(), entry.getKey()); &#125; // 创建一个集合，存放byte List&lt;Byte&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; stringBuilder.length();) &#123; int count = 1; boolean flag = true; Byte b = null; while (flag) &#123; // 取出一个'1'或者'0' String key = stringBuilder.substring(i, i + count);// i不动，让count移动，直到匹配到一个字符 b = map.get(key); if (b == null) &#123;// 未匹配 count++; &#125; else &#123; // 匹配 flag = false; &#125; &#125; list.add(b); i += count;// i 直接移动到count &#125; // for循环结束，list就存放了所有的字符"i like like..." // 把list 数据放入 byte[] 并返回 byte b[] = new byte[list.size()]; for (int i = 0; i &lt; b.length; i++) &#123; b[i] = list.get(i); &#125; return b; &#125; /** * 功能 ： 将一个以字符串 转换为二进制串 * @param flag 标识 是否 需要补高位，如果是true，表示需要补高位，如果是false表示不补,即最后一个字节，无需补高位 * @param b 传一个数组 * @return 是该b 对应的二进制的字符串(注意按补码返回) */ private static String byteToBitString(boolean flag, byte b) &#123; // 使用变量保存 b int temp = b;// b转为 int // 如果是正数我们还存在补高位 if (flag) &#123; temp |= 256;// 按位与256 1 000 0000 | 0000 0001 =&gt;1000 0001 &#125; String str = Integer.toBinaryString(temp); // System.out.println(str); if (flag) &#123; return str.substring(str.length() - 8); &#125; return str; &#125;=================================结果解码- ：i like like like java do you like a java 总结对文件进行压缩 ，压缩的文件 普通Zip解压不了，需要特有的编码才能解压文件。 ####代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889=================================结果压缩文件ok~~解压成功!=================================main函数 String srcFile = "d:/test/tupian.jpg"; String dstFile = "d:/test/1.zip"; zipFile(srcFile, dstFile); System.out.println("压缩文件ok~~"); // 测试解压文件 String zipFile = "d:/test/1.zip"; String dstFile2 = "d:/test/xin.docx"; unZipFile(zipFile, dstFile2); System.out.println("解压成功!");===================================//编写方法，对文件进行压缩 /** * * @param srcFile 源文件路径 * @param dstFile 目标路径 */ public static void zipFile(String srcFile,String dstFile) &#123; // 创建输出流 FileOutputStream os = null; //创建一个对象输出流 ObjectOutputStream oos = null; // 创建输入流 FileInputStream is = null; try &#123; is = new FileInputStream(srcFile); byte[] b = new byte[is.available()];// 创建一个大小一样的byte[] is.read(b); // 读文件 byte[] huffmanBytes = huffmanZip(b); // 源文件压缩 os = new FileOutputStream(dstFile); // 创建文件输出流，存放压缩文件 oos = new ObjectOutputStream(os);//创建一个和文件输出流关联的ObjectOutputStream //赫夫曼编码的字节数组写入压缩文件 oos.writeObject(huffmanBytes); //这里我们以对象流的方法写入赫夫曼编码，是为了以后恢复源文件时使用 //一定要把赫夫曼编码 写入压缩文件 oos.writeObject(huffmanCodes); &#125; catch (Exception e) &#123; // e.printStackTrace(); System.out.println(e.getMessage()); &#125; finally &#123; try &#123; is.close(); os.close(); oos.close(); &#125; catch (IOException e) &#123; System.out.println(e.getMessage()); &#125; &#125; &#125; // 编写一个放，完成对压缩文件的解压 public static void unZipFile(String zipFile, String dstFile) &#123; // 定义文件输入流 InputStream is = null; // 定一个对象输入流 ObjectInputStream ois = null; OutputStream os = null; try &#123; is = new FileInputStream(zipFile); ois = new ObjectInputStream(is); byte[] huffmanBytes = (byte[]) ois.readObject(); Map&lt;Byte, String&gt; codes = (Map&lt;Byte, String&gt;) ois.readObject(); byte[] bytes = decode(huffmanCodes, huffmanBytes); os = new FileOutputStream(dstFile); os.write(bytes); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; finally &#123; try &#123; os.close(); ois.close(); is.close(); &#125; catch (IOException e) &#123; System.out.println(e.getMessage()); &#125; &#125; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC拦截器及国际化、异常处理]]></title>
    <url>%2F%2F2019%2F07%2F23%2F2019-07-23%2F</url>
    <content type="text"><![CDATA[拦截器情景：登录成功后可以访问用户首页(main.jsp),一般情况下用户如果没有登录，是不允许直接访问的。实际上，除了注册和登录页面，其他信息访问都应该控制在用户登录完成之后；登录成功后，将用户信息存放到session里面，其他信息访问通过spring的拦截器统一处理，session获取不到用户信息，跳转到登录页面无需拦截的地址可通过配置白名单控制。 拦截器的作用springMVC的处理器拦截器类似于Servlet 开发中的过滤器Filter，用于对处理器进行预处理和后处理。SpringMVC中的Intercepter拦截器也是相当重要和相当有用的，他的主要作用是拦截用户的请求并进行相应的处理。比如通过它来进行权限验证，或者是来判断用户是否登录，或者是像12306那样 判断当前时间是否为购票时间。拦截器是对调用的Controller起作用，它提供了一种机制可以使开发者可以定义在一个请求执行的前后的代码，也可以在一个请求执行前组织其执行。比如，访问一个URL，可以先定义一个拦截器判断用户有没有权限，有权限才让访问。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 @RequestMapping(value = "testMap", method = RequestMethod.GET) public String testMap(ModelMap map) &#123; System.out.println("testMap invoked"); map.put("names", Arrays.asList("TOM","Jary","zhangsan")); map.put("string", "helloworld"); return "success";=========================== public class FirstInterceptor implements HandlerInterceptor &#123; /** * 渲染视图之后，释放资源 */ @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; // TODO Auto-generated method stub &#125; /* * * 目标方法执行完毕以后，render视图之前 修改modelAndView */ @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("111postHandle invoked"); &#125; /** * 在目标方法执行之前调用 * 返回值 false 不会去调用目标方法或者后续的拦截器 * 返回值true 调用后续的拦截器或者方法 */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("111preHandle invoked"); return true; &#125;&#125;=============================================== &lt;!-- 拦截器的配置 --&gt; &lt;mvc:interceptors&gt; &lt;bean id="i1" class="com.neusoft.interceptor.FirstInterceptor"&gt;&lt;/bean&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path="/**" /&gt; &lt;mvc:exclude-mapping path="/static/lib/helloworld.js" /&gt; &lt;bean id="i2" class="com.neusoft.interceptor.SecondInterceptor"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt;================================================访问test/testMaphelloworld [TOM, Jary, zhangsan] console：111preHandle invoked111preHandle invokedtestMap invoked222postHandle invoked111postHandle invoked111preHandle invoked111postHandle invoked 国际化国际化 i18n 封装在jdk，本身自带的jdk包12345678910@RequestMapping("testi18n") public String testI18n(Locale locale) &#123; String val = resourceBundleMessageSource.getMessage("hello", null, locale.US); System.out.println(val); return "i18n"; &#125;=============================================console (把hello转为)hi返回i18n-英语对应的网页，这是i18n英语 异常处理对自定义异常的处理 i/0123456789101112131415161718192021222324252627282930313233 @Autowired private ResourceBundleMessageSource resourceBundleMessageSource; @ExceptionHandler(&#123;ArithmeticException.class&#125;) public ModelAndView handlerArithmeticException(Exception e) &#123; ModelAndView mav = new ModelAndView("error"); mav.addObject("exception",e); return mav; &#125; @RequestMapping("testException") public String testException(@RequestParam("param")Integer id)&#123; System.out.println("result"+(10/id)); return "redirect:/WEB-INF/success"; &#125;===========================================================跳转到error界面错误： /by zero可以单独拿出来，把它放到SpringMVCExceptionHandler，注解@ControllerAdvice 可以实现，总的异常处理。如果springMVCController类中有先执行其中的处理异常的方法，再执行总的。@ControllerAdvicepublic class SpringMVCExceptionHandler &#123; @ExceptionHandler(&#123; ArithmeticException.class, ClassNotFoundException.class &#125;) public ModelAndView handlerArithmeticException(Exception e) &#123; ModelAndView mav = new ModelAndView("error"); mav.addObject("exception", e); return mav; &#125; &#125; 出现的问题 访问/static/lib/helloworld.js文件 报错 到最后解决方法为1&lt;!-- &lt;script type="text/javascript" src="../static/lib/helloworld.js"&gt;&lt;/script&gt; --&gt;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的前序、中序、后序线索化]]></title>
    <url>%2F%2F2019%2F07%2F22%2F2019-07-22-02%2F</url>
    <content type="text"><![CDATA[源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588public class ThreadBinaryTreeDemo &#123; public static void main(String[] args) &#123; //中序线索二叉树 /*HeroNode root = new HeroNode(1, "tom"); HeroNode node2 =new HeroNode(3, "jack"); HeroNode node3 =new HeroNode(6, "simth"); HeroNode node4 =new HeroNode(8, "marry"); HeroNode node5 =new HeroNode(10, "king"); HeroNode node6 =new HeroNode(14, "dim"); //二叉树，后面我们要递归创建，现在简单处理使用手动创建 root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); //测试线索化 ThreadBinaryTree threadBinaryTree = new ThreadBinaryTree(); threadBinaryTree.setRoot(root); threadBinaryTree.infixthreadNodes(); // 测试：以10号节点测试 HeroNode leftnode = node5.getLeft(); HeroNode rightnode = node5.getRight(); System.out.println("10号节点前驱结点 "+leftnode); //3 System.out.println("10号节点后继结点 "+rightnode);//1 //当线索二叉树后，不能使用原来的遍历方式 System.out.println("使用线索化的方式遍历线索化二叉树"); threadBinaryTree.threadList();// */ HeroNode root = new HeroNode(1, "A"); HeroNode node2 =new HeroNode(2, "B"); HeroNode node3 =new HeroNode(3, "C"); HeroNode node4 =new HeroNode(4, "D"); HeroNode node5 =new HeroNode(5, "E"); HeroNode node6 =new HeroNode(6, "F"); HeroNode node7 =new HeroNode(7, "G"); HeroNode node8 =new HeroNode(8, "H"); HeroNode node9 =new HeroNode(9, "I"); root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); node3.setRight(node7); node4.setLeft(node8); node4.setRight(node9); // 为了后序线索化，手动挡 node2.setParent(root); node3.setParent(root); node4.setParent(node2); node5.setParent(node2); node6.setParent(node3); node7.setParent(node3); node8.setParent(node4); node9.setParent(node4); ThreadBinaryTree threadBinaryTree = new ThreadBinaryTree(); threadBinaryTree.setRoot(root); threadBinaryTree.postOrder(); threadBinaryTree.postthreadNodes(); HeroNode leftnode = node6.getLeft(); HeroNode rightnode = node6.getRight(); System.out.println("F节点前驱结点 " + leftnode); // D System.out.println("F节点后继结点 " + rightnode);// B threadBinaryTree.postthreadList(); &#125;&#125;//实现线索化功能的二叉树 ThreadBinaryTreeclass ThreadBinaryTree &#123; private HeroNode root; //为了实现线索化，需要创建指向当前结点的前驱节点的指针 //当递归进行线索化时，pre 总是记录前一个结点，(后序线索化需要父节点) private HeroNode pre = null; public void setRoot(HeroNode root) &#123; this.root = root; &#125; // 重载threadNodes public void postthreadNodes() &#123; this.postthreadNodes(root); &#125; // 编写对二叉树进行后序线索化的方法 /** * * @param heroNode * 当前需要线索化的结点 */ public void postthreadNodes(HeroNode node) &#123; if (node == null) &#123; return; &#125; // 1.线索化左子树 postthreadNodes(node.getLeft()); // 2.线索化右子树 postthreadNodes(node.getRight()); // 3.线索化当前结点[有难度] // 处理当前结点的前驱节点，前驱线索 if (node.getLeft() == null) &#123; node.setLeft(pre);// 让当前结点的左子针指向前驱节点 node.setLefttype(1);// 修改当前节点的左子针类型 &#125; // 处理后继节点，后继线索 if (pre != null &amp;&amp; pre.getRight() == null) &#123; pre.setRight(node);// 让前驱节点的右指针指向当前结点 pre.setRighttype(1); &#125; // ！！！每处理完一个节点后，让当前结点是下一个结点的前驱结点 pre = node; &#125; // 遍历中序线索化二叉树的方法,按照后序遍历方式遍历 public void postthreadList() &#123; // 定义一个变量，存储当前遍历的结点，从root开始 HeroNode node = root; while (node != null) &#123; // 循环找到lefttype==1的结点. // 后面随着遍历而变化，因为lefttype==1，说明该结点是按照线索化 // 处理后的结点 while (node.getLefttype() == 0) &#123; node = node.getLeft(); &#125; // 如果当前结点的右指针指向的是后继结点，就一直输出 while (node.getRighttype() == 1) &#123; System.out.println(node); pre = node; node = node.getRight(); &#125; while (node.getRight() == pre) &#123; System.out.println(node); if (node == root) &#123; return; &#125; pre = node; node = node.getParent(); &#125; // 替换这个遍历的结点 node = node.getRight(); &#125; &#125; // 重载threadNodes public void infixthreadNodes() &#123; this.infixthreadNodes(root); &#125; // 编写对二叉树进行中序线索化的方法 /** * * @param heroNode * 当前需要线索化的结点 */ public void infixthreadNodes(HeroNode node) &#123; if (node == null) &#123; return; &#125; // 1.线索化左子树 infixthreadNodes(node.getLeft()); // 2.线索化当前结点[有难度] // 处理当前结点的前驱节点 // 以8为例，8.left=null,8.lefttype=1 if (node.getLeft() == null) &#123; // 让当前结点的左子针指向前驱节点 node.setLeft(pre); // 修改当前节点的左子针类型 node.setLefttype(1); &#125; // 处理后继节点 if (pre != null &amp;&amp; pre.getRight() == null) &#123; // 让前驱节点的右指针指向当前结点 pre.setRight(node); pre.setRighttype(1); &#125; // ！！！没处理完一个节点后，让当前结点是下一个结点的前驱结点 pre = node; // 3.线索化右子树 infixthreadNodes(node.getRight()); &#125; // 遍历中序线索化二叉树的方法,按照前驱遍历方式遍历 public void infixthreadList() &#123; // 定义一个变量，存储当前遍历的结点，从root开始 HeroNode node = root; while (node != null) &#123; // 循环找到lefttype==1的结点，第一个找到就是8结点 // 后面随着遍历而变化，因为lefttype==1，说明该结点是按照线索化 // 处理后的结点 while (node.getLefttype() == 0) &#123; node = node.getLeft(); &#125; // 打印当前结点 System.out.println(node); // 如果当前结点的右指针指向的是后继结点，就一直输出 while (node.getRighttype() == 1) &#123; // 获取当前结点的后继结点 node = node.getRight(); System.out.println(node); &#125; // 替换这个遍历的结点 node = node.getRight(); &#125; &#125; // 重载threadNodes public void prethreadNodes() &#123; this.prethreadNodes(root); &#125; // 编写对二叉树进行前序线索化的方法 /** * * @param heroNode * 当前需要线索化的结点 */ public void prethreadNodes(HeroNode node) &#123; if (node == null) &#123; return; &#125; // 左指针为空,让当前结点的左子针指向前驱节点,前驱线索 if (node.getLeft() == null) &#123; node.setLeft(pre); node.setLefttype(1); &#125; // 处理后继节点 ，让前驱节点的后继结点指向当前结点,后继线索 if (pre != null &amp;&amp; pre.getRight() == null) &#123; pre.setRight(node); pre.setRighttype(1); &#125; pre = node; // 线索化左子树 if (node.getLefttype() == 0) &#123; prethreadNodes(node.getLeft()); &#125; // 线索化右子树 prethreadNodes(node.getRight()); &#125; // 遍历线索化二叉树的方法,按照前驱遍历方式遍历 public void prethreadList() &#123; // 定义一个变量，存储当前遍历的结点，从root开始 HeroNode node = root; while (node != null) &#123; // 循环找到lefttype==1的结点，第一个找到就是root结点 // 后面随着遍历而变化，因为lefttype==1，说明该结点是按照线索化 // 处理后的结点 while (node.getLefttype() == 0) &#123; System.out.println(node); node = node.getLeft(); &#125; // 打印当前结点 System.out.println(node); node = node.getRight(); &#125; &#125; // 删除结点 public void delNode(int no) &#123; if (root != null) &#123; // 如果只有一个结点这里判断root是不是要删除的结点 if (root.getNo() == no) &#123; root = null; &#125; else &#123; root.delNode(no); &#125; &#125; else &#123; System.out.println("空树，不能删除"); &#125; &#125; // 前序遍历测试 public void preOrder() &#123; if (this.root != null) &#123; this.root.preOrder(); &#125; else &#123; System.out.println("二叉树为空，无法遍历"); &#125; &#125; // 中序遍历测试 public void infixOrder() &#123; if (this.root != null) &#123; this.root.infixOrder(); &#125; else &#123; System.out.println("二叉树为空，无法遍历"); &#125; &#125; // 后序遍历测试 public void postOrder() &#123; if (this.root != null) &#123; this.root.postOrder(); &#125; else &#123; System.out.println("二叉树为空，无法遍历"); &#125; &#125; // 前序遍历 public HeroNode preOrderSerach(int no) &#123; if (root != null) &#123; return root.preOrderSearch(no); &#125; else &#123; return null; &#125; &#125; // 中序遍历 public HeroNode infixOrderSearch(int no) &#123; if (root != null) &#123; return root.infixOrderSearch(no); &#125; else &#123; return null; &#125; &#125; // 后序遍历 public HeroNode postOrderSearch(int no) &#123; if (root != null) &#123; return root.postOrderSearch(no); &#125; else &#123; return null; &#125; &#125;&#125;class HeroNode &#123; private int no; private String name; private HeroNode left;// 默认为空 private HeroNode right;// 默认为空 private HeroNode parent;// 为后序线索化 所用,父结点指针 // 说明 // 1.如果lefttype==0表示指向左子树，lefttype==1表示指向前驱节点 // 2.如果righttype==0表示指向右子树，righttype==1表示指向后继节点 private int lefttype; private int righttype; public int getLefttype() &#123; return lefttype; &#125; public void setLefttype(int lefttype) &#123; this.lefttype = lefttype; &#125; public int getRighttype() &#123; return righttype; &#125; public void setRighttype(int righttype) &#123; this.righttype = righttype; &#125; public HeroNode(int no, String name) &#123; super(); this.no = no; this.name = name; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public HeroNode getLeft() &#123; return left; &#125; public void setLeft(HeroNode left) &#123; this.left = left; &#125; public HeroNode getRight() &#123; return right; &#125; public void setRight(HeroNode right) &#123; this.right = right; &#125; public HeroNode getParent() &#123; return parent; &#125; public void setParent(HeroNode parent) &#123; this.parent = parent; &#125; @Override public String toString() &#123; return "HeroNode [no=" + no + ", name=" + name + "]"; &#125; /** * 1)如果删除的结点是叶子结点，则删除该节点 * 2)如果删除的结点是非叶子结点，则删除该子树 * @param no */ public void delNode(int no ) &#123; /** * 思路 * 1、因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除的结点 * 2.如果当前结点的左子结点不为空，并且左子节点就是需要删除结点，就将 * this.left=null;并且就返回(结束递归删除) * 3. 如果当前结点的右子结点不为空，并且右子结点就是要删除的结点，就将 * this.right=null;并且就返回(结束递归删除) * 4. 如果第二步，第三步没有删除结点，那么我们就需要向左子树进行递归删除 * 5.如果第4步也没有删除结点，则应对对右子树进行递归删除。 * 6. 考虑如果树是空树 root，如果只有一个root结点，则将二叉树置空 */ // 2.如果当前结点的左子结点不为空，并且左子节点就是需要删除结点，就将this.left=null;并且就返回(结束递归删除) if (this.left != null &amp;&amp; this.left.no == no) &#123; this.left = null; return; &#125; // 3.如果当前结点的右子结点不为空，并且右子节点就是需要删除结点，就将this.right=null;并且就返回(结束递归删除) if (this.right != null &amp;&amp; this.right.no == no) &#123; this.right = null; return; &#125; // 4.需要向左子树递归删除 if (this.left != null) &#123; this.left.delNode(no); &#125; // 5.需要向右子树递归删除 if (this.right != null) &#123; this.right.delNode(no); &#125; &#125; // 前序遍历 public void preOrder() &#123; System.out.println(this);// 先输出父节点 // 递归向左子树前序遍历 if (this.left != null) &#123; this.left.preOrder(); &#125; // 递归向右子树前序遍历 if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; // 中序遍历 public void infixOrder() &#123; // 递归向左子树前序遍历 if (this.left != null) &#123; this.left.infixOrder(); &#125; System.out.println(this);// 输出父节点 // 递归向右子树前序遍历 if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125; // 后序遍历 public void postOrder() &#123; // 递归向左子树前序遍历 if (this.left != null) &#123; this.left.postOrder(); &#125; // 递归向右子树前序遍历 if (this.right != null) &#123; this.right.postOrder(); &#125; System.out.println(this);// 输出父节点 &#125; // 前序遍历查找 public HeroNode preOrderSearch(int no) &#123; if (this.no == no) &#123; return this; &#125; // 1.则判断当前结点的左子结点是否为空，如果不为空，递归前序查找 // 2.如果做地柜前序查找，找到结点，则返回 HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.preOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; // 1.左递归前序查找，找到结点，则返回，否继续判断 // 2.当前的结点的右子结点是否为空，如果不为空，则继续向右递归前序查找 if (this.right != null) &#123; resNode = this.right.preOrderSearch(no); &#125; return resNode; &#125; // 中序遍历查找 public HeroNode infixOrderSearch(int no) &#123; // 1.则判断当前结点的左子结点是否为空，如果不为空，递归中序查找 HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.infixOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; // 2.如果做地柜前序查找，找到结点，则返回 // System.out.println("进入中序查找"); if (this.no == no) &#123; return this; &#125; // 否则向右递归中序查找 if (this.right != null) &#123; resNode = this.right.infixOrderSearch(no); &#125; return resNode; &#125; // 后序遍历查找 public HeroNode postOrderSearch(int no) &#123; // 1.则判断当前结点的左子结点是否为空，如果不为空，递归后序查找 HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.postOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; if (this.right != null) &#123; resNode = this.right.postOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; // 如果左右子树都不是，比较根节点 System.out.println("进入后序遍历查找"); if (this.no == no) &#123; return this; &#125; return resNode; &#125;&#125;结果：输出以后序线索化为例HeroNode [no=8, name=H]HeroNode [no=9, name=I]HeroNode [no=4, name=D]HeroNode [no=5, name=E]HeroNode [no=2, name=B]HeroNode [no=6, name=F]HeroNode [no=7, name=G]HeroNode [no=3, name=C]HeroNode [no=1, name=A]F节点前驱结点 HeroNode [no=2, name=B]F节点后继结点 HeroNode [no=7, name=G]HeroNode [no=8, name=H]HeroNode [no=9, name=I]HeroNode [no=4, name=D]HeroNode [no=5, name=E]HeroNode [no=2, name=B]HeroNode [no=6, name=F]HeroNode [no=7, name=G]HeroNode [no=3, name=C]HeroNode [no=1, name=A]]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F%2F2019%2F07%2F22%2F2019-07-22%2F</url>
    <content type="text"><![CDATA[作业:使用前序线索化二叉树，后序线索化二叉树 前序线索化二叉树12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//遍历线索化二叉树的方法,按照前驱遍历方式遍历 public void infixthreadList() &#123; // 定义一个变量，存储当前遍历的结点，从root开始 HeroNode node = root; while (node != null) &#123; // 循环找到lefttype==1的结点，第一个找到就是8结点 // 后面随着遍历而变化，因为lefttype==1，说明该结点是按照线索化 // 处理后的结点 while (node.getLefttype() == 0) &#123; node = node.getLeft(); &#125; // 打印当前结点 System.out.println(node); // 如果当前结点的右指针指向的是后继结点，就一直输出 while (node.getRighttype() == 1) &#123; // 获取当前结点的后继结点 node = node.getRight(); System.out.println(node); &#125; // 替换这个遍历的结点 node = node.getRight(); &#125; &#125; //重载threadNodes public void infixthreadNodes() &#123; this.infixthreadNodes(root); &#125; //编写对二叉树进行中序线索化的方法 /** * * @param heroNode 当前需要线索化的结点 */ public void infixthreadNodes(HeroNode node) &#123; if (node == null) &#123; return; &#125; //1.线索化左子树 infixthreadNodes(node.getLeft()); //2.线索化当前结点[有难度] //处理当前结点的前驱节点 //以8为例，8.left=null,8.lefttype=1 if (node.getLeft() == null) &#123; // 让当前结点的左子针指向前驱节点 node.setLeft(pre); // 修改当前节点的左子针类型 node.setLefttype(1); &#125; //处理后继节点 if (pre != null &amp;&amp; pre.getRight() == null) &#123; // 让前驱节点的右指针指向当前结点 pre.setRight(node); pre.setRighttype(1); &#125; // ！！！没处理完一个节点后，让当前结点是下一个结点的前驱结点 pre = node; // 3.线索化右子树 infixthreadNodes(node.getRight()); &#125;结果HeroNode [no=1, name=A]HeroNode [no=2, name=B]HeroNode [no=4, name=D]HeroNode [no=8, name=H]HeroNode [no=9, name=I]HeroNode [no=5, name=E]HeroNode [no=3, name=C]HeroNode [no=6, name=F]HeroNode [no=7, name=G]F节点前驱结点 HeroNode [no=3, name=C]F节点后继结点 HeroNode [no=7, name=G]HeroNode [no=1, name=A]HeroNode [no=2, name=B]HeroNode [no=4, name=D]HeroNode [no=8, name=H]HeroNode [no=9, name=I]HeroNode [no=5, name=E]HeroNode [no=3, name=C]HeroNode [no=6, name=F]HeroNode [no=7, name=G] 后序线索化二叉树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 需要在Heronode中添加 指向父节点的指针 Heronode parent; set、get方法 // 重载threadNodes public void postthreadNodes() &#123; this.postthreadNodes(root); &#125; // 编写对二叉树进行后序线索化的方法 /** * * @param heroNode * 当前需要线索化的结点 */ public void postthreadNodes(HeroNode node) &#123; if (node == null) &#123; return; &#125; // 1.线索化左子树 postthreadNodes(node.getLeft()); // 2.线索化右子树 postthreadNodes(node.getRight()); // 3.线索化当前结点[有难度] // 处理当前结点的前驱节点，前驱线索 if (node.getLeft() == null) &#123; node.setLeft(pre);// 让当前结点的左子针指向前驱节点 node.setLefttype(1);// 修改当前节点的左子针类型 &#125; // 处理后继节点，后继线索 if (pre != null &amp;&amp; pre.getRight() == null) &#123; pre.setRight(node);// 让前驱节点的右指针指向当前结点 pre.setRighttype(1); &#125; // ！！！每处理完一个节点后，让当前结点是下一个结点的前驱结点 pre = node; &#125;结果HeroNode [no=8, name=H]HeroNode [no=9, name=I]HeroNode [no=4, name=D]HeroNode [no=5, name=E]HeroNode [no=2, name=B]HeroNode [no=6, name=F]HeroNode [no=7, name=G]HeroNode [no=3, name=C]HeroNode [no=1, name=A]F节点前驱结点 HeroNode [no=2, name=B]F节点后继结点 HeroNode [no=7, name=G]HeroNode [no=8, name=H]HeroNode [no=9, name=I]HeroNode [no=4, name=D]HeroNode [no=5, name=E]HeroNode [no=2, name=B]HeroNode [no=6, name=F]HeroNode [no=7, name=G]HeroNode [no=3, name=C]HeroNode [no=1, name=A] 堆排序简介1、堆排序是利用堆这种数据结构而设计的排序算法，堆排序是一种选择排序，他的最坏，最好，平均时间复杂度为O(nlogn)，他也是不稳定排序。2、堆是具有以下性质的完全二叉树： 每个结点的值都＞＝其左右孩子结点的值，称为大顶堆，注意：没有要求结点的左孩子的值和右孩子的值的大小关系。3、 每个结点的值都＜＝其左右孩子结点的值，称为小顶堆4、大顶堆图例 对堆中结点按层编号，映射到数组 0 1 2 3 4 5 6 7 8arr 50 45 40 20 25 35 30 10 15 大顶堆的特点： 用于升序arr[i]&gt;=arr[2i+1]&amp;&amp;arr[i]&gt;=arr[2i+2]i为对应第几个结点，i从0开始编号 小顶堆的特点： 用于降序arr[i] &lt;=arr[2i+1] &amp;&amp; arr[i] &lt;=arr[2i+2]i为对应第几个结点，i从0开始编号 堆排序的思想基本思想为：1)将待排序序列构造成一个大顶堆2)此时，整个序列的最大值就是堆顶的根节点。3)将其与末尾元素进行交换，此时末尾就为最大值。4)然后将剩余的 n-1个元素重新构造成一个堆，这样就会得到n个元素的次小值。反复执行就能得到一个有序序列。 代码实现adjustheap关键1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * @author Administrator * 2019年7月22日 * 堆排序 * 平均O(nlogn) 最坏O(nlogn) 空间复杂度O(1) 不稳定 */public class HeapSort &#123; public static void main(String[] args) &#123; //数组升序排列-大顶堆，降序-小顶堆// int arr[] = &#123;4,6,8,5,9,100,-500,7,90,542,45,89&#125;; int[] arr = new int[8000000]; for (int i = 0; i &lt; 8000000; i++) &#123; arr[i] = (int) (Math.random() * 80000); // 生成一个[0,80000]的数随机数 &#125; Date date1 = new Date(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1str = sdf.format(date1); System.out.println("排序前的时间： " + date1str); heapSort(arr); Date date2 = new Date(); String date2str = sdf.format(date2); System.out.println("排序后的时间: " + date2str); &#125; public static void heapSort(int arr[]) &#123; int temp = 0; System.out.println("堆排序："); //分析过程：i=arr.length/2-1; 5/2-1=1 1/2-1=0 /*adjustHeap(arr, 1,arr.length); System.out.println("第一次 "+Arrays.toString(arr)); //4,9,8,5,6 adjustHeap(arr, 0, arr.length); System.out.println("第二次 "+Arrays.toString(arr)); //9,6,8,5,4 */ //1.将无序数列构建成一个堆，根据升序-大顶堆或者降序-小顶堆 for (int i = arr.length / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(arr, i, arr.length); &#125; /** * 2.将堆顶元素与末尾元素交换，将最大元素"沉到数组末端" * 3.重新调整结构满足堆定义,然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 */ for (int j = arr.length - 1; j &gt; 0; j--) &#123; //交换 temp=arr[j]; arr[j]=arr[0]; arr[0]=temp; adjustHeap(arr, 0, j);// System.out.println(Arrays.toString(arr)); &#125; System.out.println("数组="+Arrays.toString(arr)); &#125; //将一个数组(二叉树) 调整为一个大顶堆 /** * 功能：完成将以i对应的非叶子结点的树调整成大顶堆 * 举例 int arr[] = &#123;4,6,8,5,9&#125;;=&gt; i = 1 =&gt; adjustHeap =&gt; 得到&#123;4,9,8,5,6&#125; * 如果再次调用 adjustHeap 传入 i = 0 =&gt;&#123;4,9,8,5,6,&#125; =&gt; &#123;9,6,8,5,4&#125; * @param arr 待调整的数组 * @param i 表示非叶子结点在数组中的索引 * @param length 表示对多少个元素继续调整，length是在逐渐减少 */ public static void adjustHeap(int arr[],int i,int length) &#123; int temp = arr[i];//先取出当前元素的值，保存临时变量 //Begin //1.K = i * 2 + 1 k是i结点的左子结点 for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) &#123; if(k+1&lt;length&amp;&amp;arr[k]&lt;arr[k+1]) &#123;//左子结点的值小于右子结点,k+1&lt;length提高效率 k++;//k指向了右子结点 &#125; if(arr[k]&gt;temp) &#123;//如果子结点大于父节点 arr[i] = arr[k];//把较大的值赋给当前结点 i=k;//！！！i指向k，继续循环比较 &#125;else &#123; break;// &#125; &#125; //当for 循环结束后，我们已经将以i为父结点的数的最大值，放在了最顶(局部) arr[i]=temp;//将temp放在调整后的位置 &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC数值校验]]></title>
    <url>%2F%2F2019%2F07%2F21%2F2019-07-21%2F</url>
    <content type="text"><![CDATA[SpringMvc数据校验 需要的jar包为hibernate-validator.jarvalidation-api-1.1.0.jarjboss-logging-3.1.3.jarexample：12345678910111213141516171819202122232425262728293031323334353637 @NotNull private String username; @Email private String password; @Max(value=120) private Integer age; @Past private Date birthday;===================================@RequestMapping(value = "/user2", method = RequestMethod.POST) public ModelAndView register(@Valid User user, BindingResult result) &#123; if (result.getFieldErrors().size() != 0) &#123; for (FieldError FieldError : result.getFieldErrors()) &#123; System.out.println(FieldError.getField()+" "+FieldError.getDefaultMessage()); &#125; &#125; System.out.println( user.getUsername() + " " + user.getAddress() + " " + user.getAge() + " " + user.getBirthday()); ModelAndView mav = new ModelAndView(); int i = userService.addUser(user); // System.out.println(i); if (i != 0) &#123; mav.setViewName("success"); &#125; return mav; &#125; =================================password： 123age： 130birhthday ： 2019-04-13=================================结果password not a well-formed email addressage must be less than or equal to 120 com.neusoft.entity.Address@57dcd992 130 Sat Apr 13 00:00:00 CST 2019 不在 User user前加 @Valid 无法进行校验用 BindingResult result 接受这个错误，否则前端会报 400的错误]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle数据库]]></title>
    <url>%2F%2F2019%2F07%2F20%2F2019-07-20%2F</url>
    <content type="text"><![CDATA[day011.安装XP虚拟机安装的是Oracle 10g的版本，将压缩包上传到虚拟机，解压缩安装。 在远程连接安装PL/SQL Develper，推荐使用windowsXP安装，windows7或10有卸载起来很麻烦。虚拟机里安装XP和Oracle数据库，不用的时候直接删了。 我设置的网卡是NAT模式，(没插网线，桥接不了,用WIFI做的测试) 2. 配置解锁了scott用户，密码为123456，后面的orcl为实例名sqlplus system/orcl@192.168.106.128:1521/orcl 1)tools-&gt;preferences-&gt;connection中sqlplus路径 不能有中文或者空格2)确认服务器上的tnsnames.ora和linstener中的host为虚拟机ip地址默认为 主机名，可以改为192.168.106.128 对应的Ip地址3)C:\oracle\product\10.2.0\db_1\NETWORK\ADMIN里12345678910111213141516171819ORCL = (DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.106.128)(PORT = 1521)) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = orcl) ) )EXTPROC_CONNECTION_DATA = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1)) ) (CONNECT_DATA = (SID = PLSExtProc) (PRESENTATION = RO) ) ) 系统变量添加TNS_ADMIN 为tnsames.ora文件目录4) 中文乱码问题 Oracle数据库1查询select userenv('language') from dual;--AMERICAN_AMERICA.ZHS16GBK 设置一个环境变量NLS_LANG = AMERICAN_AMERICA.ZHS16GBK重新启动PLSQL输入scott，123456，会提示Connect字眼在XP系统中的服务里 安装Oracle数据库会增加几个服务12345OracleDBConsoleorcl --可以不启动,用于管理Oracle的企业管理器的服务.OracleJobSchedulerORCL --通常不启动,用于定期操作任务的服务OracleOraDb10g_home1iSQL*Plus --可以不启动,isqlplus服务,用网页执行sql,11g已经取消这个功能OracleOraDb10g_home1TNSListener --必须启动,这是临听,用于远程客户端连接你的OracleOracleServiceORCL --必须启动,这是Oracle数据库的服务 ========基本查询–1.查询出所有emp中的信息，并用中文进行字段重命名123select empno as "员工编号",ename "员工姓名",job "职位",mgr "领导编号", hiredate "入职日期",sal "工资",comm "奖金", deptno "部门编号" from emp; –2.查询emp表中员工的job信息，并去除重复信息1select distinct(job) from emp; –3.查询emp表中员工的全年的工资总和(sal总和)1select ename,12*sal from emp; –4.查询emp表中员工的全年收入总和(sal+comm的总和)1select ename,12*sal+nvl(comm,0) from emp; –5.查询emp表中员工编号，姓名–输出格式如下：编号:xxx，姓名：xxx–Concat拼接方式1select Concat(Concat('1编号: ',empno),Concat('，姓名：',ename))from emp; —-Oracle的||方式1select '2编号:'||empno||'，姓名：'||ename from emp; ========条件查询–1.查询工资大于1500的员工1select * from emp where sal &gt; 1500; –2.查询工资大于1500并且有奖金的雇员1select * from emp where sal &gt; 1500 and comm is not null; –3.查询工资大于1500或者有奖金的雇员1select * from emp where sal &gt; 1500 or comm is not null; –4.查询工资大于1500并且没有奖金的雇员1select * from emp where sal &gt; 1500 and comm is null; –5.查询员工姓名为smith的员工1select * from emp where ename = 'SMITH'; ========范围查询–1.查询工资大于1500但小于3000的全部雇员—-&gt;=,&lt;=方式1select * from emp where sal &gt;=1500 and sal &lt;= 3000; –between and方式1select * from emp where sal between 1500 and 3000; –2.查询1981-1-1到1981-12-31号入职的雇员（between and）123× select * from emp where to_char(hiredate,'yyyy-MM-dd') between '1981-1-1' and '1981-12-31'select * from emp where hiredate between to_date('1981-1-1','yyyy-MM-dd') and to_date('1981-12-31','yyyy-MM-dd') –3.查询员工编号是7369,7654,7566的员工—-OR方式1select * from emp where empno=7369 or empno=7654 or empno=7566 —-IN方式1select * from emp where empno in(7369,7654,7566) –4.查询雇员姓名是’SMITH’,’ALLEN’,’WARD’的雇员信息—-IN方式1select * from emp where ename in('SMITH','ALLEN','WARD') ========模糊查询like–1.查询所有雇员姓名中第二个字符有‘M’的雇员1select * from emp where ename like '_M%' –2.查询名字中带有‘M’的雇员1select * from emp where ename like '%M%' –3.查询雇员编号不是7369的雇员信息—-&lt;&gt;方式1select * from emp where empno &lt;&gt; 7369 —-!=方式1select * from emp where empno ！= 7369 ========排序 order by–1.查询雇员的工资进行降序排序 （升序asc，默认为升序asc）1234select ename,sal from emp order by sal desc``` --2.查询雇员的奖金并做降序排序（关于nulls first/nulls last） 默认为nulls first select ename,comm from emp order by comm desc nulls last;1--3.查询雇员的工资做降序排列并且其中奖金部分是升序排序 select ename,sal,comm from emp order by sal desc ,comm asc;1234567891011121314151617181920212223### ========单行函数```bash/*伪表，虚表：dual 没有任何的实际意义，只是为了补全Oracle查询语法*/--字符函数--1.将'smith'转换成大写--关键字:upperselect upper('smith') from dual;--2.将'SMITH'转换成小写--关键字:lowerselect lower('SMITH') from dual;将emp中所有员工姓名全转为小写select lower(ename) from emp;--3.将'smith'首字母大写--关键字:initcap将emp中所有员工姓名第一个首字母大写select initcap(ename) from emp;--4.将'helloworld'截取字符串成'hello'--关键字substrselect substr('helloworld',0,5) from dual;select substr('helloworld',1,5) from dual; 0,1 都是截得hello，ellow 是substr('helloworld',2,5)--5.获取'hello'的字符串长度--关键字lengthselect length('hello') from dual;--6.将'hello'中的l用x进行替换--关键字replaceselect replace('hello','l','x') from dual; ========数值函数–1.将15.66进行四舍五入（从-2到2）–关键字round12345select round(15.66,-2) from dual; --0select round(15.66,-1) from dual; --20select round(15.66,0) from dual; --16select round(15.66,1) from dual; --15.7select round(15.66,2) from dual; --15.66 –2.将15.66进行截断（从-2到2）–关键字trunc1234567select trunc(15.66,-2) from dual; --0select trunc(15.66,-1) from dual; --10select trunc(15.66,0) from dual; --15select trunc(15.66,1) from dual; --15.6select trunc(15.66,2) from dual; --15.66--3.对15/3进行求余数--关键字modselect mod(15,3) from dual; ========日期函数123456789--1.查询系统时间--关键字sysdateselect sysdate from dual;--2.查询雇员进入公司的周数 (sysdate-hiredate) 天数select ename,(sysdate-hiredate)/7 from emp--3.查询雇员进入公司的月数--关键字months_betweenselect ename,months_between(sysdate,hiredate) from emp;--4.求出三个月后的日期--关键字add_monthsselect emp,hiredate,add_months(hiredate,3) from emp; ========转换函数1234567891011121314--1.将系统日期显示为yyyy-mm-dd hh:mi:ss(去掉补零和24小时显示时间)--关键字to_charselect tochar(sysdate,'yyyy-mm-dd hh:mi:ss') from dual;24小时制select tochar(sysdate,'yyyy-mm-dd hh24:mi:ss') from dual;去掉其中的0select tochar(sysdate,'yyyyfm-mm-dd hh24:mi:ss') from dual;----显示成年月日select tochar(sysdate,'yyyy')||'年'||to_char(sysdate,'MM')||'月'||to_char(sysdate,'dd')||'日' from dual;--2.将字符串'1981-1-1'转换成日期类型--关键字to_dateselect to_date('1981-1-1','yyyy-MM--dd') from dual;select to_number('99') from dual;select to_char(99) from dual; ========通用函数12345--1.空值的处理函数 ,没有用0代替select nvl(comm,0) from emp;--2.nvl2(判断值,空返回值,非空返回值) select nv12(null,'1','2') from dual; --空返回'2'，非空返回'1' ========条件表达式1234567891011--1.查询员工的job内容并转成中文显示----decode方式select ename,decode(job,'CLERK','柜员','SALEMAN','销售','MANAGER','管理','其他') from emp;最后不写'其他' 会变为空----case when then end方式select ename,case job when 'CLERK' then '柜员' when 'SALEMAN' then '销售' when 'MANAGER' then '管理' else '其他' end from emp; ========多行函数12345678910111213--1.查询所有员工记录数--关键字countselect count(*) from emp;--2.查询佣金的总数--（如何查询某个字段的总数量）select sum(comm) from emp;--3.查询最低工资--关键字minselect min(sal) from emp;--4.查询最高工资--关键字maxselect max(sal) from emp;--5.查询平均工资--关键字avgselect avg(sal) from emp;--6.查询20号部门的员工工资总和select sum(sal) from emp where deptno = 20; ========分组函数12345678910--1.查询部门编号及人数--分组查询关键字group byselect deptno,count(*) from emp group by deptno;--2.查询每个部门编号及平均工资select deptno,avg(sal) from emp group by deptno;--3.查询部门名称，部门编号，平均工资select dname,emp.deptno,avg(sal) from dept,emp where dept.deptno = emp.deptno group by dname,emp.deptno;--4.查询出部门人数大于5人的部门select deptno,count(*) from emp group by deptno having count(*) &gt; 5;--5.查询部门编号，部门名称，平均工资且平均工资大于2000select emp.deptno,dname,avg(sal) from emp,dept where emp.deptno = dept.deptno group by emp.deptno,dname having avg(sal) &gt; 2000; day02第二天 -======================================多表关联查询–查询员工编号,员工姓名,员工部门编号,员工部门名称,员工部门地址,中文显示员工工资等级,及领导编号,领导姓名,领导部门编号,领导部门名称,中文显示领导工资等级1234select e1.empno,e1.ename,e1.deptno,d1.dname,d1.loc,decode(s1.grade,1,'一级',2,'二级',3,'三级',4,'四级',5,'五级')"salLevel",e1.mgr,e2.ename,e2.deptno,d2.dname,decode(s2.grade,1,'一级',2,'二级',3,'三级',4,'四级',5,'五级')"salLevel"from emp e1,dept d1,salgrade s1,emp e2,dept d2,salgrade s2 where e1.deptno = d1.deptno and e1.sal between s1.losal and s1.hisal and e1.mgr=e2.empno and e2.deptno=d2.deptno and e2.sal between s2.losal and s2.hisal; –画图 select from salgrade;select from emp;select * from dept;–1.查询员工编号,员工姓名,领导编号,领导姓名1select * from emp where sal &gt; (select sal from emp where empno = 7654); –2.查询员工编号,员工姓名,员工部门编号,员工部门名称,员工部门地址,领导编号,领导姓名,领导部门编号,领导部门名称 –3.查询员工编号,员工姓名,员工部门编号,员工部门名称,员工部门地址,员工工资等级,领导编号,领导姓名,领导部门编号,领导部门名称,领导工资等级 –4.查询员工编号,员工姓名,员工部门编号,员工部门名称,员工部门地址,中文显示员工工资等级,领导编号,领导姓名,领导部门编号,领导部门名称,中文显示领导工资等级12345678select e1.empno,e1.ename,e1.deptno,d1.dname,d1.loc,decode(s1.grade,1,&apos;一级&apos;,2,&apos;二级&apos;,3,&apos;三级&apos;,4,&apos;四级&apos;,5,&apos;五级&apos;)&quot;salLevel&quot;,e2.empno,e2.ename,e2.deptno,d2.dname,d2.loc,decode(s2.grade,1,&apos;一级&apos;,2,&apos;二级&apos;,3,&apos;三级&apos;,4,&apos;四级&apos;,5,&apos;五级&apos;)&quot;salLevel&quot; from emp e1,emp e2, dept d1,dept d2, salgrade s1 ,salgrade s2 where e1.mgr = e2.empno and e1.sal between s1.losal and s1.hisal and e1.deptno = d1.deptno and e2.sal between s2.losal and s2.hisaland e2.deptno =d2.deptno –======================================外连接–1.查询员工编号，姓名，领导编号，领导姓名，包括没领导的—-left join on方式1234以e1表为准select e1.empno,e1.ename,e2.empno,e2.enamefrom emp e1 left join emp e2 on e1.mgr = e2.empno; —-Orcl的(+)方式12以没 (+)的为准select e1.empno,e1.ename,e2.empno,e2.ename from emp e1,emp e2 where e1.mgr = e2.empno(+) –2.查询出所有部门信息(包括没员工的部门)及部门下的员工信息1select * from emp,dept where emp.deptno(+) = dept.deptno; 子查询会低一些–===========子查询–1.查询比雇员7654工资高，同时从事和7788的工作一样的员工12select * from emp where sal &gt; (select sal from emp where empno = 7654)and job =(select job from emp where empno = 7788); –2.查询每个部门最低工资及最低工资的部门名称和雇员名称12select emp.empno,emp.ename,e1.minsal,e1.deptno from (select min(sal) minsal,deptno from emp group by deptno) e1,emp ,deptwhere e1.deptno =dept.deptno and emp.deptno = e1.deptno and e1.minsal=emp.sal; –===========课堂练习–1.找到员工表中工资最高的前三名1select rownum,e.* from(select emp.* from emp order by sal desc)e where rownum &lt;= 3; –2.找到员工表中薪水大于本部门平均工资的所有员工12select emp.empno,emp.ename,e1.avgsal,e1.deptno,emp.sal from (select avg(sal) avgsal,deptno from emp group by deptno)e1,empwhere e1.deptno = emp.deptno and e1.avgsal &lt; emp.sal; –3.统计每年入职的员工个数行列转换(有难度)12345678每年部门入职select count(*),to_char(hiredate,'yyyy') from emp group by to_char(hiredate,'yyyy');求和 -14select sum(decode(hdate,'1980',hcount)) "1980",min(decode(hdate,'1981',hcount)) "1981",max(decode(hdate,'1982',hcount)) "1982",avg(decode(hdate,'1987',hcount)) "1987" from (select count(*) hcount,to_char(hiredate,'yyyy') hdate from emp group by to_char(hiredate,'yyyy'))e; –===========分页查询–1.查询员工表，将员工工资进行降序查询，并进行分页取出第一页，一页三条记录rownum 不能进行大于查询123456789101112131415161718//第一页select rownum,e.* from ( select * from emp order by sal desc)e where rownum &lt;=3//第二页select * from(select rownum r,e.* from ( select * from emp order by sal desc)e)e1 where r &gt; 3 and r&lt;=6分页公式pageNo = 0pageSize = 3select * from(select rownum r,e.* from ( select * from 表名 order by 列名 desc)e)e1 where r &gt; (pageNo - 1) * pageSize and r &lt;= pageNo * pageSize``` --===========集合运算（了解）--1.查询工资大于1200并且job是SALESMAN(intersect)```bashselect * from emp where sal &gt; 1200 and job = 'SALESMAN'select * from emp where sal &gt; 1200intersect select * from emp where job = 'SALESMAN' –2.查询工资大于1200或者job是SALESMAN(union)123456select * from emp where sal &gt; 1200 or job = 'SALESMAN'union后面（加了all），是不去重select * from emp where sal &gt; 1200unionselect * from emp where job = 'SALESMAN' –3.求工资大约1200和job是SALESMAN的差集(minus)第一个集合中有，第二个集合中没有的123select * from emp where sal &gt; 1200minusselect * from emp where job = 'SALESMAN' –==========================exists / not exists/*select … where exists(查询语句)exists：当查询结果不为null，返回true 当查询结果为null，返回false */–1.查询出有员工的部门12345select * from dep0t where exists(select * from emp where dept.deptno = emp.deptno);select * from dep0t where not exists(select * from emp where dept.deptno = emp.deptno);select * from emp where exists (select * from dept); 扩展 不是老板的员工1select * from emp e1 where not exists(select * from emp e2 where e1.empno=e2.mgr); MySQL解析SQL语言时的执行顺序：1) SELECT2) DISTINCT &lt;select_list&gt;3) FROM &lt;left_table&gt;4) &lt;join_type&gt; JOIN &lt;right_table&gt;5) ON &lt;join_condition&gt;6) WHERE &lt;where_condition&gt;7) GROUP BY &lt;group_by_list&gt;8) HAVING &lt;having_condition&gt;9) ORDER BY &lt;order_by_condition&gt;10) LIMIT &lt;limit_number&gt; day03 create 都可以 drop删READ UNCOMMITTED(读未提交数据) 允许事务读取未被其他事务提交的变更 脏读 不可重复读和幻读的问题都会出现READ COMMITTED(读已提交数据) 只允许事务读取已经被其他事务提交的变更，可以避免脏读，但不可重复度和幻读问题仍然可能出现REPEATABLE READ(可重复读) 确保事务可以多次从一个字段中读取相同的值，在这个事务持续期间，禁止其他事务对这个字段进行更新，可以避免脏读和不可重复读，但幻读的问题仍然存在。SERIALIZABLE(串行化) 确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入，更新和删除操作，所有并发问题可以避免，但性能十分低下。 Oracle支持的 3种事务隔离级别：READ COMMITE SERIALIZABLE READ ONLY, Default: read only –1.创建itcast001表空间12345create tablespcae itcast297datafile 'c:itcast297.dbf'size 100mautoextend onnext 10m; –2.创建itcastuser用户12create user itcast297 identified by itcast297default tablespace itcast297 –3.为itcastuser用户赋予dba权限1grant dba to itcast297; –删除表空间并将物理文件一并删除12DROP TABLESPACE itcast297 INCLUDING CONTENTS AND DATAFILES;drop user itcast297 cascade –===========================Oracle数据类型/Oracel数据类型字符类型 char:固定长度类型 varchar2:可变长度类型，可保存1333多个汉字数值类型 number(3):999 number(3,2):9.99日期类型 date:mysql中日月年,oracle中精确到时分秒,相当于MySQL中的datetime timestamp:精确到秒的后9位大数据类型 long:大数据字符类型,2G Clob:存放字符类型,4G Blob:存放二进制类型,4G / –===========================创建表–4.创建person表，字段为pid，pname1234create table person ( pid number, pname varchar2(50)) –==============================Oracle表中的增删改查/Oracle中的事务需要手动commit提交 /–1.为person表新增一条数据12insert into person values(1,'cgx');select * from person; –2.修改person表中的一条数据12update person set pname ='zbz' where pid = 1;commit; –3.删除person表中的一条数据12delete from person where pid = 1; commit; –==============================修改表列的属性–1.给person表增加sex性别列，类型为number(1)1alter table person add sex number(1); –2.修改person表列sex类型为char(1)1alter table person modify sex char(1); –3.修改person表sex列为gender1alter table person rename column sex to gender –4.删除person表的gender列1alter table person drop column gender; –5.删除person表中所有数据12delete person where 1=1;commit; –6.摧毁person表（truncate table 表名）/ 直接摧毁表结构后重构表，比delete要很快，但是没法按照条件删除 /1truncate table person; –=========================================约束drop table person;–1.创建person表，pid为主键，pname，gender(主键约束primary key)–primary key方式12345678create table person ( pid number primary key, pname varchar2(50), gender number)insert into person values(1,'cxk',1);commit; –constraint 主键名 primary key(字段),方式123456create table person ( pid number, pname varchar2(50), gender number, constraint PK_PID primary key(pid)) –2.创建person表，pname非空，gender(非空约束not null)1234567create table person( pid number, pname varchar2(50) not null, gender number)insert into person (pid,gender) values(2,0);commit; –3.创建person表，pid，pname是唯一，gender(唯一约束unique)123456789create table person( pid number, pname varchar2(50) unique, gender number)insert into person (pid,pname,gender) values(1,'zbz',0);commit;insert into person (pid,pname,gender) values(2,'cxk',1); –pname 为空会与唯一约束冲突吗1insert into person (pid,gender) values(2,1); –4.创建person表，pid，pname，gender—检查约束check(列名 in (值))123456create table person( pid number, pname varchar2(50), gender number check(gender in (1,0)))insert into person (pid,pname,gender) values(1,'cxk',3); –=========================================外键约束/constraint fk_order_orderid foreign key(外键) references 对应的表(对应的主键) / –1.创建orders表,字段为order_id(主键),total_price1234create table orders ( order_id number primary key, total_price number(8,2)) –2.创建order_detail表,字段为detail_id(主键),order_id(外键),item_name 123456create table order_detail( detail_id number primary key, order_id number, item_name varchar2(50), constraint FK_ORDER_ORDER_ID foreign key(order_id) references orders(order_id)) –3.为orders表和order_detail表插入数据12345678insert into orders values(1,999.99);commit;insert into order_detail values(1,1,'照相机');commit;insert into order_detail values(2,1,'胶卷');commit;select * from orders;select * from order_detail; –4.删除orders表和order_detail表中的数据12345delete from orders where order_id = 1;commit;delete from order_detail where 1=1;commit; –==========================Oracle事务（了解）–1.设置savepoint 回滚点，再次修改数据后用rollback to 回滚点，回滚数据1234567select * from person;update person set pname = 'aj' where pid = 1;savepoint p1;update person set pname = 'cxk' where pid = 1;rollback to p1;commit; –==========================视图/*视图：就是一张虚拟表，本身不存放数据，数据来源于原始表创建 create [or replace] view 视图名 as sql查询语句； */–1.创建视图1create or replace view emp_view as select empno,ename,hiredate from emp; –2.查询视图1select * from emp_view –3.修改视图中7369的名字为’smith’1234update emp_view set ename = 'smith' where empno = 7369;commit;select * from emp; --原来的数据被修改了 –4.删除视图12345drop view emp_view;update emp_view set sal = sal +1000 where empno = 7369;delete from emp_view where empno = 7499;commit; –5.创建只读视图（关键字 with read only）1create or replace view emp_view as select * from emp with read only; –==========================序列/*序列：类似于MySql的自动增长 create sequence seq_teststart with 5increment by 2maxvalue 20cyclecache 5*/12345678create sequence seq_teststart with 5 increment by 2maxvalue 20cyclecache 5select seq_test.nextval from dual; –1.创建序列1create sequence emp_seq; –2.如何查询序列（currval,nextval）1select emp_seq.nextval from dual; –3.删除序列1drop sequence emp_seq; –4.为person表插入数据，用序列为id赋值123456select * from emp;insert into emp(empno) values(9999);commit;insert into emp(empno) values(emp_seq.nextval);commit; –==========================索引/目的是提高检索速度语法：create index 索引名称 on 表名(列名);原则：大数据表才创建索引， 为经常用到的列创建索引， 索引的层数不要超过4层，也就是on 表名(列名1,列名2)这里的列名不要超过4个 / –创建索引 –删除索引 –创建500万条的数据 1234567891011121314151617create table person ( pid number, pname varchar2(50))create sequence seq_person;begin for i in 1..5000000 loop insert into person values(seq_person.nextval,'测试数据'||i); end loop; commit;end;select * from person where pname ='测试数据4769889' --1.485seconds --0.015secondscreate index person_index on person(pname) –====================================同义词（了解）/*为表创建别名同义词和视图的区别：不需要dba权限就可以创建同义词视图可以隐藏列，同义词不可以去掉列只是整张表的复制 创建create public synonym 同义词名 for 目标表名删除drop public synonym 同义词名*/12345select * from itcast297.orders;create public synonym my_orders for itcast297.orders;select * from my_orders –====================================导入导出/PLSqlDeveloper的导入导出方式参照Oracle导入导出.docx全库导出:exp system/orcl full=y file=expdat.dmp全库导入:imp system/orcl full=y file=expdat.dmp按用户导出: exp scott/tiger file=expdat.dmp按用户导入: imp scott/tiger file=expdat.dmp full=y / day04–=====================================pl/sql的使用/PLSQL定义：在数据库服务器上保存的大段可执行方法，供其他开发人员进行调用PLSQL语法：[declare] –定义部分：变量，引用变量，记录型变量，异常begin[exception] –需要捕获异常时写上end / –定义number变量，定义PI常量，定义记录型变量，定义引用型变量12345678910111213141516171819declare i number :=1; --变量 pjob varchar2(50); --定义字符 PI constant number :=3.14; --常量 pemp emp%rowtype; --定义记录型变量 pname emp.ename%type; --定义引用型变量begin select * into pemp from emp where empno = 7499; -- into给记录型变量赋值 dbms_output.put('员工编号: '||pemp.empno||' 员工姓名: '||pemp.ename); dbms_output.put_line(i); --PI :=PI+1; dbms_output.put_line(PI); select ename into pname from emp where empno = 7499; select job into pjob from emp where empno = 7499; dbms_output.put_line(pname); dbms_output.put_line(pjob);end;select * from emp for update; –=======================================if分支/if判断分支语法：begin if 判断条件 then elsif 判断条件 then else end if;end; /–从控制台输入一个数字，如果数字是1，则输出我是112345678declare age number :=&amp;age;begin if age = 1 then dbms_output.put_line('我是1'); else dbms_output.put_line('我不是1'); end if;end; –如果输入的年龄在18岁以下，输出未成年人，18~40：成年人，40以上 老年人1234567891011declare age number :=&amp;age;begin if age &lt; 18 then dbms_output.put_line('未成年人'); elsif age &gt;= 18 and age &lt;= 40 then dbms_output.put_line('中年人'); else dbms_output.put_line('老年人'); end if;end; –===========================================loop 循环/*loop循环 语法1：begin while 循环条件 loop end loop;end;语法2：(常用)begin loop exit when 退出条件 end loop;end;语法3:begin for i in 1..10 loop end loop;end; */12345678910111213141516171819202122232425262728--语法1实现在控制台输出1~10declare i number := 1;begin while i&lt;=10 loop dbms_output.put_line(i); i := i + i; end loop;end;--语法2实现在控制台输出1~10(掌握)declare i number := 1; begin loop exit when i &gt; 10; dbms_output.put_line(i); i := i + 1; end loop; end;--语法3实现在控制台输出1~10begin for i in 1..10 loop dbms_output.put_line(i); end loop;end; –====================================================光标（游标）/*光标:指定记录集，可抓取记录集中的记录语法：cursor 游标名 is select查询语句 提取游标：open 游标名; loop fetch 游标名 into 记录型变量 exit when 游标名%notfound; end loop;close 游标名;*/–使用光标输出emp表中7369的员工信息1234567891011declare cursor emp_cur is select * from emp where empno = 7499; pemp emp&amp;rowtype;begin open emp_cur; --打开游标 loop fetch emp_cur into pemp;--抓取记录 exit when emp_cur&amp;notfound; --notfound找不到记录就退出loop循环 end loop; close emp_cur; --关闭游标 end; –输出指定部门的员工信息 –给部门编号为10 的员工涨工资123456789101112131415declare cursor emp_cur(dno number) is select * from emp where deptno = dno; pemp emp%rowtype;begin open emp_cur(10); --loop fetch emp_cur into pemp; --exit when emp_cur%notfound; update emp set sal = sal + 1000 where empno = pemp.empno; --end loop commit; close emp_cur;end;select * from emp where deptno = 10; –=====================================例外（异常）–系统异常，被0除的zero_divide异常12345678910111213141516171819declare i number :=1;begin i :=i/0;exception when zero_divide then dbms_output.put_line('分母不能为0');end;--系统异常，设置错误的value_error异常declare pname varchar2(50);begin pname := 1234; dbms_output.put_line(pname);exception when value_error then dbms_output.put_line('类型赋值错误');end; –系统异常，都可以通过others异常捕获123456789declare pname number;begin pname := 'test'; dbms_output.put_line(pname);exception when others then dbms_output.put_line('最大的异常(多个异常)之一');end; –自定义异常，查询部门编号为40员工（自定义exception）123456789101112131415declare --cursor emp_cur is select * from emp where deptno = 40; no_date exception; --pemp emp%rowtype;begin -- open emp_cur; -- fetch emp_cur into pemp; --if emp_cur%notfound then raise no_date; -- end if; --close emp_cur;exception when no_date then dbms_output.put_line('自定义异常');end; –==============================================存储过程（过程）/定义：保存一段可执行的sql语句，方便开发调用过程名语法：create [or replace] procedure 过程名(参数 in|out number)asbeginend; / –声明pro_add_sal存储过程,作用是给指定员工涨1000工资,并打印出涨前和涨后工资12345678910111213141516create or replace procedure pro_add_sal(pno in number)as totalSal number;begin select sal into totalSal from emp where empno = pno; --查询工资并赋值给totalSal dbms_output.put_line(totalSal); update emp set sal = sal + 1000 where empno = pno; select sal into totalSal from emp where empno = pno; --查询后来工资 dbms_output.put_line(totalSal); commit;end;begin pro_add_sal(7499);end;select * from emp where empno = 7499; –================================================存储函数/定义：保存一段可执行的sql语句，方便开发调用过程名语法：create [or replace] function 方法名(参数 in|out number) return 参数类型as 定义变量名 类型要和return返回类型一致begin return 变量名;end; / –声明pro_emp_totalsal存储过程,查询指定员工的年薪123456789101112create or replace procedure pro_emp_totalsal(pno number,totalsal out number)as begin select sal*12+nvl(comm,0) into totalsal from emp where empno = pno;end;declare total number;begin pro_emp_totalsal(7499,total); dbms_output.put_line(total);end; –声明fun_emp_totalsal存储函数,根据部门编号查询出部门名称1234567891011121314create or replace function fun_emp_totalsal(pno number)return number--in 可忽略，out不可以as totalsal number; begin select sal*12+nvl(comm,0) into totalsal from emp where empno = pno; return totalsal;end;declare totalSal number;begin totalSal := fun_emp_totalSal(7499); dbms_output.put_line(totalSal);end; –声明fun_emp_dname存储函数,根据部门编号查询出部门名称123456789101112131415create or replace function fun_emp_dname(dno number)return emp.ename%type--varchar2as dname emp.ename%type ;begin select dname into dname from dept where deptno = dno; return dname;end;declare dname varchar2(50);begin dname := fun_emp_dname(10); dbms_output.put_line(dname);end;select * from dept; –在select 调用存储函数1select ename,fun_emp_dname(deptno) from emp; /存储过程与存储函数的区别：1.定义的语法不一样procedure,function2.function有返回值3.function可以在select中进行调用4.存储过程可以通过out类型来返回参数 / —存储过程根据部门编号返回员工12345678910111213141516171819create or replace procedure pro_emp_list(dno number,emplist out sys_refcursor)asbegin open emplist for select * from emp where deptno = dno;end;declare emplist sys_refcursor; pemp emp%rowtype;begin pro_emp_list(10,emplist); loop fetch emplist into pemp; exit when emplist%notfound; dbms_output.put_line(pemp.ename); end loop; close emplist;end; java中调用 oracle数据库用到的jar包有 ojdbc14-10.2.0.1.0.jar通过Jnit4 测试123456789101112131415161718192021222324252627public class OracleTest &#123; /** * Statement &amp; callableStatement 两种实现方式查询数据库 * @throws Exception */ @Test public void testConnection() throws Exception &#123; String driver = &quot;oracle.jdbc.driver.OracleDriver&quot;; String url = &quot;jdbc:oracle:thin:@192.168.106.128:1521:orcl&quot;; String user = &quot;scott&quot;; String password = &quot;tiger&quot;; Class.forName(driver); Connection conn = DriverManager.getConnection(url,user,password); CallableStatement call = conn.prepareCall(&quot;select * from emp&quot;); // Statement st = connection.createStatement(); //ResultSet rs = st.executeQuery(&quot;select * from emp&quot;); ResultSet rs = call.executeQuery(); while(rs.next()) &#123; System.err.println(&quot;员工编号： &quot;+ rs.getString(1)+&quot;,员工姓名： &quot;+rs.getString(&quot;ename&quot;)); &#125; rs.close(); //st.close(); call.close(); conn.close(); &#125;&#125; 调用 存储过程1234567891011121314151617181920212223@Test public void testCallProcedureAddSal() throws SQLException &#123; call = conn.prepareCall("call pro_add_sal(?)"); call.setInt(1,7499 ); call.execute(); &#125; /** * 调用存储过程返回list pro_emp_list(dno number,emplist out sys_refcursor); * @throws SQLException * */ @Test public void testCallProcedureEmpList() throws SQLException &#123; call = conn.prepareCall("&#123;call pro_emp_list(?,?)&#125;"); call.setInt(1, 10); call.registerOutParameter(2, OracleTypes.CURSOR); call.execute(); rs = ((OracleCallableStatement)call).getCursor(2); while(rs.next()) &#123; System.err.println("员工编号： "+ rs.getString(1)+",员工姓名： "+rs.getString("ename")); &#125; &#125; 调用存储函数1234567891011121314/** * 调用存储函数 fun_emp_dname(dno number) * @throws SQLException * */ @Test public void testCallFuntionEmpDname() throws SQLException &#123; call = conn.prepareCall("&#123;? = call fun_emp_dname(?)&#125;"); call.registerOutParameter(1, OracleTypes.VARCHAR); call.setInt(2, 10); call.execute(); String dname = call.getString(1); System.out.println("部门名称： " + dname); &#125; 通过before after 提取1234567891011121314151617181920212223242526272829public class OracleTest &#123; private String driver = "oracle.jdbc.driver.OracleDriver"; private String url = "jdbc:oracle:thin:@192.168.106.128:1521:orcl"; private String user = "scott"; private String password = "tiger"; private Connection conn; private CallableStatement call; private ResultSet rs; @Before public void init() throws ClassNotFoundException, SQLException &#123; Class.forName(driver); conn = DriverManager.getConnection(url,user,password); &#125; @After public void closeAll() throws SQLException &#123; if (rs != null) &#123; rs.close(); &#125; if (call != null) &#123; call.close(); &#125; if (conn != null) &#123; conn.close(); &#125; &#125;&#125; –==========================================触发器/*触发器：满足一定设定的触发条件，立即执行 语法：create [or replace] trigger 触发器名before|afterinsert|update|deleteon 表名for each row –:new,:oldbeginend; */ –添加一个员工后打印一句话“一个新员工添加成功”create or replace trigger tri_addafterinserton empbegin dbms_output.put_line(‘一个新员工添加成功’);end; insert into emp (ename) values(‘cxk2’);commit; delete from emp where empno=1;–不能在休息时间办理入职/raise_application_error(参数1，参数2);参数1：错误代码 在 -20001~ -20999‘参数2：提示错误信息 / –不能给员工降薪create or replace trigger tri_emp_salbeforeupdateon empfor each rowbegin if :new.sal&lt; :old.sal then raise_application_error(-20001,’不能降薪’); end if;end; select from emp where empno = 7499;update emp set sal = sal + 1000 where empno = 7499;commit;–触发器应用（通过序列在插入数据的时候，将ID用序列赋值）DDH_20190814_0002create or replace trigger tri_emp_insertbeforeinserton empfor each rowbegin select emp_seq.nextval into :new.empno from dual;end;select from emp; 一句话输出9*91234567891011121314151617181920select r1 || '*' || r1 || '=' || r1 * r1 A, decode(r2, '', '', r2 || '*' || r1 || '=' || r2 * r1) b, decode(r3, '', '', r3 || '*' || r1 || '=' || r3 * r1) C, decode(r4, '', '', r4 || '*' || r1 || '=' || r4 * r1) D, decode(r5, '', '', r5 || '*' || r1 || '=' || r5 * r1) E, decode(r6, '', '', r6 || '*' || r1 || '=' || r6 * r1) F, decode(r7, '', '', r7 || '*' || r1 || '=' || r7 * r1) G, decode(r8, '', '', r8 || '*' || r1 || '=' || r8 * r1) H, decode(r9, '', '', r9 || '*' || r1 || '=' || r9 * r1) I from (select level r1, lag(level, 1) over(order by level) r2, lag(level, 2) over(order by level) r3, lag(level, 3) over(order by level) r4, lag(level, 4) over(order by level) r5, lag(level, 5) over(order by level) r6, lag(level, 6) over(order by level) r7, lag(level, 7) over(order by level) r8, lag(level, 8) over(order by level) r9 from dual connect by level &lt; 10)]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC常用注解(三)、自定义类型转换]]></title>
    <url>%2F%2F2019%2F07%2F19%2F2019-07-19%2F</url>
    <content type="text"><![CDATA[Void返回类型 模型数据 SpringMVC的模型处理1)request作用域中，通过转发2) ModelAndView，底层源码也是把mav放到request中3)Map以及ModelMap中 123456789101112131415161718/*@ModelAttribute public void testModelAttribute() &#123; System.out.println("model Attribute invoked"); &#125;*/不推荐使用@ModelAttribute ,每次都先执行该方法 @RequestMapping(value = "testMap", method = RequestMethod.GET) public String testMap(ModelMap map) &#123; map.put("names", Arrays.asList("TOM","Jary","zhangsan")); map.put("string", "helloworld"); return "success"; &#125; @RequestMapping(value = "testReturn", method = RequestMethod.POST) public String testReturn(User user, HttpSession session,HttpServletRequest request) &#123; request.setAttribute("user", user);// session.setAttribute("user", user); return "success"; &#125; 处理模型数据之SessionAttributes /@SessionAttributes(value=”names”,types=String.class)/ 自定义类型转换–user如果输入 username-password-age？ user 接受register.jsp12345&lt;form action="test/user" method="post"&gt; &lt;!-- name-password-age --&gt; user: &lt;input type="text" name="user"/&gt; &lt;input type="submit" value="submit"&gt;&lt;/form&gt; UserController1234567891011121314151617@Controllerpublic class UserController &#123; @Autowired private UserService userService; @RequestMapping("/user") public ModelAndView register(User user) &#123; System.out.println(user.getUsername()+" "+user.getAddress()+" "+user.getAge()+" "+user.getBirthday()); ModelAndView mav = new ModelAndView(); int i = userService.addUser(user);// System.out.println(i); if (i != 0) &#123; mav.setViewName("success"); &#125; return mav; &#125;&#125; UserConverter12345678910111213141516171819202122232425@Componentpublic class UserConverter implements Converter&lt;String, User&gt; &#123; @Override public User convert(String source) &#123; // zhangsan-123-12 if (null != source) &#123; String[] values = source.split("-"); if (values.length == 3) &#123; String username = values[0]; String password = values[1]; Integer age = Integer.parseInt(values[2]); User user = new User(); user.setUsername(username); user.setPassword(password); user.setAge(age); return user; &#125; &#125; return null; &#125;&#125; 为什么配置conversion-service=”conversionService”，依赖于HandlerAdapter，HandlerMapping123456789101112&lt;mvc:annotation-driven conversion-service="conversionService"/&gt; &lt;mvc:resources location="/static/" mapping="/static/**"/&gt; &lt;!-- 配置好自定义类型转换 --&gt; &lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;set&gt; &lt;ref bean="dataConverter"/&gt; &lt;ref bean="userConverter"/&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; 12345678SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); Date date = null; try &#123; date = sdf.parse(source); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC常用注解(二)、Restful风格]]></title>
    <url>%2F%2F2019%2F07%2F18%2F2019-07-18%2F</url>
    <content type="text"><![CDATA[RequestParamRequestHeader RESTful编程风格记性编程1)RESTful:表现层的状态转换。view层2) HTTP协议中的四种状态GET POST PUT(修改) DELETE3) 如果在SpringMvC中使用RESTful编程风格，我们需要借助于@PathVariable注解获取到请求的路径参数的值/{} 占位符SpringMVC框架能支持RESTFul，就是借助于一个过滤器 HiddenHttpMethodFilter，HiddenHttpMethodFilter的作用就是将浏览器中POST请求转换为PUT和DELETE请求/* 所有请求/ 除JSP13、 SpringMVC中如何使用RESTful的编程风格1) 添加过滤器 HiddenHttpMethodFilter2) 在Form中添加name 为_method的input隐藏域3) 进行对Form中POST请求转换为PUT和DELETE请求 14、SpringMVC来说，他会自欧东的将前端请求的参数赋值给控制器中方法的形参，(提交的参数名必须等于形参的名字) ，在转换的过程中，还会自动类型转换，如果参数名和形参名字不一样，我们需要在形参中添加@RequestParam(value就是请求参数的名字)user?id=1user?id=1&amp;flag=deleteuser?id=1&amp;flag=update user/1 GETuser/1 DELETEuser/1 PUTuser/1 POST @CookieValue 数据绑定 15、在SpringMVC中当我们想ModelAndView中添加数据的时候，默认的放到request作用域中，在返回一个字符串；或者MAV(ModelAndView)的时候，默认的是基于转发模式的。 返回类型及模型数据ModelAndViewSpringmvcController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101@Controller@RequestMapping(value = "/test/")public class springMVCController &#123; // /user/testRequestMapping @RequestMapping(value = "testString", method = RequestMethod.POST) public String testString(User user, HttpSession session) &#123; session.setAttribute("user", user); return "redirect:/index.jsp"; // return "forward:/index.jsp"; /表示当前路径下，否则就/test/index.jsp &#125; @RequestMapping(value = "testPojo", method = RequestMethod.POST) public ModelAndView testPojo(User user) &#123; ModelAndView mav = new ModelAndView("success"); mav.addObject(user); System.out.println(user.getUsername() + user.getAddress().getHomeAddress()); return mav; &#125; @RequestMapping(value = "testServletAPI", method = RequestMethod.GET) public String testCookie(HttpServletRequest request, HttpSession httpSession) &#123; System.out.println(request.getContextPath()); System.out.println("testServletAPI"); return "success"; &#125; @RequestMapping(value = "testDataBinder", method = RequestMethod.GET) public String testCookie(User user) &#123; System.out.println(user.getUsername() + user.getAge()); System.out.println("testDataBinder"); return "success"; &#125; @RequestMapping(value = "testCookie", method = RequestMethod.GET) public String testCookie(@CookieValue("JSESSIONID") String jsessionid) &#123; System.out.println(jsessionid); System.out.println("testRESTful-testCookie"); return "success"; &#125; @RequestMapping(value = "user/&#123;id&#125;", method = RequestMethod.GET) public String testSelect(@PathVariable(value = "id") Integer id) &#123; System.out.println(id); System.out.println("testRESTful-Select"); return "success"; &#125; @RequestMapping(value = "user/&#123;id&#125;", method = RequestMethod.DELETE) public String testDelete(@PathVariable(value = "id") Integer id) &#123; System.out.println("delete invoked"); System.out.println(id); System.out.println("testRESTful-Delete"); return "success"; &#125; @RequestMapping(value = "user/&#123;id&#125;", method = RequestMethod.PUT) public String testUpdate(@PathVariable(value = "id") Integer id) &#123; System.out.println("put invoked"); System.out.println(id); System.out.println("testRESTful-put"); return "success"; &#125; @RequestMapping(value = "testPathVariable/&#123;id&#125;", method = RequestMethod.GET) public String testRequestParam(@PathVariable(value = "id") Integer id) &#123; System.out.println(id); System.out.println("testPathVaribale"); return "success"; &#125; @RequestMapping(value = "testRequestHeader", method = RequestMethod.GET) public String testRequestParam(@RequestHeader(value = "Cookie") String cookie) &#123; System.out.println(cookie); System.out.println("testRequestHeader"); return "success"; &#125; @RequestMapping(value = "testRequestMapping2/**/user", method = RequestMethod.GET) public String testRequestMapping2(String username, Integer age) &#123; System.out.println(username + age); System.out.println("testRequestMapping"); return "success"; &#125; @RequestMapping(value = "testRequestParam", method = RequestMethod.GET) public String testRequestParam( @RequestParam(value = "name", required = false, defaultValue = "hellomoren") String username, Integer age) &#123; System.out.println(username + age); System.out.println("testRequestParam"); return "success"; &#125; @RequestMapping(value = "testRequestMapping", method = RequestMethod.GET, params = &#123; "username", "age!=12" &#125;, headers = &#123; "Content-Type=text/html;charset=UTF-8" &#125;) public String testRequestMapping(String username, Integer age) &#123; System.out.println(username + age); System.out.println("testRequestMapping"); return "success"; &#125;&#125; springmvc.jsp123456789101112131415161718192021222324252627282930313233343536373839404142body部分内容：&lt;body&gt;&lt;script type="text/javascript"&gt; function restful(method,id)&#123; document.getElementById("form1").action="test/user/"+id; document.getElementById("flag").value=method; document.getElementById("form1").submit(); return false; &#125; /* function deleteById() &#123; document.getElementById("form1").submit(); &#125; function updateById() &#123; document.getElementById("form2").submit(); &#125; */&lt;/script&gt; &lt;form action="test/user/1" method="POST" id="form1"&gt; &lt;input id="flag" type="hidden" name="_method" value="DELETE"&gt; &lt;input type="submit" value ="delete-submit"&gt; &lt;/form&gt; &lt;!-- &lt;form action="test/user/1" method="POST" id="form2"&gt; &lt;input type="hidden" name="_method" value="PUT"&gt; &lt;input type="submit" value ="delete-update"&gt; &lt;/form&gt; --&gt; &lt;a href="javascript:void(0)" onclick="restful('PUT',1)"&gt;Update&lt;/a&gt;&lt;br/&gt; &lt;a href="javascript:void(0)" onclick="restful('DELETE',1)"&gt;Delete&lt;/a&gt;&lt;br/&gt; &lt;a href="test/user/1"&gt;Get&lt;/a&gt;&lt;br/&gt; &lt;a href="test/testRequestParam?name=zhangsan&amp;age=10"&gt;testRequestParam&lt;/a&gt;&lt;br/&gt; &lt;a href="test/testRequestParam?age=10"&gt;testRequestParam只传一个参数&lt;/a&gt;&lt;br/&gt; &lt;a href="test/testRequestHeader"&gt;testRequestHeader&lt;/a&gt;&lt;br/&gt; &lt;a href="test/testRequestMapping?username=zhangsan&amp;age=10"&gt;testRequestMapping(error,415)&lt;/a&gt;&lt;br/&gt; &lt;form action="user/testRequestMapping" method="POST"&gt; &lt;input type="submit" value="submit"&gt; &lt;/form&gt; &lt;a href="test/testRequestMapping2/231/231/user"&gt;user/testRequestMapping2/231/231/user&lt;/a&gt;&lt;br/&gt; &lt;a href="test/testPathVariable/100"&gt;testPathVariable动态获取&lt;/a&gt;&lt;br/&gt; &lt;a href="test/testRequestHeader"&gt;testRequestHeader&lt;/a&gt;&lt;br/&gt;&lt;/body&gt; register.jsp1234567891011121314151617181920&lt;body&gt; register: &lt;form action="test/testString" method="post"&gt; username:&lt;input type="text" name="username"&gt;&lt;br/&gt; password:&lt;input type="text" name="password"&gt;&lt;br/&gt; age:&lt;input type="text" name="age"&gt;&lt;br/&gt; birthday:&lt;input type="text" name="birthday"&gt;&lt;br/&gt; homeAddress:&lt;input type="text" name="address.homeAddress"&gt;&lt;br /&gt; companyAddress:&lt;input type="text" name="address.companyAddress"&gt;&lt;br /&gt; &lt;input type="submit" value="submit"&gt; &lt;/form&gt;&lt;/body&gt;=====================================success.jsp$&#123;requestScope.user.username&#125;=====================================index.jsp$&#123;user.username&#125;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的删除结点、顺序存储二叉树、线索化二叉树]]></title>
    <url>%2F%2F2019%2F07%2F17%2F2019-07-17%2F</url>
    <content type="text"><![CDATA[完成删除结点的操作规定：1)如果删除的结点是叶子结点，则删除该节点2)如果删除的结点是非叶子结点，则删除该子树 思路1、因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除的结点2.如果当前结点的左子结点不为空，并且左子节点就是需要删除结点，就将this.left=null;并且就返回(结束递归删除) 如果当前结点的右子结点不为空，并且右子结点就是要删除的结点，就将this.right=null;并且就返回(结束递归删除) 如果第二步，第三步没有删除结点，那么我们就需要向左子树进行递归删除5.如果第4步也没有删除结点，则应对对右子树进行递归删除。 考虑如果树是空树 root，如果只有一个root结点，则将二叉树置空BinaryTree12345678910111213//删除结点 public void delNode(int no) &#123; if(root!=null) &#123; //如果只有一个结点这里判断root是不是要删除的结点 if(root.getNo()==no) &#123; root=null; &#125;else &#123; root.delNode(no); &#125; &#125;else &#123; System.out.println("空树，不能删除"); &#125; &#125; HeroNode123456789101112131415161718192021public void delNode(int no ) &#123; //2.如果当前结点的左子结点不为空，并且左子节点就是需要删除结点，就将this.left=null;并且就返回(结束递归删除) if (this.left != null &amp;&amp; this.left.no == no) &#123; this.left = null; return; &#125; //3.如果当前结点的右子结点不为空，并且右子节点就是需要删除结点，就将this.right=null;并且就返回(结束递归删除) if (this.right != null &amp;&amp; this.right.no == no) &#123; this.right = null; return; &#125; //4.需要向左子树递归删除 if(this.left!=null) &#123; this.left.delNode(no); &#125; //5.需要向右子树递归删除 if(this.right!=null) &#123; this.right.delNode(no); &#125; &#125; 顺序存储二叉树的特点1) 顺序二叉树通常只考虑完全二叉树2) 第n个元素的左子结点为2 n + 13) 第n个元素的右子结点为2 n + 24) 第n个元素的父节点为(n - 1) / 255) n:表示二叉树的第几个元素(从0开始编号) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class ArrayBinaryTreeDemo &#123; public static void main(String[] args) &#123; int arr[] = &#123; 1, 2, 3, 4, 5, 6, 7 &#125;; ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr);// arrBinaryTree.preOrder(); //1 2 4 5 3 6 7// arrBinaryTree.infixOrder();//4 2 5 1 6 3 7 arrBinaryTree.postOrder(); //4 5 2 6 7 3 1 &#125;&#125;// 编写一个ArrayBinaryTree，实现顺序存储二叉树遍历class ArrBinaryTree &#123; private int arr[];// 存储数据结点的数组 public ArrBinaryTree(int arr[]) &#123; this.arr = arr; &#125; /** * * @param index * 数组的下标 */ //重载preOrder public void preOrder() &#123; this.preOrder(0); &#125; public void preOrder(int index) &#123; // 如果数组为空，或者arr.length=0 if (arr == null || arr.length == 0) &#123; System.out.println("数组为空，不能按照二叉树的前序遍历"); &#125; //输出当前这个元素 System.out.println(arr[index]); // 向左递归 if ((index * 2 + 1) &lt; arr.length) &#123; preOrder(2 * index + 1); &#125; // 向右递归 if ((index * 2 + 2) &lt; arr.length) &#123; preOrder(2 * index + 2); &#125; &#125; public void infixOrder() &#123; this.infixOrder(0); &#125; public void infixOrder(int index) &#123; // 如果数组为空，或者arr.length=0 if (arr == null || arr.length == 0) &#123; System.out.println("数组为空，不能按照二叉树的中序遍历"); &#125; // 向左递归 if ((index * 2 + 1) &lt; arr.length) &#123; infixOrder(2 * index + 1); &#125; // 输出当前这个元素 System.out.println(arr[index]); // 向右递归 if ((index * 2 + 2) &lt; arr.length) &#123; infixOrder(2 * index + 2); &#125; &#125; public void postOrder() &#123; this.postOrder(0); &#125; public void postOrder(int index) &#123; // 如果数组为空，或者arr.length=0 if (arr == null || arr.length == 0) &#123; System.out.println("数组为空，不能按照二叉树的后序遍历"); &#125; // 向左递归 if ((index * 2 + 1) &lt; arr.length) &#123; postOrder(2 * index + 1); &#125; // 向右递归 if ((index * 2 + 2) &lt; arr.length) &#123; postOrder(2 * index + 2); &#125; // 输出当前这个元素 System.out.println(arr[index]); &#125;&#125; 线索化二叉树 问题分析：1)当我们对上面的二叉树进行中序遍历是，数列为 8 3 10 1 14 62) 但是6,8,10,14,这几个结点的左右指针，并没有完全利用3) 如果我们希望充分利用每个节点的左右指针，让各个节点可以指向自己的前后节点 解决方法 线索二叉树 中序遍历的结果为 8,3,10,1,14,6 说明：当线索化二叉树后，Node节点的属性left和right，有如下情况：1) left指向的是左子树，也可能是前驱节点，比如①节点的left指向左子树，而⑩节点的left指向的就是前驱节点。2) right指向的是右子树，也可能是指向后继节点，比如①节点的right指向右子树，而⑩节点的right指向的就是后继节点 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365public class ThreadBinaryTreeDemo &#123; public static void main(String[] args) &#123; //中序线索二叉树 HeroNode root = new HeroNode(1, "tom"); HeroNode node2 =new HeroNode(3, "jack"); HeroNode node3 =new HeroNode(6, "simth"); HeroNode node4 =new HeroNode(8, "marry"); HeroNode node5 =new HeroNode(10, "king"); HeroNode node6 =new HeroNode(14, "dim"); //二叉树，后面我们要递归创建，现在简单处理使用手动创建 root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); //测试线索化 ThreadBinaryTree threadBinaryTree = new ThreadBinaryTree(); threadBinaryTree.setRoot(root); threadBinaryTree.threadNodes(); // 测试：以10号节点测试 HeroNode leftnode = node5.getLeft(); HeroNode rightnode = node5.getRight(); System.out.println("10号节点前驱结点 "+leftnode); System.out.println("10号节点后继结点 "+rightnode); &#125;&#125;//实现线索化功能的二叉树 ThreadBinaryTreeclass ThreadBinaryTree &#123; private HeroNode root; //为了实现线索化，需要创建指向当前结点的前驱节点的指针 //当递归进行线索化时，pre 总是保留前一个结点 private HeroNode pre=null; public void setRoot(HeroNode root) &#123; this.root = root; &#125; //重载threadNodes public void threadNodes() &#123; this.threadNodes(root); &#125; //编写对二叉树进行中序线索化的方法 /** * * @param heroNode 当前需要线索化的结点 */ public void threadNodes(HeroNode node) &#123; if (node == null) &#123; return; &#125; //1.线索化左子树 threadNodes(node.getLeft()); //2.线索化当前结点[有难度] //处理当前结点的前驱节点 //以8为例，8.left=null,8.lefttype=1 if (node.getLeft() == null) &#123; // 让当前结点的左子针指向前驱节点 node.setLeft(pre); // 修改当前节点的左子针类型 node.setLefttype(1); &#125; //处理后继节点 if (pre != null &amp;&amp; pre.getRight() == null) &#123; // 让前驱节点的右指针指向当前结点 pre.setRight(node); pre.setRighttype(1); &#125; // ！！！没处理完一个节点后，让当前结点是下一个结点的前驱结点 pre = node; // 3.线索化右子树 threadNodes(node.getRight()); &#125; //删除结点 public void delNode(int no) &#123; if(root!=null) &#123; //如果只有一个结点这里判断root是不是要删除的结点 if(root.getNo()==no) &#123; root=null; &#125;else &#123; root.delNode(no); &#125; &#125;else &#123; System.out.println("空树，不能删除"); &#125; &#125; // 前序遍历测试 public void preOrder() &#123; if (this.root != null) &#123; this.root.preOrder(); &#125; else &#123; System.out.println("二叉树为空，无法遍历"); &#125; &#125; // 中序遍历测试 public void infixOrder() &#123; if (this.root != null) &#123; this.root.infixOrder(); &#125; else &#123; System.out.println("二叉树为空，无法遍历"); &#125; &#125; // 后序遍历测试 public void postOrder() &#123; if (this.root != null) &#123; this.root.postOrder(); &#125; else &#123; System.out.println("二叉树为空，无法遍历"); &#125; &#125; // 前序遍历 public HeroNode preOrderSerach(int no) &#123; if (root != null) &#123; return root.preOrderSearch(no); &#125; else &#123; return null; &#125; &#125; // 中序遍历 public HeroNode infixOrderSearch(int no) &#123; if (root != null) &#123; return root.infixOrderSearch(no); &#125; else &#123; return null; &#125; &#125; // 后序遍历 public HeroNode postOrderSearch(int no) &#123; if (root != null) &#123; return root.postOrderSearch(no); &#125; else &#123; return null; &#125; &#125;&#125;class HeroNode &#123; private int no; private String name; private HeroNode left;// 默认为空 private HeroNode right;//默认为空 //说明 //1.如果lefttype==0表示指向左子树，lefttype==1表示指向前驱节点 //2.如果righttype==0表示指向右子树，righttype==1表示指向后继节点 private int lefttype; private int righttype; public int getLefttype() &#123; return lefttype; &#125; public void setLefttype(int lefttype) &#123; this.lefttype = lefttype; &#125; public int getRighttype() &#123; return righttype; &#125; public void setRighttype(int righttype) &#123; this.righttype = righttype; &#125; public HeroNode(int no, String name) &#123; super(); this.no = no; this.name = name; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public HeroNode getLeft() &#123; return left; &#125; public void setLeft(HeroNode left) &#123; this.left = left; &#125; public HeroNode getRight() &#123; return right; &#125; public void setRight(HeroNode right) &#123; this.right = right; &#125; @Override public String toString() &#123; return "HeroNode [no=" + no + ", name=" + name + "]"; &#125; /** * 1)如果删除的结点是叶子结点，则删除该节点 * 2)如果删除的结点是非叶子结点，则删除该子树 * @param no */ public void delNode(int no ) &#123; /** * 思路 * 1、因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除的结点 * 2.如果当前结点的左子结点不为空，并且左子节点就是需要删除结点，就将 * this.left=null;并且就返回(结束递归删除) * 3. 如果当前结点的右子结点不为空，并且右子结点就是要删除的结点，就将 * this.right=null;并且就返回(结束递归删除) * 4. 如果第二步，第三步没有删除结点，那么我们就需要向左子树进行递归删除 * 5.如果第4步也没有删除结点，则应对对右子树进行递归删除。 * 6. 考虑如果树是空树 root，如果只有一个root结点，则将二叉树置空 */ //2.如果当前结点的左子结点不为空，并且左子节点就是需要删除结点，就将this.left=null;并且就返回(结束递归删除) if (this.left != null &amp;&amp; this.left.no == no) &#123; this.left = null; return; &#125; //3.如果当前结点的右子结点不为空，并且右子节点就是需要删除结点，就将this.right=null;并且就返回(结束递归删除) if (this.right != null &amp;&amp; this.right.no == no) &#123; this.right = null; return; &#125; //4.需要向左子树递归删除 if(this.left!=null) &#123; this.left.delNode(no); &#125; //5.需要向右子树递归删除 if(this.right!=null) &#123; this.right.delNode(no); &#125; &#125; // 前序遍历 public void preOrder() &#123; System.out.println(this);// 先输出父节点 // 递归向左子树前序遍历 if (this.left != null) &#123; this.left.preOrder(); &#125; // 递归向右子树前序遍历 if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; // 中序遍历 public void infixOrder() &#123; // 递归向左子树前序遍历 if (this.left != null) &#123; this.left.infixOrder(); &#125; System.out.println(this);// 输出父节点 // 递归向右子树前序遍历 if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125; // 后序遍历 public void postOrder() &#123; // 递归向左子树前序遍历 if (this.left != null) &#123; this.left.postOrder(); &#125; // 递归向右子树前序遍历 if (this.right != null) &#123; this.right.postOrder(); &#125; System.out.println(this);// 输出父节点 &#125; // 前序遍历查找 public HeroNode preOrderSearch(int no) &#123; if (this.no == no) &#123; return this; &#125; // 1.则判断当前结点的左子结点是否为空，如果不为空，递归前序查找 // 2.如果做地柜前序查找，找到结点，则返回 HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.preOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; // 1.左递归前序查找，找到结点，则返回，否继续判断 // 2.当前的结点的右子结点是否为空，如果不为空，则继续向右递归前序查找 if (this.right != null) &#123; resNode = this.right.preOrderSearch(no); &#125; return resNode; &#125; // 中序遍历查找 public HeroNode infixOrderSearch(int no) &#123; // 1.则判断当前结点的左子结点是否为空，如果不为空，递归中序查找 HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.infixOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; // 2.如果做地柜前序查找，找到结点，则返回// System.out.println("进入中序查找"); if (this.no == no) &#123; return this; &#125; // 否则向右递归中序查找 if (this.right != null) &#123; resNode = this.right.infixOrderSearch(no); &#125; return resNode; &#125; // 后序遍历查找 public HeroNode postOrderSearch(int no) &#123; // 1.则判断当前结点的左子结点是否为空，如果不为空，递归后序查找 HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.postOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; if (this.right != null) &#123; resNode = this.right.postOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; // 如果左右子树都不是，比较根节点 System.out.println("进入后序遍历查找"); if (this.no == no) &#123; return this; &#125; return resNode; &#125;&#125; 结果 HeroNode [no=8, name=H]HeroNode [no=4, name=D]HeroNode [no=9, name=I]HeroNode [no=2, name=B]HeroNode [no=5, name=E]HeroNode [no=1, name=A]HeroNode [no=6, name=F]HeroNode [no=3, name=C]HeroNode [no=7, name=G]F节点前驱结点 HeroNode [no=1, name=A]F节点后继结点 HeroNode [no=3, name=C]HeroNode [no=8, name=H]HeroNode [no=4, name=D]HeroNode [no=9, name=I]HeroNode [no=2, name=B]HeroNode [no=5, name=E]HeroNode [no=1, name=A]HeroNode [no=6, name=F]HeroNode [no=3, name=C]HeroNode [no=7, name=G] 遍历线索二叉树如图123456789101112131415161718192021222324252627282930//为了实现线索化，需要创建指向当前结点的前驱节点的指针//当递归进行线索化时，pre 总是保留前一个结点private HeroNode pre=null;//遍历线索化二叉树的方法public void threadList() &#123; // 定义一个变量，存储当前遍历的结点，从root开始 HeroNode node = root; while (node != null) &#123; // 循环找到lefttype==1的结点，第一个找到就是8结点 // 后面随着遍历而变化，因为lefttype==1，说明该结点是按照线索化 // 处理后的结点 while (node.getLefttype() == 0) &#123; node = node.getLeft(); &#125; // 打印当前结点 System.out.println(node); // 如果当前结点的右指针指向的是后继结点，就一直输出 while (node.getRighttype() == 1) &#123; // 获取当前结点的后继结点 node = node.getRight(); System.out.println(node); &#125; // 替换这个遍历的结点 node = node.getRight(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的前中后序查找实现]]></title>
    <url>%2F%2F2019%2F07%2F16%2F2019-07-16%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282public class BinaryTreeDemo &#123; public static void main(String[] args) &#123; // 先创建一颗二叉树 BinaryTree binaryTree = new BinaryTree(); // 创建需要的结点 HeroNode root = new HeroNode(1, "宋江1"); HeroNode node2 = new HeroNode(2, "吴用"); HeroNode node3 = new HeroNode(3, "卢俊义"); HeroNode node4 = new HeroNode(4, "林冲"); HeroNode node5 = new HeroNode(5, "关胜"); // 手动创建二叉树，用递归方式创建二叉树 root.setLeft(node2); root.setRight(node3); node3.setRight(node4); node3.setLeft(node5); binaryTree.setRoot(root); /** * 1 / \ 2 3 / \ 5 4 */ // 测试 System.out.println("前序遍历"); // 1 2 3 5 4 binaryTree.preOrder(); System.out.println("中序遍历"); // 2 1 5 3 4 binaryTree.infixOrder(); System.out.println("后序遍历"); // 2 5 4 3 1 binaryTree.postOrder(); // 前序遍历 4次 /*System.out.println("前序遍历查找~~~"); HeroNode resNode = binaryTree.preOrderSerach(5); if (resNode != null) &#123; System.out.printf("找到了，信息为no=%d name=%s", resNode.getNo(), resNode.getName()); &#125; else &#123; System.out.printf("没有找到no=%d的人",5); &#125;*/ //中序遍历 3次 /*System.out.println("中序遍历查找~~~"); HeroNode resNode = binaryTree.infixOrderSearch(5); if (resNode != null) &#123; System.out.printf("找到了，信息为no=%d name=%s", resNode.getNo(), resNode.getName()); &#125; else &#123; System.out.printf("没有找到no=%d的人", 5); &#125;*/ //后序遍历查找 2次 System.out.println("后遍历查找~~~"); HeroNode resNode = binaryTree.postOrderSearch(5); if (resNode != null) &#123; System.out.printf("找到了，信息为no=%d name=%s", resNode.getNo(), resNode.getName()); &#125; else &#123; System.out.printf("没有找到no=%d的人", 5); &#125; &#125;&#125;// 定义二叉树class BinaryTree &#123; private HeroNode root; public void setRoot(HeroNode root) &#123; this.root = root; &#125; // 前序遍历测试 public void preOrder() &#123; if (this.root != null) &#123; this.root.preOrder(); &#125; else &#123; System.out.println("二叉树为空，无法遍历"); &#125; &#125; // 中序遍历测试 public void infixOrder() &#123; if (this.root != null) &#123; this.root.infixOrder(); &#125; else &#123; System.out.println("二叉树为空，无法遍历"); &#125; &#125; // 后序遍历测试 public void postOrder() &#123; if (this.root != null) &#123; this.root.postOrder(); &#125; else &#123; System.out.println("二叉树为空，无法遍历"); &#125; &#125; // 前序遍历 public HeroNode preOrderSerach(int no) &#123; if (root != null) &#123; return root.preOrderSearch(no); &#125; else &#123; return null; &#125; &#125; // 中序遍历 public HeroNode infixOrderSearch(int no) &#123; if (root != null) &#123; return root.infixOrderSearch(no); &#125; else &#123; return null; &#125; &#125; // 后序遍历 public HeroNode postOrderSearch(int no) &#123; if (root != null) &#123; return root.postOrderSearch(no); &#125; else &#123; return null; &#125; &#125;&#125;// 创建HeroNode 结点class HeroNode &#123; private int no; private String name; private HeroNode left;// 默认为空 private HeroNode right; public HeroNode(int no, String name) &#123; super(); this.no = no; this.name = name; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public HeroNode getLeft() &#123; return left; &#125; public void setLeft(HeroNode left) &#123; this.left = left; &#125; public HeroNode getRight() &#123; return right; &#125; public void setRight(HeroNode right) &#123; this.right = right; &#125; @Override public String toString() &#123; return "HeroNode [no=" + no + ", name=" + name + "]"; &#125; // 前序遍历 public void preOrder() &#123; System.out.println(this);// 先输出父节点 // 递归向左子树前序遍历 if (this.left != null) &#123; this.left.preOrder(); &#125; // 递归向右子树前序遍历 if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; // 中序遍历 public void infixOrder() &#123; // 递归向左子树前序遍历 if (this.left != null) &#123; this.left.infixOrder(); &#125; System.out.println(this);// 输出父节点 // 递归向右子树前序遍历 if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125; // 后序遍历 public void postOrder() &#123; // 递归向左子树前序遍历 if (this.left != null) &#123; this.left.postOrder(); &#125; // 递归向右子树前序遍历 if (this.right != null) &#123; this.right.postOrder(); &#125; System.out.println(this);// 输出父节点 &#125; // 前序遍历查找 public HeroNode preOrderSearch(int no) &#123; if (this.no == no) &#123; return this; &#125; // 1.则判断当前结点的左子结点是否为空，如果不为空，递归前序查找 // 2.如果做地柜前序查找，找到结点，则返回 HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.preOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; // 1.左递归前序查找，找到结点，则返回，否继续判断 // 2.当前的结点的右子结点是否为空，如果不为空，则继续向右递归前序查找 if (this.right != null) &#123; resNode = this.right.preOrderSearch(no); &#125; return resNode; &#125; // 中序遍历查找 public HeroNode infixOrderSearch(int no) &#123; // 1.则判断当前结点的左子结点是否为空，如果不为空，递归中序查找 HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.infixOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; // 2.如果做地柜前序查找，找到结点，则返回// System.out.println("进入中序查找"); if (this.no == no) &#123; return this; &#125; // 否则向右递归中序查找 if (this.right != null) &#123; resNode = this.right.infixOrderSearch(no); &#125; return resNode; &#125; // 后序遍历查找 public HeroNode postOrderSearch(int no) &#123; // 1.则判断当前结点的左子结点是否为空，如果不为空，递归后序查找 HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.postOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; if (this.right != null) &#123; resNode = this.right.postOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; // 如果左右子树都不是，比较根节点 System.out.println("进入后序遍历查找"); if (this.no == no) &#123; return this; &#125; return resNode; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC常用注解(一)]]></title>
    <url>%2F%2F2019%2F07%2F15%2F2019-07-15%2F</url>
    <content type="text"><![CDATA[Status Report Message /SpringMVC1/WEB-INF/user.jsp Description The origin server did not find a current representation for the target resource or is not willing to disclose that one exists. 后来找了相关文档原来是ModelAndVeiw 类的包引错了。应该引入的是： org.springframework.web.servlet.ModelAndView;而不是 org.springframework.web.portlet.ModelAndView ###如何构建SpringMvc框架1)导入jar2)第二步 配置DispatcherServlet 核心及其与之对应默认配置的文件3)编写controller类4)定义视图解析类12345&lt;!-- 在SpringMVC中配置视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/view/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; 8.在Web项目中，我们的JSP页面不能直接通过浏览器的方式访问到的，需要在服务器内部进行转发访问 JSP中 controller@RequestMapping(“/user”) 对于springmvc-servlet.xml的两种配置方式修改路径1) springmvc-servlet.xml放到src/com/neusoft/resource下 contextConfigLocation classpath:com/neusoft/resource/springmvc-servlet.xml2)修改名字 /WEB-INF/dispatcherservlet.xml mvc:annotation-driven/代替两个&lt;!– &lt;bean class=&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot;&gt;&lt;/bean&gt; --&gt; SpringMVC常用的注解1) @controller 当前Bean 为一个业务处理器类。2) @RequestMapping注解 为控制器可以指定处理哪些URL请求修饰方法-@RequestMapping除了可以使用请求URL映射请求外，还可以使用请求方法、请求参数及请求头映射请求-@RequestMapping的value 、method、params及heads分别表示请求URL、请求方法、请求参数及请求头的映射条件，他们之间是与的关系，联合使用多个条件可以让请求映射更加准确化。3) @RequestParam4) @RequestHeaders 123456789101112131415@Controller@RequestMapping("/user")public class springMVCController &#123; // /user/testRequestMapping @RequestMapping("/testRequestMapping") public String testRequestMapping() &#123; System.out.println("testRequestMapping"); return "success"; &#125; &#125;注释@RequestMapping("/user")/testRequestMapping不注释user/testRequestMapping 简单配置Dao、Service@Repository、@Serviceweb.xml12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" id="WebApp_ID" version="3.1"&gt; &lt;display-name&gt;mvc&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- &lt;param-value&gt;classpath:com/neusoft/resource/springmvc-servlet.xml&lt;/param-value&gt; --&gt; &lt;param-value&gt;/WEB-INF/springmvc-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;register.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; springmvc-servlet.xml123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:dwr="http://www.directwebremoting.org/schema/spring-dwr" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;context:component-scan base-package="com.neusoft"&gt;&lt;/context:component-scan&gt; &lt;!-- 在SpringMVC中配置视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/view/"&gt;&lt;/property&gt; &lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"&gt;&lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"&gt;&lt;/bean&gt; --&gt;&lt;/beans&gt; springmvcController.java12345678910111213141516171819@Controller@RequestMapping(value = "/user/")public class springMVCController &#123; // /user/testRequestMapping @RequestMapping(value = "testRequestParam",method=RequestMethod.GET,params= &#123;"name","age"&#125;) public String testRequestParam(String username,Integer age) &#123; System.out.println(username + age); System.out.println("testRequestParam"); return "success"; &#125; @RequestMapping(value = "testRequestMapping",method=RequestMethod.GET,params= &#123;"username","age!=12"&#125;,headers= &#123;"Content-Type=text/html;charset=UTF-8"&#125;) public String testRequestMapping(String username,Integer age) &#123; System.out.println(username + age); System.out.println("testRequestMapping"); return "success"; &#125; &#125; springmvc.jsp12345678910&lt;body&gt; &lt;a href="user/testRequestParam?name=zhangsan&amp;age=10"&gt;testRequestMapping&lt;/a&gt; &lt;a href="user/testRequestMapping?username=zhangsan&amp;age=10"&gt;testRequestMapping&lt;/a&gt; &lt;form action="user/testRequestMapping" method="POST"&gt; &lt;input type="submit" value="submit"&gt; &lt;/form&gt; &lt;a href="user/testRequestMapping"&gt;testRequestMapping&lt;/a&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringAOP声明式事务]]></title>
    <url>%2F%2F2019%2F07%2F13%2F2019-07-13%2F</url>
    <content type="text"><![CDATA[在Spring中有声明式事务，主要有两种方式实现事务： 配置文件 注解，我们建议使用注解声明式事务的配置。声明式事务配置文件注解的话，需要在每个方法前加1// @Transactional applicationContext.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:dwr="http://www.directwebremoting.org/schema/spring-dwr" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd"&gt; &lt;!-- 开启注解，这个包下所有的注解，让注解生效 --&gt; &lt;context:component-scan base-package="com.neusoft"&gt;&lt;/context:component-scan&gt; &lt;!-- 1.数据库连接池c3p0 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/neusoft"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="123456"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 2.创建JDBCTemplate --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 3.Spring来进行事务管理，事务是针对于数据库的 --&gt; &lt;bean id="dataSourceTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 声明式事务 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="dataSourceTransactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="get*" read-only="true" propagation="REQUIRED"/&gt; &lt;tx:method name="find*" read-only="true"/&gt; &lt;tx:method name="select*" read-only="true"/&gt; &lt;tx:method name="*" read-only="false"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 事务的拦截 --&gt; &lt;aop:config&gt; &lt;aop:pointcut expression="execution(* com.neusoft.service..*.*(..))" id="pt"/&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt"/&gt; &lt;/aop:config&gt; &lt;!-- 开启事务的注解 --&gt; &lt;!-- &lt;tx:annotation-driven transaction-manager="dataSourceTransactionManager"/&gt; --&gt; &lt;/beans&gt; UserDao.java12345678910111213141516@Repositorypublic class UserDao &#123; @Autowired private JdbcTemplate jdbcTemplate; public void addUser(User user) &#123; String sql ="insert into t_user(username,password) values(?,?)"; jdbcTemplate.update(sql,user.getUsername(),user.getPassword()); System.out.println("数据添加成功"); &#125; &#125; TransactionManager.java1234567891011121314151617181920@Componentpublic class TransactionManager &#123; @Autowired private DataSourceTransactionManager dataSourceTransactionManager; public TransactionStatus begin() &#123; return dataSourceTransactionManager.getTransaction(new DefaultTransactionAttribute()); &#125; public void commit(TransactionStatus transactionStatus) &#123; dataSourceTransactionManager.commit(transactionStatus); &#125; public void rollback(TransactionStatus transactionStatus) &#123; dataSourceTransactionManager.rollback(transactionStatus); &#125;&#125; UserService.java123456789101112131415161718192021222324252627282930313233@Servicepublic class UserService &#123; @Resource private UserDao userDao; @Autowired private TransactionManager transactionManager; /*public void add() &#123; TransactionStatus transactionStatus =null; try &#123; transactionStatus = transactionManager.begin(); userDao.addUser(new User("zhangsan-"+System.currentTimeMillis(),"123456"));// int i=1/0; userDao.addUser(new User("zhangsan1-"+System.currentTimeMillis(),"123456")); transactionManager.commit(transactionStatus); &#125; catch (Exception e) &#123; transactionManager.rollback(transactionStatus); e.printStackTrace(); &#125; &#125;*/// @Transactional public void add() &#123; userDao.addUser(new User("zhangsan-"+System.currentTimeMillis(),"123456"));// int i=1/0; userDao.addUser(new User("zhangsan1-"+System.currentTimeMillis(),"123456")); &#125; &#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构---二叉树的层次遍历]]></title>
    <url>%2F%2F2019%2F07%2F10%2F2019-07-10%2F</url>
    <content type="text"><![CDATA[层次遍历给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如:给定二叉树: [3,9,20,null,null,15,7],123456789101112 3 / \ 9 20 / \ 15 7返回其层次遍历结果：[ [3], [9,20], [15,7]] 代码1234567891011121314151617181920212223 List&lt;List&lt;Integer&gt;&gt; result=new ArrayList();public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; if(root==null)return result; Queue&lt;TreeNode&gt; q= new LinkedList(); q.add(root); while(!q.isEmpty()) &#123; int count = q.size(); List&lt;Integer&gt; list = new ArrayList(); while(count&gt;0) &#123; TreeNode temp =q.peek(); q.poll(); list.add(temp.val); if(temp.left!=null)q.add(temp.left); if(temp.right!=null)q.add(temp.right); count--; &#125; result.add(list); &#125; return result;&#125; TreeNode123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; 1two sum]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构---二叉树]]></title>
    <url>%2F%2F2019%2F07%2F09%2F2019-07-09%2F</url>
    <content type="text"><![CDATA[为什么使用树结构123456789101112数组存储方式的分析优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低 链式存储方式的分析优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) 树存储方式的分析能提高数据存储，读取的效率, 比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。案例: [7, 3, 10, 1, 5, 9, 12] 前序遍历二叉树1234567891011121314151617181920public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; resultList=new ArrayList&lt;&gt;(); if(root==null) &#123; return resultList; &#125; preOrder(resultList,root); return resultList; &#125; public void preOrder(List&lt;Integer&gt; resultList,TreeNode root) &#123; if(root==null) return; resultList.add(root.val); preOrder(resultList,root.left); preOrder(resultList,root.right); &#125; 中序遍历二叉树123456789101112131415161718192021public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; resultList=new ArrayList&lt;&gt;(); if(root==null) &#123; return resultList; &#125; InOrder(resultList,root); return resultList; &#125; public void InOrder(List&lt;Integer&gt; resultList,TreeNode root) &#123; if(root==null) return; InOrder(resultList,root.left); resultList.add(root.val); InOrder(resultList,root.right); &#125; 后序遍历二叉树1234567891011121314151617181920public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; resultList=new ArrayList&lt;&gt;(); if(root==null) &#123; return resultList; &#125; postOrder(resultList,root); return resultList; &#125; public void postOrder(List&lt;Integer&gt; resultList,TreeNode root) &#123; if(root==null) return; postOrder(resultList,root.left); postOrder(resultList,root.right); resultList.add(root.val); &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构---哈希表]]></title>
    <url>%2F%2F2019%2F07%2F08%2F2019-07-08%2F</url>
    <content type="text"><![CDATA[哈希表简单介绍可以用来做缓存 1234567Java程序 《=》 缓存层 =&gt;数据库 缓存产品：(1)Redis memcache 自己写：(1)哈希表 (2)数组+链表 (3)数组+二叉树 google公司的一个上机题: 有一个公司,当有新的员工来报道时,要求将该员工的信息加入(id,性别,年龄,名字,住址..),当输入该员工的id时,要求查找到该员工的所有信息. 要求:1、不使用数据库,,速度越快越好=&gt;哈希表(散列)2、添加时，保证按照id从低到高插入[课后思考：如果id不是从低到高插入，但要求各条链表仍是从低到高，怎么解决?]使用链表来实现哈希表, 该链表不带表头[即: 链表的第一个结点就存放雇员信息]思路分析并画出示意图代码实现[增删改查(显示所有员工，按id查询)]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176public class HashTabDemo &#123; public static void main(String[] args) &#123; // 创建哈希表 HashTab hashTab = new HashTab(7); // 写一个简单的菜单 String key = ""; Scanner scanner = new Scanner(System.in); while (true) &#123; System.out.println("add： 添加雇员"); System.out.println("list： 显示雇员"); System.out.println("find: 查找雇员"); System.out.println("exit： 退出系统"); key = scanner.next(); switch (key) &#123; case "add": System.out.println("输入id"); int id = scanner.nextInt(); System.out.println("输入名字"); String name = scanner.next(); // 创建雇员 Emp emp = new Emp(id, name); hashTab.add(emp); break; case "list": hashTab.list(); break; case "find": System.out.println("请输入要查找的id"); id = scanner.nextInt(); hashTab.findEmpById(id); break; case "exit": scanner.close(); System.exit(0); default: break; &#125; &#125; &#125;&#125;// 创建HashTable 管理多条链表class HashTab &#123; private EmpLinkedList[] empLinkedListArray; private int size; // 表示共有多少条链表 // 构造器 public HashTab(int size) &#123; // 表示有多少条链表 this.size = size; // 初始化empLinkedListArray empLinkedListArray = new EmpLinkedList[size]; // ？？？这里是坑,这是不要分别初始化每个链表 for (int i = 0; i &lt; size; i++) &#123; empLinkedListArray[i] = new EmpLinkedList(); &#125; &#125; // 添加雇员 public void add(Emp emp) &#123; // 根据员工的id，得到员工应当添加到哪条链表 int empLinkedListNo = hasFun(emp.id); // 将emp添加到对应的链表中 empLinkedListArray[empLinkedListNo].add(emp); &#125; // 编写散列函数，使用一个简单的取模法 public int hasFun(int id) &#123; return id % size; &#125; // 遍历所有的链表，遍历hastab public void list() &#123; for (int i = 0; i &lt; size; i++) &#123; empLinkedListArray[i].list(i); &#125; &#125; //根据输入的id 查找雇员 public void findEmpById(int id) &#123; //使用散列函数确定到哪条链表查找 int empLinkedListNo=hasFun(id); Emp emp = empLinkedListArray[empLinkedListNo].findEmpById(id); if(emp!=null) &#123;//找到 System.out.printf("在第%d条链表中找到 雇员 id = %d\n",(empLinkedListNo+1),id); &#125;else &#123; System.out.println("在哈希表中,没有找到该雇员~"); &#125; &#125;&#125;// 表示一个雇员class Emp &#123; public int id; public String name; public Emp next;// 默认为空 public Emp(int id, String name) &#123; super(); this.id = id; this.name = name; &#125;&#125;// 创建EmpLinkedList，表示链表class EmpLinkedList &#123; // 头指针，执行第一个Emp，因此我们这个链表的head 是直接指向第一个Emp private Emp head;// 默认为空 // 添加雇员到链表 // 说明 // 1.假定，当添加雇员时，id是自增长，即id的分配点总是从小到大 // 因此我们将该雇员直接加入到本链表的最后即可 public void add(Emp emp) &#123; // 如果添加第一个雇员 if (head == null) &#123; head = emp; return; &#125; // 如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后 Emp curEmp = head; while (true) &#123; if (curEmp.next == null) &#123;// 说明到链表最后 break; &#125; curEmp = curEmp.next;// 后移 &#125; // 退出时直接将emp 加入链表即可 curEmp.next = emp; &#125; // 遍历链表的雇员信息 public void list(int no) &#123; if (head == null) &#123;// 说明链表为空 System.out.println("第" + (no + 1) + "链表为空"); return; &#125; System.out.print("第" + (no + 1) + "条链表的信息为 "); Emp curEmp = head;// 辅助指针 while (true) &#123; System.out.printf("=&gt; id=%d name=%s\t", curEmp.id, curEmp.name); if (curEmp.next == null) &#123;// 说明curEmp已经是最后节点 break; &#125; curEmp = curEmp.next;// 后移，遍历 &#125; System.out.println(); &#125; // 根据id查找雇员 // 如果查找到,就返回Emp，如果没有找到，就返回null public Emp findEmpById(int id) &#123; // 判断链表是否为空 if (head == null) &#123; System.out.println("链表为空"); return null; &#125; // 辅助指针 Emp curEmp = head; while (true) &#123; if (curEmp.id == id) &#123;// 找到 break;// 这是curEmp就指向要查找的雇员 &#125; // 退出 if (curEmp.next == null) &#123; // 说明遍历当前链表没有找到该雇员 curEmp = null; break; &#125; curEmp=curEmp.next;//以后 &#125; return curEmp; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构二分查找及峰插查找及斐波那契查找算法]]></title>
    <url>%2F%2F2019%2F07%2F07%2F2019-07-07%2F</url>
    <content type="text"><![CDATA[二分查找思路分析 首先确定该数组的中间的下标mid=(left+right)/2 然后让需要查找的数findVal和arr[mid]比较2.1 findVal&gt;arr[mid]，说明你要查找的数在mid的右边，因此需要递归的向右查找2.2 findVal &lt;arr[mid]，说明你要查找的数在mid的左边，因此需要递归的向左查找2.3 findVal==arr[mid]说明找到，就返回 //什么时候我们需要结束递归1)找到就结束递归2)递归完整个数组，仍然没有找到findVal，也需要结束递归，当left&gt;right就需要退出 binarySearch1针对于当一个有序数组中，有多个相同的数值时，如何将所有的数组都查找到，比如有多个1000{1, 8, 10, 89, 1000, 1000,1000, 1234 } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//注意：使用二分查找的前提是 ： 该数组的是有序的。public class BinarySearch &#123; /** * * @param arr 数组 * @param left 左边的索引 * @param right 右边的索引 * @param findVal 要查找的值 * @return 如果找到就返回下标，如果没找到，返回-1 */ public static int binarySearch(int[] arr,int left ,int right,int findVal) &#123; //当left&gt;right时，说明递归整个数组没找到 if (left &gt; right) return -1; int mid =(left+right)/2; int midVal=arr[mid]; if(findVal&gt;midVal) &#123;//向右递归 return binarySearch(arr, mid+1,right, findVal); &#125; if(findVal&lt;midVal) &#123;//向左递归 return binarySearch(arr, left,mid-1, findVal); &#125; else &#123; return mid; &#125; &#125; public static void main(String[] args) &#123; /*int arr[] = &#123; 1, 8, 10, 89, 1000, 1234 &#125;; int resIndex=binarySearch(arr, 0, arr.length, 1234);*/ int arr[] = &#123; 1, 8, 10, 89, 1000,1000,1000,1000, 1234 &#125;; List&lt;Integer&gt; resIndexList = binarySearch1(arr, 0, arr.length, 1000); System.out.println("resIndex= "+resIndexList); &#125; /* * 当一个有序数组中，有多个相同的数值时，如何将所有的数组都查找到， * 比如有多个1000 * &#123;1, 8, 10, 89, 1000, 1000,1000, 1234 &#125;; * * 思路分析 * 1. 在找到mid 值，不要马上返回 * 2. 向mid 索引值的左边扫描，将所有满足1000，的元素的下标，加入到集合ArrayList * 3. 向mid 索引值的右边扫描，将所有满足1000，的元素的下标，加入到集合ArrayList * 4. 将ArrayList返回 * * */ public static List&lt;Integer&gt; binarySearch1(int[] arr,int left ,int right,int findVal) &#123; //当left&gt;right时，说明递归整个数组没找到 if (left &gt; right) return new ArrayList&lt;Integer&gt;(); int mid =(left+right)/2; int midVal=arr[mid]; if(findVal&gt;midVal) &#123;//向右递归 return binarySearch1(arr, mid+1,right, findVal); &#125; if(findVal&lt;midVal) &#123;//向左递归 return binarySearch1(arr, left,mid-1, findVal); &#125; else &#123; ArrayList&lt;Integer&gt; resIndexlist = new ArrayList&lt;Integer&gt;(); //向mid 索引值的左边扫描，将所有满足1000，的元素的下标，加入到集合ArrayList int temp =mid-1; while(true) &#123; if(temp&lt;0||arr[temp]!=findVal) &#123;//temp到左边，退出 break; &#125; //否则，就将temp放入到resIndexlist中 resIndexlist.add(temp); temp-=1;//temp左移 &#125; resIndexlist.add(mid); temp=mid+1; while(true) &#123; if(temp&gt;arr.length-1||arr[temp]!=findVal) &#123; //退出 break; &#125; //否则，就将temp放入到resIndexlist resIndexlist.add(temp); temp+=1;//temp右移 &#125; return resIndexlist; &#125; &#125;&#125; 插值查找算法1）算法类似于二分查找，不同的是插值查找每次从自适应的mid开始查找。2）将折半查找中的求mid索引的公式，low表示左边索引left，high表示右边索引right. mid=(low+high)/2=&gt;low +1/2(high-low)改成mid=low+(high-low)(key-a[low])/(a[high]-a[low)/插值索引/int mid=left+(right-left)(findVal-arr[left])/(arr[right]-arr[left]) 数组arr=[1,2,3,……,100]需要查找的数为1使用二分查找需要多次递归，才能找到1使用插值查找算法比如我们查找1int mid =0+(99-0)(1-1)/(100-1)=0+990/99= 0比如我们查找100int mid =0+(99-0)*(100-1)/(100-1)= 99 一次就查找到12345678910111213141516171819202122232425262728293031public class InsertValueSearch &#123; public static void main(String[] args) &#123; int[] arr = new int[100]; for (int i = 0; i &lt; 100; i++) &#123; arr[i] = i + 1; &#125; int index = insertValueSearch(arr, 0, arr.length - 1, 100); System.out.println("index= " + index); // System.out.println(Arrays.toString(arr)); &#125; public static int insertValueSearch(int[] arr, int left, int right, int findVal) &#123; System.out.println("峰插查找被调用"); // 注意： findVal &lt; arr[0] || findVal &gt; arr[arr.length - 1] 必须需要，防止mid越界 if (left &gt; right || findVal &lt; arr[0] || findVal &gt; arr[arr.length - 1]) &#123; return -1; &#125; // 自适应，数据量较大，关键字分布比较均匀的查找表，采用较快 int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]); int midVal = arr[mid]; if (findVal &gt; midVal) &#123;// 说明应该向右边递归 return insertValueSearch(arr, mid + 1, right, findVal); &#125; else if (findVal &lt; midVal) &#123;// 说明应该向左边递归 return insertValueSearch(arr, left, mid - 1, findVal); &#125; else &#123; return mid; &#125; &#125;&#125; 斐波那契查找借助斐波那契数列找到分割点k，需要先把数组扩展成能够找到分割点的数列，扩展需求使用a数组最后的数填充temp斐波那契原理：斐波那契查找原理与前两种相似，仅仅改变了中间结点mid的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，mid=low+f[k-1]-1（F代表斐波那契数列） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class FibonacciSort &#123; public static int maxSize=20; public static void main(String[] args) &#123; int arr[] = &#123; 1, 8, 10, 89, 1000, 1234 &#125;; System.out.println("index="+fibSearch(arr, 89)); &#125; //因为后面我们mid=low+F(k-1)-1,需要使用斐波那契数列，因此我们需要先获取到一个斐波那契数列 //非递归方法得到一个斐波那契数列 public static int[] fib() &#123; int[] f=new int[maxSize]; f[0]=1; f[1]=1; for(int i =2;i&lt;maxSize;i++) &#123; f[i]=f[i-1]+f[i-2]; &#125; return f; &#125; //编写斐波那契查找算法 //使用非递归的方式编写算法 public static int fibSearch(int[]a,int key) &#123; int low = 0; int high = a.length - 1; int k = 0;// 表示斐波那契分割数值的下标 int mid = 0;//存放mid值 int f[] = fib();//获取斐波那契数列 //获取到斐波那契分割数值的下标 while (high &gt; f[k] - 1) &#123; k++; &#125; //f[k] 值可能大于 a 的长度 ，因此我们需要使用Arrays类，构造一个新的数组，并指向teMp[] //不足的部分会使用0来填充 int[] temp = Arrays.copyOf(a, f[k]); //实际上需求使用a数组最后的数填充temp //举例：int arr[] = &#123; 1, 8, 10, 89, 1000, 1234 &#125;; //temp=&#123;1,8,10,89,1000,1234,0,0,0&#125;=&gt;&#123;1,8,10,89,1000,1234,1234,1234,1234&#125; for (int i = high + 1; i &lt; temp.length; i++) &#123; temp[i] = a[high]; &#125; //使用while循环处理，找到我们的这个数 key while (low &lt;= high) &#123; // 只有满足条件，就可以找 mid = low + f[k - 1] - 1; if(key&lt;temp[mid]) &#123; //我们应该继续向数组的前面查找(左边) high = mid - 1; //为什么是k--,1.全部的元素=前面的元素+后边的元素 // 2.f[k]=f[k-1]+f[k-2] // 因为 前面有f[k-1]个元素，所以可以继续拆分 f[k-1]=f[k-2]+f[k-3] //在f[k-1]的前面继续查找 k-- //下次循环的mid=f[k-1-1]-1 k--; &#125; else if (key &gt; temp[mid]) &#123;//我们应该继续向数组的前面查找(右边) low = mid + 1; //为什么是k-=2,1.全部的元素=前面的元素+后边的元素 // 2.f[k]=f[k-1]+f[k-2] // 3.因为 后面有f[k-2]个元素，所以可以继续拆分 f[k-1]=f[k-3]+f[k-3] // 4.f[k-2]的前面进行查找k-=2 // 5.下次循环mid=f[k-1-2]-1 k -= 2; &#125;else &#123; //找到 //需要确定，返回的是哪个下标 if(mid&lt;=high) &#123; return mid; &#125;else &#123; return high; &#125; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构基数排序(桶排序)]]></title>
    <url>%2F%2F2019%2F07%2F06%2F2019-07-06%2F</url>
    <content type="text"><![CDATA[基数排序[53,3,542,748,14,214] 第一轮排序：1）将每个元素的个位数取出，然后看这个数应该放在哪个对应的桶(一个一维数组)2）按照这个桶的顺序(一维数组的下标一次取出数据，放入原来数组)数组的第一轮排序arr=[542,53,3,14,214,748]第二轮排序1）将每个元素的十位数取出，然后看这个数应该放在哪个对应的桶(一个一维数组)2）按照这个桶的顺序(一维数组的下标一次取出数据，放入原来数组)arr=[3,14,214,542,748,53]第三轮排序1）将每个元素的百位数取出，然后看这个数应该放在哪个对应的桶(一个一维数组) 短的补02）按照这个桶的顺序(一维数组的下标一次取出数据，放入原来数组)arr=[3,14,53,214,542,748] 1)radix sort 属于分配式排序 distruibution sort 又称 bucket sort，是通过键值的各个位的值，将要排序的元素分配至某些”桶”中，达到排序的作用。2)效率高的稳定性排序法3)基数排序是桶排序的扩展，Error速度很快，对海量数据 OutOfMemory图文基数排序 平均O(d(n+r)),最好O(d(n+r)),最坏O(d(n+r));空间复杂度O(n+r);稳定;较复杂 d为位数,r为分配后链表的个数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164public class RadixSort &#123; public static void radixSort(int[] arr) &#123; //总结 //1.得到数组中最大的数的位数 int max=arr[0];//假设第一个数就是最大数 for(int i=1;i&lt;arr.length;i++) &#123; if(arr[i]&gt;max) &#123; max=arr[i]; &#125; &#125; //得到最大数是几位数 int maxLength=(max + "").length(); // 1、二维数组包含十个一维数组 // 2、为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length int[][] bucket = new int[10][arr.length]; // 为了记录每个桶中，实际存放了多少个数据，我们定义一个一维数组来记录各个桶的每次放入的数据个数 // 比如buketElementCounts[0],记录的就是bucket[0] 桶放入的数据个数 int[] buketElementCounts = new int[10]; for(int i =0,n=1;i&lt;maxLength;i++,n*=10) &#123; // (针对每个元素的对应的位进行排序处理)，第一次个位，第二次十位，第三次百位 for (int j = 0; j &lt; arr.length; j++) &#123; // 取出每个元素的对应位的值 int digitOfElement = arr[j] / n % 10; // 放入到对应的桶中 bucket[digitOfElement][buketElementCounts[digitOfElement]] = arr[j]; buketElementCounts[digitOfElement]++; &#125; // 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) int index = 0; for (int k = 0; k &lt; buketElementCounts.length; k++) &#123; // 如果桶中，有数据，我们才放到原数组 if (buketElementCounts[k] != 0) &#123; // 循环该桶即第k个桶(第k个一维数组)，放入 for (int l = 0; l &lt; buketElementCounts[k]; l++) &#123; // 取出元素放入到arr arr[index++] = bucket[k][l]; &#125; &#125; // 第i+1一轮处理后，需要将每个buketElementCounts[k] = 0!!!!!! buketElementCounts[k] = 0; &#125;// System.out.println("基数排序后第"+(i+1)+"轮arr： " + Arrays.toString(arr)); &#125; &#125; /** * 基数排序 推导过程 * @param arr */ public static void radixSort1(int[] arr) &#123; //定义一个二维数组，表示是个桶，每个桶就是一个一位数组 //说明 //1、二维数组包含十个一维数组 //2、为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length int[][] bucket = new int[10][arr.length]; // 为了记录每个桶中，实际存放了多少个数据，我们定义一个一维数组来记录各个桶的每次放入的数据个数 // 比如buketElementCounts[0],记录的就是bucket[0] 桶放入的数据个数 int[] buketElementCounts = new int[10]; // ============================================== // 第一轮(针对每个元素的个位进行排序处理) for (int j = 0; j &lt; arr.length; j++) &#123; // 取出每个元素的个位的值 int digitOfElement = arr[j] / 1 % 10; // 放入到对应的桶中 bucket[digitOfElement][buketElementCounts[digitOfElement]] = arr[j]; buketElementCounts[digitOfElement]++; &#125; // 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) int index = 0; for (int k = 0; k &lt; buketElementCounts.length; k++) &#123; // 如果桶中，有数据，我们才放到原数组 if (buketElementCounts[k] != 0) &#123; // 循环该桶即第k个桶(第k个一维数组)，放入 for (int l = 0; l &lt; buketElementCounts[k]; l++) &#123; // 取出元素放入到arr arr[index++] = bucket[k][l]; &#125; &#125; //第一轮处理后，需要将每个buketElementCounts[k] = 0!!!!!! buketElementCounts[k] = 0; &#125; System.out.println("基数排序后第一轮arr： " + Arrays.toString(arr)); // ============================================== // 第二轮(针对每个元素的十位进行排序处理) for (int j = 0; j &lt; arr.length; j++) &#123; // 取出每个元素的个位的值 int digitOfElement = arr[j] / 10 % 10; // 748/10=&gt;74%10=&gt;4 // 放入到对应的桶中 bucket[digitOfElement][buketElementCounts[digitOfElement]] = arr[j]; buketElementCounts[digitOfElement]++; &#125; // 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) index = 0; for (int k = 0; k &lt; buketElementCounts.length; k++) &#123; // 如果桶中，有数据，我们才放到原数组 if (buketElementCounts[k] != 0) &#123; // 循环该桶即第k个桶(第k个一维数组)，放入 for (int l = 0; l &lt; buketElementCounts[k]; l++) &#123; // 取出元素放入到arr arr[index++] = bucket[k][l]; &#125; &#125; //第二轮处理后，需要将每个buketElementCounts[k] = 0!!!!!! buketElementCounts[k] = 0; &#125; System.out.println("基数排序后第二轮arr： " + Arrays.toString(arr)); // ============================================== // 第三轮(针对每个元素的百位进行排序处理) for (int j = 0; j &lt; arr.length; j++) &#123; // 取出每个元素的个位的值 int digitOfElement = arr[j] / 100 % 10; // 748/100=&gt;7%10=&gt;7 // 放入到对应的桶中 bucket[digitOfElement][buketElementCounts[digitOfElement]] = arr[j]; buketElementCounts[digitOfElement]++; &#125; // 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) index = 0; for (int k = 0; k &lt; buketElementCounts.length; k++) &#123; // 如果桶中，有数据，我们才放到原数组 if (buketElementCounts[k] != 0) &#123; // 循环该桶即第k个桶(第k个一维数组)，放入 for (int l = 0; l &lt; buketElementCounts[k]; l++) &#123; // 取出元素放入到arr arr[index++] = bucket[k][l]; &#125; &#125; &#125; System.out.println("基数排序后第三轮arr： " + Arrays.toString(arr)); &#125; public static void main(String[] args) &#123; /*int arr[] = &#123; 53, 3, 542, 748, 14, 214 &#125;; radixSort(arr);*/ //80000000 * 11 * 4 /1024 / 1024 /1024 =3.3G //耗费额外的内存空间 int[] arr = new int[8000000]; for (int i = 0; i &lt; 8000000; i++) &#123; arr[i] = (int) (Math.random() * 80000); // 生成一个[0,80000]的数随机数 &#125; Date date1 = new Date(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1str = sdf.format(date1); System.out.println("排序前的时间： " + date1str); int temp[] = new int[arr.length]; radixSort(arr); Date date2 = new Date(); String date2str = sdf.format(date2); System.out.println("排序后的时间: " + date2str);// System.out.println(Arrays.toString(arr)); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构快速排序(二)]]></title>
    <url>%2F%2F2019%2F07%2F05%2F2019-07-05%2F</url>
    <content type="text"><![CDATA[以中轴值为基准的快速排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class QuickSort1 &#123; public static void quickSort(int[] arr,int left,int right) &#123; int l=left;//左下标 int r=right;//右下标 //pivot中轴值 int pivot=arr[(left+right)/2]; int temp=0;//临时变量，作为交换时使用 //while循环的目的让比pivot小放到左边 //比pivot值大放到右边 while(l&lt;r) &#123; //在pivot的左边一直找，找到大于等于pivot值，才退出 while(arr[l]&lt;pivot) &#123; l+=1; &#125; //在pivot的右边一直找，找到小于等于pivot值，才退出 while(arr[r]&gt;pivot) &#123; r-=1; &#125; //如果l&gt;=r说明pivot左右两边的值，按照左边全部是 //小于等于pviot值，右边全部都是大于等于pviot值 if(l&gt;=r) &#123; break; &#125; //交换 temp=arr[l]; arr[l]=arr[r]; arr[r]=temp; //如果交换完后，发现arr[1]==pivot值 r--，前移 if(arr[l]==pivot) &#123; r-=1; &#125; //如果交换完后，发现arr[r]==pivot值 l--，前移 if(arr[r]==pivot) &#123; l+=1; &#125; &#125; //如果l==r ,必须l++，r--，否则出现栈溢出 if(l==r) &#123; l+=1; r-=1; &#125; //向左递归 if(left&lt;r) &#123; quickSort(arr, left, r);//把左边的变成有序的 &#125; if(right&gt;l) &#123; quickSort(arr, l, right);//把右边的变成有序的 &#125; &#125; /** * 之前 -9,78,0,23,-567,70 * 向左递归 -9, -567, 0, 23, 78, 70 * 向右递归 -567, -9, 0, 23, 70, 78 */ public static void main(String[] args) &#123; int[] test = new int[] &#123;-9,78,0,23,-567,70&#125;; int[] arr = new int[800000]; for (int i = 0; i &lt; 800000; i++) &#123; arr[i] = (int) (Math.random() * 80000); // 生成一个[0,80000]的数随机数 &#125; Date date1 = new Date(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1str = sdf.format(date1); System.out.println("排序前的时间： " + date1str); quickSort(arr,0,arr.length-1); Date date2 = new Date(); String date2str = sdf.format(date2); System.out.println("排序后的时间: " + date2str);// quickSort(arr, 0, arr.length-1); System.out.println(Arrays.toString(arr)); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构快速排序]]></title>
    <url>%2F%2F2019%2F07%2F03%2F2019-07-03%2F</url>
    <content type="text"><![CDATA[快速排序，大致有两种，一种以中轴值为基准，还有就是以左边第一个数为基准 快速排序 中轴值 平均O(nlogn),最好O(nlogn),最坏O(n^2);空间复杂度O(nlogn);不稳定;较复杂 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class QuickSort &#123; public static void quickSort(int[] a, int left, int right) &#123; if(left&gt;=right) return; int i = left; int j = right; int t=0; int temp = a[left];//temp中存的是基准数 while (i!=j) &#123; while (i &lt; j &amp;&amp; a[j] &gt;= temp)//顺序很重要，要先从右边开始找 j--; while (i &lt; j &amp;&amp; a[i] &lt;= temp)//再找左边的 i++; if(i&lt;j)//交换两个数在数组中的位置 &#123; t=a[i]; a[i]=a[j]; a[j]=t; &#125; &#125; //最终将基准数归位 a[left]=a[i]; a[i]=temp; quickSort(a,left,i-1);//继续处理左边的，这里是一个递归的过程 quickSort(a,i+1,right);//继续处理右边的 ，这里是一个递归的过程 &#125; public static void main(String[] args) &#123;// int[] a= &#123;-9,78,0,23,-567,70,8&#125;; int[] a = &#123; 49 ,38 ,65 ,97, 76, 13 ,27 &#125;; int[] arr = new int[80]; for (int i = 0; i &lt; 80; i++) &#123; arr[i] = (int) (Math.random() * 80000); // 生成一个[0,80000]的数随机数 &#125; Date date1 = new Date(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1str = sdf.format(date1); System.out.println("排序前的时间： " + date1str); quickSort(a,0,a.length-1); Date date2 = new Date(); String date2str = sdf.format(date2); System.out.println("排序后的时间: " + date2str);// quickSort(arr, 0, arr.length-1); System.out.println(Arrays.toString(a)); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构选择排序与插入排序及其改进-希尔排序]]></title>
    <url>%2F%2F2019%2F07%2F02%2F2019-07-02%2F</url>
    <content type="text"><![CDATA[说明:1 选择排序一共有数组大小：1轮排序2 每一轮排序，又是一个循环的规则2.1 假定当前这个数最小2.2 然后和后面的数比较，如果发现有比当前更小的数，就重新确定最小数，并得到下标2.3 遍历到数组的最后，就得到本轮最小数和下标2.4 交换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public class SelectSort &#123; public static void selectSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; int min = arr[i]; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j])// 假定的最下值，并不是最小 &#123; min = arr[j];// 重置min minIndex = j;// 重置minIndex &#125; &#125; if (minIndex != i) &#123; arr[minIndex] = arr[i]; arr[i] = min; &#125; // System.out.println("第" + (i + 1) + "轮" + Arrays.toString(arr)); &#125; // 分析过程 // 第一轮 /*int minIndex = 0; int min = arr[0]; for (int j = 0 + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j])// 假定的最下值，并不是最小 &#123; min = arr[j];// 重置min minIndex = j;// 重置minIndex &#125; &#125; if(minIndex!=0) &#123; arr[minIndex] = arr[0]; arr[0] = min; &#125; System.out.println("第一轮" + Arrays.toString(arr)); // 第二轮 minIndex = 1; min = arr[1]; for (int j = 1 + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j])// 假定的最下值，并不是最小 &#123; min = arr[j];// 重置min minIndex = j;// 重置minIndex &#125; &#125; if(minIndex!=1) &#123; arr[minIndex] = arr[1]; arr[1] = min; &#125; System.out.println("第二轮" + Arrays.toString(arr)); // 第三轮 minIndex = 2; min = arr[2]; for (int j = 2 + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j])// 假定的最下值，并不是最小 &#123; min = arr[j];// 重置min minIndex = j;// 重置minIndex &#125; &#125; if(minIndex!=2) &#123; arr[minIndex] = arr[2]; arr[2] = min; &#125; System.out.println("第三轮" + Arrays.toString(arr));*/&#125; public static void main(String[] args) &#123; int[] a = &#123; 101, 34, 119, 1 &#125;; int[] arr = new int[80000]; for (int i = 0; i &lt; 80000; i++) &#123; arr[i] = (int) (Math.random() * 80000); // 生成一个[0,80000]的数随机数 &#125; Date date1 = new Date(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1str = sdf.format(date1); System.out.println("排序前的时间： " + date1str); selectSort(arr); Date date2 = new Date(); String date2str = sdf.format(date2); System.out.println("排序后的时间: " + date2str);// System.out.println("排序前: "+Arrays.toString(a));// selectSort(a);// System.out.println("排序后: "+Arrays.toString(a)); &#125;&#125; 插入排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class InsertSort &#123; public static void insertSort(int[] arr) &#123; int insertVal = 0; int insertIndex = 0; for (int i = 1; i &lt; arr.length; i++) &#123; insertVal = arr[i]; insertIndex = i - 1; // 1.insertIndex&gt;=0 保证在给insertVal找插入的位置，不越界 // 2.insertVal &lt;arr[insertIndex] 待插入的数，还没有找到插入位置 // 3.就需要将arr[insertIndex] 后移 while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex + 1] = arr[insertIndex];// arr[insertIndex] insertIndex--; &#125; // 当退出while循环的时候，说明插入的位置找到，insertIndex+1 // 这里我们判断是否需要赋值 if (insertIndex + 1 != i) &#123; arr[insertIndex + 1] = insertVal; &#125; // System.out.println("第"+(i)+"轮： "+Arrays.toString(arr)); &#125; // 分析过程 // 定义插入的数 /* * int insertVal=arr[1]; int insertIndex=1-1;//即arr[1]的前面这个数的下标 * * // 1.insertIndex&gt;=0 保证在给insertVal找插入的位置，不越界 // 2.insertVal &lt;arr[insertIndex] * 待插入的数，还没有找到插入位置 // 3.就需要将arr[insertIndex] 后移 * * while(insertIndex&gt;=0&amp;&amp;insertVal&lt;arr[insertIndex]) &#123; * arr[insertIndex+1]=arr[insertIndex];//arr[insertIndex] insertIndex--; &#125; * //当退出while循环的时候，说明插入的位置找到，insertIndex+1 * * arr[insertIndex+1]=insertVal; * * System.out.println("第一轮： "+Arrays.toString(arr)); * * * //第二轮 insertVal=arr[2]; insertIndex=2-1; * while(insertIndex&gt;=0&amp;&amp;insertVal&lt;arr[insertIndex]) &#123; * arr[insertIndex+1]=arr[insertIndex];//arr[insertIndex] insertIndex--; &#125; * arr[insertIndex+1]=insertVal; * System.out.println("第二轮： "+Arrays.toString(arr)); * * //第三轮 insertVal=arr[3]; insertIndex=3-1; * while(insertIndex&gt;=0&amp;&amp;insertVal&lt;arr[insertIndex]) &#123; * arr[insertIndex+1]=arr[insertIndex];//arr[insertIndex] insertIndex--; &#125; * arr[insertIndex+1]=insertVal; * System.out.println("第三轮： "+Arrays.toString(arr)); */ &#125; public static void main(String[] args) &#123; int[] a = &#123; 101, 34, 119, 1 &#125;; insertSort(a); int[] arr = new int[80000]; for (int i = 0; i &lt; 80000; i++) &#123; arr[i] = (int) (Math.random() * 80000); // 生成一个[0,80000]的数随机数 &#125; Date date1 = new Date(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1str = sdf.format(date1); System.out.println("排序前的时间： " + date1str); insertSort(arr); Date date2 = new Date(); String date2str = sdf.format(date2); System.out.println("排序后的时间: " + date2str); // System.out.println(Arrays.toString(arr)); &#125;&#125; 对于arr={2,3,4,5,6,1},这时插入的数1（最小）2,3,4,5,6,62,3,4,5,5,62,3,4,4,5,62,3,3,4,5,62,3,2,4,5,61,2,3,4,5,6需要插入的数是较小的数，后移次数明显增多，对效率有影响提出了 希尔排序也称缩小增量排序对有序数列插入时采用交换法(1)交换法，(2)移动法，不是该数位置先后移123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class ShellSort &#123; public static void shellSort(int[] arr) &#123; int temp = 0; int count = 0; for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; // 遍历各组中所有的元素（共五组，每组两个元素），步长5 for (int j = i - gap; j &gt;= 0; j -= gap) &#123; if (arr[j] &gt; arr[j + gap]) &#123; temp = arr[j]; arr[j] = arr[j + gap]; arr[j + gap] = temp; &#125; &#125; &#125;// System.out.println("希尔排序第" + (++count) + "轮： " + Arrays.toString(arr)); &#125; //分析过程 //第一轮，将10个数分为5组 /*int temp=0; for(int i = 5;i&lt;arr.length;i++) &#123; //遍历各组中所有的元素（共五组，每组两个元素），步长5 for(int j=i-5;j&gt;=0;j-=5) &#123; if(arr[j]&gt;arr[j+5]) &#123; temp=arr[j]; arr[j]=arr[j+5]; arr[j+5]=temp; &#125; &#125; &#125; System.out.println("第一次排序后: "+Arrays.toString(arr)); //第二轮排序 ，5/2=2组 for(int i = 2;i&lt;arr.length;i++) &#123; //遍历各组中所有的元素（共五组，每组两个元素），步长5 for(int j=i-2;j&gt;=0;j-=2) &#123; if(arr[j]&gt;arr[j+2]) &#123; temp=arr[j]; arr[j]=arr[j+2]; arr[j+2]=temp; &#125; &#125; &#125; System.out.println("第二次排序后: "+Arrays.toString(arr)); //第三轮 ，2/2=1组 for(int i= 1;i&lt;arr.length;i++) &#123; //遍历各组中所有的元素（共五组，每组两个元素），步长5 for(int j=i-1;j&gt;=0;j-=1) &#123; if(arr[j]&gt;arr[j+1]) &#123; temp=arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; &#125; &#125; &#125; System.out.println("第三次排序后: "+Arrays.toString(arr));*/ &#125; //移位法改进 public static void shellSort2(int[] arr) &#123; for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; // 遍历各组中所有的元素（共五组，每组两个元素），步长5 int j = i; int temp = arr[j]; if (arr[j] &lt; arr[j - gap]) &#123; while (j - gap &gt;= 0 &amp;&amp; temp &lt; arr[j - gap]) &#123; // 移动 arr[j] = arr[j - gap]; j -= gap; &#125; // 当退出while时，就给temp找到插入的位置 arr[j] = temp; &#125; &#125; &#125; // System.out.println("希尔排序第" + (++count) + "轮： " + Arrays.toString(arr)); &#125; public static void main(String[] args) &#123; int[] a= &#123;8,9,1,7,2,3,5,4,6,0&#125;;// shellSort(a); int[] arr = new int[80000]; for (int i = 0; i &lt; 80000; i++) &#123; arr[i] = (int) (Math.random() * 80000); // 生成一个[0,80000]的数随机数 &#125; Date date1 = new Date(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1str = sdf.format(date1); System.out.println("shell排序前的时间： " + date1str);// shellSort(arr);//交换式 shellSort2(arr);//移位式 Date date2 = new Date(); String date2str = sdf.format(date2); System.out.println("shell排序后的时间: " + date2str);// System.out.println(Arrays.toString(arr)); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构归并排序与冒泡排序]]></title>
    <url>%2F%2F2019%2F07%2F01%2F2019-07-01%2F</url>
    <content type="text"><![CDATA[归并排序平均O(nlogn),最好O(nlogn),最坏O(nlogn);空间复杂度O(n);稳定;较复杂12345678910111213141516171819202122232425262728293031323334353637383940414243public class MyMergeSort &#123; public static void Merge(int[] a,int start,int mid,int end) &#123; int[] tmp =new int[a.length]; System.out.print("merge"+start+"~"+end+" "); int i=start,j=mid+1,k=start; while(i!=mid+1&amp;&amp;j!=end+1) &#123; if(a[i]&lt;a[j]) tmp[k++]=a[i++]; else tmp[k++]=a[j++]; &#125; //后面数组分好 while(i!=mid+1) tmp[k++]=a[i++]; //前面数组分好 while(j!=end+1) tmp[k++]=a[j++]; for(i=start;i&lt;=end;i++) a[i]=tmp[i]; for(int p:a) System.out.print(p+" "); System.out.println(); &#125; static void mergeSort(int[] a,int start,int end) &#123; if(start&lt;end) &#123; int mid=(start+end)/2; mergeSort(a, start, mid);//左边有序 mergeSort(a, mid+1, end);//右边有序 Merge(a, start, mid, end); &#125; &#125; public static void main(String[] args) &#123; int[] b = &#123; 49, 38, 65, 97, 76, 13, 27, 50 &#125;; mergeSort(b, 0, b.length-1); &#125;&#125; 归并排序测试速度 新07-06123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class MergeSort &#123; //分+合的方法 public static void mergeSort(int[] arr, int left, int right, int[] temp) &#123; if (left &lt; right) &#123; int mid = (left + right) / 2;// 中间索引 // 向左递归进行分解 mergeSort(arr, left, mid, temp); mergeSort(arr, mid + 1, right, temp); //***合并 merge(arr, left, mid, right, temp); &#125; &#125; // 合并的方法 /** * * @param arr 排序的原始数组 * @param left 左边有序序列的初始索引 * @param mid 中间索引 * @param right 右边索引 * @param tmp 做中转的临时数组 */ public static void merge(int arr[], int left, int mid, int right, int[] temp) &#123;// System.out.println("xxx"); int i = left;// 初始化i,左边有序序列的初始索引 int j = mid + 1; // 初始化j,右边有序序列的初始索引 int t = 0; // 指向temp数组的当前索引 // (一)// 先把左右两边(有序)的数据按照规则填充到temp数组// 直到左右两边的有序序列，有一边处理完毕为止 while(i&lt;=mid&amp;&amp;j&lt;=right) &#123; //继续 //如果左边的的有序序列的当前元素,小于等于右边有序序列的当前元素 //即将左边的当前元素，拷贝到temp数组 //然后t++，i++ 是为了下一个需要拷贝的元素 if (arr[i] &lt;= arr[j]) &#123; temp[t] = arr[i]; t += 1; i += 1; &#125; else &#123; // 反之，将右边有序序列的当前元素，填充到temp数组 temp[t] = arr[j]; t += 1; j += 1; &#125; &#125;// (二)// 把有剩余的数据一边的数据依次全部填充到temp while (i &lt;= mid) &#123;// 左边的有序序列还有剩余的元素，就全部填充到temp temp[t] = arr[i]; t += 1; i += 1; &#125; while (j &lt;= right) &#123;// 右边的有序序列还有剩余元素，全部填充到temp temp[t] = arr[j]; t += 1; j += 1; &#125; // (三)// 将temp数组的元素拷贝到arr //注意不是每次 都拷贝所有 t=0; int tempLeft = left;// System.out.println("tempLeft="+tempLeft+" right="+right); while (tempLeft &lt;= right) &#123; // 第一次合并temp=0，right=1//tempLeft=2 right =3//tempLeft=0,right=3 // 最后一次tempLeft=0，right=7 arr[tempLeft] = temp[t]; t += 1; tempLeft += 1; &#125; &#125; public static void main(String[] args) &#123;// int test[] = &#123; 8, 4, 5, 7, 1, 3, 6, 2, &#125;; int[] arr = new int[8000000]; for (int i = 0; i &lt; 8000000; i++) &#123; arr[i] = (int) (Math.random() * 80000); // 生成一个[0,80000]的数随机数 &#125; Date date1 = new Date(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1str = sdf.format(date1); System.out.println("排序前的时间： " + date1str); int temp[] = new int[arr.length]; mergeSort(arr, 0, arr.length-1, temp); mergeSort(arr,0,arr.length-1,temp); Date date2 = new Date(); String date2str = sdf.format(date2); System.out.println("排序后的时间: " + date2str);// System.out.println("归并排序后="+Arrays.toString(arr)); &#125;&#125; 冒泡排序规则(1)一共进行的数组的大小-1次大的循环(2)每一趟排序的次数在逐渐的减少(3)如果我们发现在某趟排序中，没有发生一次交换，可以提前结束冒泡排序。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class BubbleSort &#123; public static void bubbleSort(int[] a)&#123; int n = a.length; int temp = 0; boolean flag=false;//标识变量，表示是否进行过交换 for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n-i-1;j++)&#123; if(a[j]&gt;a[j+1])&#123; flag=true; temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; &#125; &#125;// System.out.println("第"+(i+1)+"趟排序后的数组");// System.out.println(Arrays.toString(a)); if(flag==false) &#123; //在一堂排序中，一次交换都没有发生过 break; &#125; else &#123; flag=false;//重置flag，进行下次判断 &#125; &#125; &#125; public static void main(String[] args) &#123; int[] a =&#123;3,9,-1,10,20&#125;; int[] arr=new int[80000]; for (int i = 0; i &lt; 80000; i++) &#123; arr[i]=(int)(Math.random()*80000); //生成一个[0,80000]的数随机数 &#125; Date date1=new Date(); SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1str = sdf.format(date1); System.out.println("排序前的时间： "+date1str); bubbleSort(arr); Date date2=new Date(); String date2str = sdf.format(date2); System.out.println("排序后的时间: "+date2str); /*System.out.println("排序前："+Arrays.toString(arr)); System.out.println("排序后"); for(int j:arr) System.out.print(j+" ");*/ &#125; &#125; 123结果输出：排序前的时间： 2019-07-03 09:07:28排序后的时间： 2019-07-03 09:07:39]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android实训]]></title>
    <url>%2F%2F2019%2F06%2F28%2F2019-06-28%2F</url>
    <content type="text"><![CDATA[手机备忘录APP功能需求–a、主界面设计,备忘记录的分页展示– b、备忘录的添加、修改和删除功能– c、设计界面菜单– d、闹钟提醒功能 SDK Android Gradle 虚拟机 Genymotion 代码结构 ①MainActibity布局文件的编写②Alarm、AlarmNote闹钟的设置与实现③ActivityManager 公共类，添加保存，获取时间、设置铃声路径④EditActivity为备忘录的添加一条备忘录和设置提醒时间⑤LineEditText实现显示页面格式⑥SetAlarm设置铃声的界面⑦SqliteDBConnect sqllite 数据库连接，创建。 Successful进入备忘录，首页按钮，下一页等功能 长按一个备忘信息，修改和删除功能。 修改的界面，保存等操作。添加一条Note，保存时的必要条件。单击或者长按时间按钮 成功添加 单击备忘信息查看详细 闹钟功能的提示代码已上传 https://github.com/zhangcv/NotePad]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringAOP编码式事务]]></title>
    <url>%2F%2F2019%2F06%2F21%2F2019-06-21%2F</url>
    <content type="text"><![CDATA[数据库连接池： JDK dataSource接口 1）c3p0 数据库连接池 并发 2）DBCP database connection pool ：apache开发的，数据连接池的实现，教学。 3）Druid Ali：开源的数据库连接池。 2.搭建Spring 事务框架 1）创建数据库连接池 c3p0中的ComboPooledDataSource &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUtil&quot; value=&quot;jdbd:mysql://localhost:3306/neusoft&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt; &lt;property name=&quot;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; initialPoolSize 连接池的最大个数 loginTimeout 超时时间 maxPoolSize 最大多少个连接 2）创建JDBCTemplate 3）创建事务管理DataSourceTransactionManager Spring中的事务1）编码式事务（手动） JDBCConnection2）声明式事务（自动）：配置文件 注解的方式 在三层体系中，事务通常定义在Service层，不要定义在dao层 编码式事务：applicationContext.xml12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:dwr="http://www.directwebremoting.org/schema/spring-dwr" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd"&gt; &lt;!-- 开启注解，这个包下所有的注解，让注解生效 --&gt; &lt;context:component-scan base-package="com.neusoft"&gt;&lt;/context:component-scan&gt; &lt;!-- 1.数据库连接池c3p0 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/newdbss"&gt;&lt;/property&gt; &lt;property name="user" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="123456"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 2.创建JDBCTemplate --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 3.Spring来进行事务管理，事务是针对于数据库的 --&gt; &lt;bean id="dataSourceTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 注意jdbcUrl UserService的代码1234567891011121314151617public void add()&#123; TransactionStatus transactionStatus =null; try &#123; //事务的开始 transactionStatus = transactionManager.begin(); userDao.addUser(new User("zhangsan-"+System.currentTimeMillis(),"123456")); //int i=1/0; userDao.addUser(new User("zhangsan-"+System.currentTimeMillis(),"123456")); //事务的提交 transactionManager.commit(transactionStatus); &#125; catch (Exception e) &#123; //事务的回滚 transactionManager.rollback(transactionStatus); e.printStackTrace(); &#125;&#125; 添加了事务后： 如果在两条数据之间 int i=1/0; 报错 两条数据都插入不进去。没有事务： 会添加进一条。 编码式事务中，增删查改每一个都需要添加try catch 这三条事务的语句，在Spring中有声明式事务，通过注解的形式解决。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringAOP常用注解]]></title>
    <url>%2F%2F2019%2F06%2F18%2F2019-06-18%2F</url>
    <content type="text"><![CDATA[Spring常用注解 SpringAOP如何来实现事务的管理的 注解1)@Controller 标注控制器层2)@Service 标注服务层3)@Repository 标注数据访问层4)@Resource 标注当前注入 建议使用，因为@Resource耦合度会低 5)@Autowired 标注的是注入 6)@Component 表示标注所有的对象到容器中。（万能的注解） 面试Resource、Autowired 问区别和联系？相同点1.使用注解的方法注入bean。2.注解的位置可以是容器类中的属性，也可以是其中的setter方法不同点（1）默认按名称进行注入，通过name属性进行指定对应bean的Id或者name；userService这个接口的实现类，找不到会以类型注入。@Resource(name=”predicteDao”)（2）不使用name也可，比如@Resourceprivate UserService userService;默认会按类型注入，和 @Autowired效果一样。 Autowired是默认类型注入。 当我们使用注解方式配置好了关联之后，我们需要让关联生效 applicationContext.xml1234567891011&lt;bean id="userController" class="com.neusoft.controller.UserController"&gt; &lt;property name="userService" ref="userService"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="userService" class="com.neusoft.service.impl.UserServiceImpl"&gt; &lt;property name="userDao" ref="userDao"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="userDao" class="com.neusoft.dao.impl.UserDaoImpl"&gt; &lt;/bean&gt; Controller 1234567@ComponentUserController&#123; @Resource private UserService userService; ....&#125; UserServiceImpl 123456@ServiceUserServiceImpl&#123; @Resource private UserDao userDao;&#125; UserDaoImpl 1@Repository 其他总结：]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringAOP通知]]></title>
    <url>%2F%2F2019%2F06%2F17%2F2019-06-17%2F</url>
    <content type="text"><![CDATA[MethodBeforeAdvice、MethodAfterAdvice动态代理去代理某个类，这个类必须是实现了某个接口的类 @Override public void before(Method arg0, Object[] arg1, Object arg2) throws Throwable { System.out.println(“pre advice”); } @Override public void afterReturning(Object arg0, Method arg1, Object[] arg2, Object arg3) throws Throwable { System.out.println(“after advice”); } 1234567891011121314151617181920212223&lt;bean id="methodBeforeAdvice" class="com.neusoft.MyMethodBeforeAdvice"&gt;&lt;/bean&gt;&lt;bean id="methodAfterAdvice" class="com.neusoft.MyMethodAfterAdvice"&gt;&lt;/bean&gt;&lt;bean id="personTarget" class="com.neusoft.PersonImpl"&gt;&lt;/bean&gt;&lt;bean id="person" class="org.springframework.aop.framework.ProxyFactoryBean"&gt; &lt;property name="target"&gt; &lt;ref local="personTarget"/&gt; &lt;/property&gt; &lt;property name="interceptorNames"&gt; &lt;list&gt; &lt;value&gt;methodBeforeAdvice&lt;/value&gt; &lt;value&gt;methodAfterAdvice&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="proxyInterfaces"&gt; &lt;value&gt;com.neusoft.Person&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; 其中person 是一个代理类，是ProxyFactoryBean（注意别导错ProxyFactoryBean，造成没有interceptorNames的错误），返回的代理类实现了proxyInterfaces接口，所以也是一个Peson类型的。 name12 &lt;value&gt;com.neusoft.Person&lt;/value&gt;&lt;/property&gt; id12345678interceptorNames中添加一个 value methodAfterAdvice&lt;property name=&quot;interceptorNames&quot;&gt; &lt;list&gt; &lt;value&gt;methodBeforeAdvice&lt;/value&gt; &lt;value&gt;methodAfterAdvice&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; 输出的结果 123pre adviceexecute 2after advice AroundAdvice 环绕通知123&lt;bean id="aroundAdvice" class="com.neusoft.AroundAdvice"&gt;&lt;/bean&gt;在interceptorNames的list中添加&lt;value&gt;aroundAdvice&lt;/value&gt; 得出结果为123pre methodexecute 2after method 如果前置 后置通知不注释 12345pre advicepre methodexecute 2after methodafter advice 前置和环绕谁放在前面谁先执行。 当我们使用AOP进行代理目标对象的时候，如果目标对象没有实现某个接口，那么Spring会以CGlib 的方式进行增强。 public void afterThrowing(Method method,Object[] args,Object target,Exception ex) 在applicationCaontext.xml中声明 Student是一个class，没有实现接口的类。在interceptorNames添加 myThrowsException]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringAOP代理]]></title>
    <url>%2F%2F2019%2F06%2F16%2F2019-06-16%2F</url>
    <content type="text"><![CDATA[我们大家都知道租房，简单地说就是中介代替真实租户卖房，真实租户“委托”代理为其销售商品。关于租房，首先我们从他们那里买东西时通常不知道背后的卖家究竟是谁，也就是说，“委托者”对我们来说是不可见的，我们把中介和真实租户进一步抽象，前者可抽象为代理类，后者可抽象为委托类(被代理类)。通过使用代理，通常有两个优点：优点一：可以隐藏委托类的实现;优点二：可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理。 Subject.java1234public abstract class Subject &#123; public abstract void rent();//共同的行为&#125; RealSubject.java 123456789public class RealSubject extends Subject&#123; @Override public void rent() &#123; System.out.println("from realSubject"); &#125; &#125; ProxySubject中介12345678910111213141516171819202122232425public class ProxySubject extends Subject&#123; private RealSubject realSubject; @Override public void rent() &#123; this.preRequest(); if(null==realSubject) &#123; realSubject=new RealSubject(); &#125; realSubject.rent();//真正租房 this.afterRequest(); &#125; public void preRequest() &#123; System.out.println("pre Request"); &#125; public void afterRequest() &#123; System.out.println("After Request"); &#125;&#125; main1234567public class Client &#123; public static void main(String[] args) &#123; Subject subject = new ProxySubject(); subject.rent(); &#125;&#125; 静态代理：result123pre Requestfrom realSubjectAfter Request ==================================================Subject12345//抽象角色public interface Subject &#123; public void request(); &#125; RealSubject 12345678//真实角色public class RealSubject implements Subject&#123; @Override public void request() &#123; System.out.println("from RealSubject"); &#125;&#125; DynamicProxy 1234567891011121314151617181920import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class DynamicProxy implements InvocationHandler&#123; private Object obj; public DynamicProxy(Object obj) &#123; this.obj=obj; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("pre request"); Object object = method.invoke(obj, args); System.out.println("after request"); return object; &#125; &#125; main 1234567891011121314151617181920212223242526272829import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.util.ArrayList;import java.util.List;public class Client &#123; public static void main(String []args) &#123; // RealSubject realSubject = new RealSubject(); List&lt;String&gt; arrayList=new ArrayList&lt;&gt;(); InvocationHandler ih = new DynamicProxy(arrayList);//代表了动态代理要执行的那个方法realSubject List&lt;String&gt; list= (List&lt;String&gt;)Proxy.newProxyInstance(ih.getClass().getClassLoader(), arrayList.getClass().getInterfaces(), ih); System.out.println(list.getClass().getName()); list.add("helloworld"); // System.out.println(list.size()); // 动态代理方法的加载，动态代理方法里的实现接口（不知道），谁实现的 // System.out.println(subject.getClass().getName()); // subject.request(); &#125; &#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MapReduce]]></title>
    <url>%2F%2F2019%2F06%2F13%2F2019-06-13%2F</url>
    <content type="text"><![CDATA[MapReduce的基本原理Hadoop作为一个分布式架构的实现方案，它的核心思想包括以下几个方面：HDFS文件系统，MapReduce的编程模型以及RPC框架。无论是怎样的架构，一个系统的关键无非是存储结构和业务逻辑。HDFS分布式文件系统是整个Hadoop的基础。在HDFS文件系统之中，大文件被分割成很多的数据块，每一块都有可能分布在集群的不同节点中。也就是说在HDFS文件系统中，文件的情况是这样的： 文件保存在不同的节点上，而Hadoop是用于海量数据处理的，那么如何把分布在各个节点的数据进行高效的并发处理呢？Hadoop对此提供了不同的解决方案，比如yarn框架等。框架已经帮我们写好了很多的诸如任务分配，节点通信之类的事情。而我们要做的就是写好自己的业务逻辑，那么我们就要遵守Hadoop的编程规范，而这个编程规范就是MapReduce。那么MapReduce的运行过程是怎么样的呢？且看下图： 1.从HDFS文件系统中读取文件，每一个数据块对应一个MapTask。2.进行Map任务，逐行读取文件，每一行调用一次Map函数，数据被封装为一个键值对也就是图中的&lt;k2,v2&gt;。3.将Map后的键值对进行归约，key值相同的value会被封装到一起。就行了图中的&lt;k,{v1,v2,v3}&gt;4.归约后的键值对会被送到不同的Reduce中，执行Reduce任务，输出&lt;k3,v3&gt;到输出文件中。弄懂了MapReduce的执行过程之后，我们就可以编写自己的逻辑来进行处理了。 MD5暴力破解的基本思路还是先上图：1.编程生成所有的密码明文文件。2.将明文上传至HDFS文件系统中，在Map函数中实现MD5的求值。然后直接存入文件系统中中。 数据查询有了上一步生成的数据，我们就可以做数据的查询了。生成的文件仍然是在HDFS文件系统中，通过终端输入参数（可以是明文或者是密文），然后用MapReduce进行查找，结果输出到文件中。 导出JAR包放到Hadoop中运行把文件导出成JAR包，在终端使用命令12345生成密文：bin/hadoop jar [jar包路径] [输入文件路径] [输出路径]查询bin/hadoop jar [jar包路径] [输入文件路径] [输出路径] [密文或者明文]生成的密文结果实例： 部分代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import java.security.MessageDigest; import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.input.TextInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;/** * 目地很简单。不需要reduce处理，直接在Map中解决问题 * @author hadoop * */public class Test &#123; private static String s=null; //定义Map处理类 static class TestMapper extends Mapper&lt;LongWritable, Text, Text, Text&gt;&#123; //重写map方法 public void map(LongWritable key, Text value, Context context)throws InterruptedException &#123; try&#123; //查询MD5的值 int index=value.find(s); if(index&gt;=0)&#123; System.out.println("=================="+value.toString()); context.write(new Text("result"), value); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;/** * MD5计算 * @param str * @return */public static String getMD5(String str) &#123; try &#123; // 生成一个MD5加密计算摘要 MessageDigest md = MessageDigest.getInstance("MD5"); // 计算md5函数 md.update(str.getBytes()); // digest()最后确定返回md5 hash值，返回值为8为字符串。因为md5 hash值是16位的hex值，实际上就是8位的字符 // BigInteger函数则将8位的字符串转换成16位hex值，用字符串来表示；得到字符串形式的hash值 byte[] encrypt = md.digest(); StringBuilder sb = new StringBuilder(); for (byte t : encrypt) &#123; String s = Integer.toHexString(t &amp; 0xFF); if (s.length() == 1) &#123; s = "0" + s; &#125; sb.append(s); &#125; String res = sb.toString(); return res; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125; public static void main(String[] args) throws Exception &#123; //必须要传递的是自定的mapper和reducer的类，输入输出的路径必须指定，输出的类型&lt;k3,v3&gt;必须指定 //将自定义的MyMapper和MyReducer组装在一起 //参数（明文或者MD5值） s=args[2]; Configuration conf=new Configuration(); String jobName=Test.class.getSimpleName(); //首先写job，知道需要conf和jobname在去创建即可 Job job = Job.getInstance(conf, jobName); //如果要打包运行改程序，则需要调用如下行 job.setJarByClass(Test.class); //读取HDFS內容：设置输入路径 FileInputFormat.setInputPaths(job, new Path(args[0])); //指定解析&lt;k1,v1&gt;的类（谁来解析键值对） //*指定解析的类可以省略不写，因为设置解析类默认的就是TextInputFormat.class job.setInputFormatClass(TextInputFormat.class); //指定自定义mapper类 job.setMapperClass(TestMapper.class); //指定map输出的key2的类型和value2的类型 &lt;k2,v2&gt; //下面两步可以省略，当&lt;k3,v3&gt;和&lt;k2,v2&gt;类型一致的时候,&lt;k2,v2&gt;类型可以不指定 job.setMapOutputKeyClass(Text.class); job.setMapOutputValueClass(Text.class); //分区(默认1个)，排序，分组，规约 采用 默认// job.setCombinerClass(null); //接下来采用reduce步骤 //指定自定义的reduce类// job.setReducerClass(null); //指定输出的&lt;k3,v3&gt;类型 job.setOutputKeyClass(Text.class); job.setOutputValueClass(Text.class); //指定输出&lt;K3,V3&gt;的类 //下面这一步可以省// job.setOutputFormatClass(TextOutputFormat.class); //指定输出路径 FileOutputFormat.setOutputPath(job, new Path(args[1])); //写的mapreduce程序要交给resource manager运行 job.waitForCompletion(true);&#125; &#125; 结果加密 解密之后]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringIOC 、DI]]></title>
    <url>%2F%2F2019%2F06%2F10%2F2019-06-10%2F</url>
    <content type="text"><![CDATA[今天是个难忘的日子。Spring1.1)IOC（Inverse of control） DI（dependency injection） 控制翻转 依赖注入2) AOP(Aspect oriented programming) 切面编程OOP Object oriented programming面向对象编程 12345B b =factory.get(&quot;b&quot;); 通过工厂主动生成，直接拿conn.setAutoCommit(false);//beginTransactionaddupdateconn.commit()//commit 1)涉及到的设计模式—-简单工厂模式 ：什么是工厂模式？ （1）工厂角色:生成产品，具体的产品 （2）抽象产品角色： 抽象类接口 （3）具体产品角色： （4）Spring的时候 new 关键字消失了 12345678910111213141516传统的,需要哪个 我需要NEW一个对象/*Person america = new American(); america.sayHello(); Person chinese = new Chinese(); chinese.sayHello();*/ ==============================Spring 工厂模式，创建一个个对象，Person与Chinese进行解耦 如果是美国人，对应US 不需要进行new Person person=PersonFactory.getPerson("CN"); person.sayHello(); 当我们使用Spring框架的时候，Spring会有一个与之对应的工厂角色的配置文件，默认的名字为 applicationContext.xml,SRC下 applicationContext.xml就是工厂，工厂中创建具体的对象，创建的对象bean id 创建对象的变量名字 class是这个变量的类型。 在配置文件中，不能使用Bean标签去定义抽象类接口。 基于配置文件从工厂当中获取BeanXmlBeanFactory xbf = new XmlBeanFactory(cpr);Japan japan =xbf.getBean(“japan”,Japan.class);1234567891011121314如果你的Chinese是无参的构造方法例如： private String name; public Chinese(String name) &#123; this.name=name; &#125;========================================Multiple annotations found at this line: - No constructor with 0 arguments defined in class 'com.neusoft.Chinese'IOC 控制翻转applicationContext.xml 控制权交给了第三方工厂 依赖注入1234567891011121314 XmlBeanFactory xbf =new XmlBeanFactory(new ClassPathResource("applicationContext.xml")); Printer printer = xbf.getBean("printer",Printer.class); printer.print();==============================================applicaitonContext.xml中 &lt;bean id="colorInk" class="com.neusoft.ColorInk"&gt;&lt;/bean&gt; &lt;bean id="blackInk" class="com.neusoft.BlackInk"&gt;&lt;/bean&gt; &lt;bean id="printer" class="com.neusoft.Printer"&gt; &lt;property name="ink" ref="colorInk"&gt;&lt;/property&gt; &lt;/bean&gt; 在Spring的依赖注入中 1)借助于Setter方法进行注入 建议使用set注入 –需要Printer无参的构造方法– 2)借助于构造方法 constrctor-arg 1）在Spring体系中，工厂创建Bean的Scope默认的是单例模式，也就是说这个bean在整个生命周期中只能生成一次2）Scope=”prototype” 访问一次生成一次。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Json]]></title>
    <url>%2F%2F2019%2F06%2F08%2F2019-06-08%2F</url>
    <content type="text"><![CDATA[JSON{username:’zhangsan’,password:123,age:12} 后端Servlet —前端JSP XML 解析 展示JSP Java .net系统 接口 XML与JSON跨平台 Person Integer id; String name; Date birthday; List&lt;Person&gt; persons; {id:1,name:”zhangsan”,birthday:2018-1-1,persons:[{id:2,name=”lisi”,birthday:2018-1-1},{id:2,name=”zhangsan”,birthday:2018-1-1}]} jsonviewzhangsan lisi wangwu zhaoliu [“zhangsan”,”lisi”,1,true,1.2,{id:2,name=”lisi”,birthday:2018-1-1},{id:2,name=”zhangsan”,birthday:2018-1-1}] /函数式编程documentById(“button按钮的Id”)data:给服务器传的参数 / 1234567891011121314151617&lt;script type="text/javascript"&gt; $( function()&#123; $("#button").click(function() &#123; $.ajax(&#123; type:"POST", url:"/gsonServlet", dataType:"html", success:function(returndata) &#123; alert(returndata); &#125; &#125;); &#125;); &#125;);&lt;/script&gt; 用到的jar 包gson-2.3.1.jar123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657以Gson为例package com.neusoft;import java.util.ArrayList;import java.util.List;import com.google.gson.Gson;import com.neusoft.Person;public class GsonTest &#123; public static void main(String[] args) &#123; // json 格式 String // 如何将person 对象转换为String Person person = new Person(); ((Person) person).setId(1); person.setUsername("zhangsan"); person.setPassword("123456"); person.setAge(18); List&lt;Person&gt; persons = new ArrayList&lt;&gt;(); persons.add(new Person("lisi", "123456", 12)); persons.add(new Person("wangwu", "123456", 13)); persons.add(new Person("zhaoliu", "123456", 14)); person.setPersons(persons); Gson gson = new Gson(); String str = gson.toJson(person); System.out.println(str); System.out.println("******************************"); // Person 转换JSON String字符串 /* * String str=gson.toJson(person); * * System.out.println(str); */ String str1 = "&#123;\"id\":1,\"username\":\"lisi\",\"password\":\"456456\",\"age\":18&#125;"; Person person1 = gson.fromJson(str1, Person.class); System.out.println(person1.getUsername()); System.out.println(person1.getPassword()); System.out.println(person1.getAge()); &#125;&#125; 输出为12345&#123;"id":1,"username":"zhangsan","password":"123456","age":18,"persons":[&#123;"username":"lisi","password":"123456","age":12&#125;,&#123;"username":"wangwu","password":"123456","age":13&#125;,&#123;"username":"zhaoliu","password":"123456","age":14&#125;]&#125;******************************lisi45645618]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ScalarHandler及BeanListHandler的区别。]]></title>
    <url>%2F%2F2019%2F06%2F07%2F2019-06-07%2F</url>
    <content type="text"><![CDATA[ScalarHandler及BeanListHandler的区别。${param.选项} 等价于 request.getParamter(“xx”); ${requestScope.xx} 等价于 request.getAttribute(“xx”); ResultSetHandler 的作用: QueryRunner 的 query 方法的返回值最终取决于 query 方法的 ResultHandler 参数的 hanlde 方法的返回值。 BeanListHandler: 把结果集转为一个 Bean 的 List, 并返回.。Bean的类型在创建 BeanListHanlder对象时以 Class对象的方式传入，可以适应列的别名来映射 JavaBean 的属性 名: String sql = “SELECT id, name customerName, email, birth “ + “FROM customers WHERE id = ?”; BeanListHandler(Class type)。 BeanHandler: 把结果集转为一个 Bean,并返回.。Bean的类型在创建BeanHandler 对象时以 Class 对象的方式传入 BeanHandler(Class type)。 MapHandler: 把结果集转为一个 Map 对象, 并返回。若结果集中有多条记录, 仅返回 第一条记录对应的Map对象.。Map的键: 列名(而非列的别名), 值: 列的值。 MapListHandler: 把结果集转为一个 Map 对象的集合, 并返回.。Map的键: 列名(而非列的别名), 值: 列的值。 ScalarHandler: 可以返回指定列的一个值或返回一个统计函数的值，比如count(1)。]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面分层]]></title>
    <url>%2F%2F2019%2F06%2F06%2F2019-06-06%2F</url>
    <content type="text"><![CDATA[分页的实现方式1)mysql limit 索引 查询的条数 规律:limit 索引=(当前页数-1) * 每页显示的数量 2)总的记录数 每页显示的数量 多少页 多少页=总的记录数%每页显示是数量==0？ 显示是 数量为：总的记录数%每页显示的数量+1 3)对于分页来说 &lt;ul&gt;当前的页数 &lt;ul&gt;每页显示的数量 &lt;ul&gt;总的记录数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152public class PageUtil &#123; private int currentPageNum;// 当前页 客户端点击的页 private int pageSize = 20; //每页的数量 private int totalSize;//数据库总的记录数 private int totalPageNum;//总的页数 private int startIndex; //开始页的索引 private int prePageNum; //上一页 private int nextPageNum; //下一页 private int startPageNum; //首页 private int endPageNum; //末页 private List records; public List getRecords() &#123; return records; &#125; public void setRecords(List records) &#123; this.records = records; &#125; public PageUtil(int currentPageNum,int totalrecords) &#123; this.currentPageNum=currentPageNum; this.totalSize=totalrecords; //每页的索引 this.startIndex=(currentPageNum-1)*pageSize; //总的页数 totalPageNum=totalrecords%pageSize==0?totalrecords/pageSize:totalrecords/pageSize+1; if(totalPageNum&gt;9) &#123; startPageNum=currentPageNum-4; endPageNum=currentPageNum+4; if(startPageNum&lt;1) &#123; startPageNum=1; endPageNum=startPageNum+8; &#125; if(endPageNum&gt;totalPageNum) &#123; endPageNum=totalPageNum; startPageNum=endPageNum-8; &#125; &#125; else &#123; startPageNum=1; endPageNum=totalPageNum; &#125; &#125; public int getCurrentPageNum() &#123; return currentPageNum; &#125; public void setCurrentPageNum(int currentPageNum) &#123; this.currentPageNum = currentPageNum; &#125; public int getPageSize() &#123; return pageSize; &#125; public void setPageSize(int pageSize) &#123; this.pageSize = pageSize; &#125; public int getTotalSize() &#123; return totalSize; &#125; public void setTotalSize(int totalSize) &#123; this.totalSize = totalSize; &#125; public int getTotalPageNum() &#123; return totalPageNum; &#125; public void setTotalPageNum(int totalPageNum) &#123; this.totalPageNum = totalPageNum; &#125; public int getStartIndex() &#123; return startIndex; &#125; public void setStartIndex(int startIndex) &#123; this.startIndex = startIndex; &#125; /** * 处理一些逻辑问题 * 首页，当前页-1=0，没有第0页 * @return */ public int getPrePageNum() &#123; prePageNum=currentPageNum-1; if(prePageNum&lt;=0) &#123; prePageNum=1; &#125; return prePageNum; &#125; public void setPrePageNum(int prePageNum) &#123; this.prePageNum = prePageNum; &#125; //处理尾页 public int getNextPageNum() &#123; nextPageNum=currentPageNum+1; if(prePageNum&gt;totalPageNum) &#123; prePageNum=totalPageNum; &#125; return nextPageNum; &#125; public void setNextPageNum(int nextPageNum) &#123; this.nextPageNum = nextPageNum; &#125; public int getStartPageNum() &#123; return startPageNum; &#125; public void setStartPageNum(int startPageNum) &#123; this.startPageNum = startPageNum; &#125; public int getEndPageNum() &#123; return endPageNum; &#125; public void setEndPageNum(int endPageNum) &#123; this.endPageNum = endPageNum; &#125; ${param.选项} 等价于 request.getParamter(“xx”); ${requestScope.xx} 等价于 request.getAttribute(“xx”);]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[upload文件上传]]></title>
    <url>%2F%2F2019%2F06%2F05%2F2019-06-05%2F</url>
    <content type="text"><![CDATA[JSP+Servlet中request getPart Part代表了当前上传的文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556571. JSP+Servlet中request getPart Part代表了当前上传的文件 使用@MultipartConfig注解 String header = part.getHeader("Content-Disposition");header：form-data; name="file2"; filename="实验四.docx" String fileName=header.substring(header.lastIndexOf("=")+2, header.length()-1); String uploadPath = req.getServletContext().getRealPath("/upload");//根目录下/upload路径 part.write(uploadPath+"/"+fileName);2. Fileupload 1)DiskFileItemFactory存储目录 2)FileItem:表单中的文件或者是普通的文本 3)ServletFileUpload: 就是解析请求的 //创建工厂 DiskFileItemFactory factory = new DiskFileItemFactory(); //根目录下的存储位置 path String path = req.getRealPath("/upload"); //工厂存储在path下 factory.setRepository(new File(path)); //解析文件上传 parserequest(HttpServletRequest request) ServletFileUpload upload = new ServletFileUpload(factory); /** *List&lt;FileItem&gt; item = (List&lt;FileItem&gt;)upload.parseRequest(req); *解析请求，List&lt;FileItem&gt;代表的就是表单中的一个文件或文本 *需要判断一下 *if是文本 *else里是文件 *转发给result结果页面。 * **/ try &#123; List&lt;FileItem&gt; item = (List&lt;FileItem&gt;)upload.parseRequest(req); for (FileItem fileItem : item) &#123; /*String name = fileItem.getName();*/ String name = fileItem.getFieldName(); if(fileItem.isFormField()) &#123; String value = fileItem.getString(); System.out.println("name="+name+" value="+value); req.setAttribute(name, value); &#125; else &#123; String fileName = fileItem.getName();//处理上传的文件 req.setAttribute(name,fileName); try &#123; fileItem.write(new File(path,fileName)); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block &#125; &#125; &#125; } catch (FileUploadException e) { e.printStackTrace(); }//list&lt;FileItem&gt;代表的就是表单中的一个文件或者文本 req.getRequestDispatcher(&quot;uploadResult.jsp&quot;).forward(req, resp);]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX简介2]]></title>
    <url>%2F%2F2019%2F06%2F04%2F2019-06-04%2F</url>
    <content type="text"><![CDATA[介绍 属性 https://github.com/zhangcv/AjaxProject/tree/master]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX简介]]></title>
    <url>%2F%2F2019%2F06%2F03%2F2019-06-03%2F</url>
    <content type="text"><![CDATA[传统Web应用请求Ajax请求 比较 关键技术]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android(二)]]></title>
    <url>%2F%2F2019%2F06%2F02%2F2019-06-02%2F</url>
    <content type="text"><![CDATA[drawable 里存放一些xml配置文件或者动画 mipmap 里面放一些图片 layout目录 存放的布局文件 values 存放数值文件 1234style可以继承，为了让layout_main.xml不显得繁琐在layout_main.xml 使用 style=@style/自定义命名的名字，可以引用 123456789101112131415顺序由0-&gt;1-&gt;2-&gt;3-&gt;4步骤一 ：编译，具体Gradle是个啥，我也不清楚，我只知道Android是用Gradle进行编译的，编译的过程它会 一、检查Gradle自身程序是否可用或版本是否最新 二、启动各种我们桌面上看不见的程序，如果我没猜错的话，Gradle和Java、Python都差不多，大概就是一些java.exe、javac.exe之类的 三、匹配各种依赖项，存在的检查完整性，不存在的去指定网站下载步骤 二 ：解析注册XML，AndroidManifest.xml在Android中的作用和Windows中的注册表类似，每个Activity.java都需要去注册，而且里面有MAIN和LAUNCH设置，MAIN是：主要、入口的意思；LAUNCH是：启动、加载的意思。也就是说，AndroidManifest.xml是个导游，告诉AndroidStudio从哪开始运行，都有什么大致内容。步骤 三：运行Activity，所谓Activity 翻译为 ：活动、界面 一个Activity就是一个运行界面，AndroidStudio会启动在AndroidManifest.xml中被设置为 MAIN和LAUNCH 的Activity。首页启动之后，就是各个Activity之间的跳转通信了。步骤 四：解析布局XML，在每个Activity创建（onCreate）时都会加载自己的xml布局文件，这些xml布局文件定义了对应Activity长什么样子。步骤 无： 解析完布局XML后，每个Activity的模样就确定了，然后就会返回Activity中执行类似响应点击、滑动之类的操作的代码]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android(一) 登录界面的实现]]></title>
    <url>%2F%2F2019%2F06%2F01%2F2019-06-01%2F</url>
    <content type="text"><![CDATA[主要 版本号 LoginActivity MainActivity 需要在Manifest.xml声明 这个activity(第二个) 12我是安装的android虚拟机，点击运行后，再点击 绿色的RUN就可以运行了]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop单例和伪分布式(环境搭建)]]></title>
    <url>%2F%2F2019%2F05%2F31%2F2019-05-31%2F</url>
    <content type="text"><![CDATA[一、准备1234561.1创建hadoop用户$ sudo useradd -m hadoop -s /bin/bash #创建hadoop用户，并使用/bin/bash作为shell$ sudo passwd hadoop #为hadoop用户设置密码，之后需要连续输入两次密码$ sudo adduser hadoop sudo #为hadoop用户增加管理员权限$ su - hadoop #切换当前用户为用户hadoop$ sudo apt-get update #更新hadoop用户的apt,方便后面的安装 1234561.2安装SSH,设置SSH无密码登陆$ sudo apt-get install openssh-server #安装SSH server$ ssh localhost #登陆SSH，第一次登陆输入yes$ exit #退出登录的ssh localhost$ cd ~/.ssh/ #如果没法进入该目录，执行一次ssh localhost$ ssh-keygen -t rsa 输入完 $ ssh-keygen -t rsa 语句以后，需要连续敲击三次回车，如下图： 其中，第一次回车是让KEY存于默认位置，以方便后续的命令输入。第二次和第三次是确定passphrase，相关性不大。两次回车输入完毕以后，如果出现类似于下图所示的输出，即成功： 之后再输入：12$ cat ./id_rsa.pub &gt;&gt; ./authorized_keys #加入授权$ ssh localhost #此时已不需密码即可登录localhost，并可见下图。如果失败则可以搜索SSH免密码登录来寻求答案 将master生成的id_rsa.pub公钥传给 slave1和slave2两个节点之后，加入授权。在ssh之前，先设置下/etc/hosts 里的添加12310.22.18.163 master10.22.18.164 slave110.22.18.165 slave2 在master的终端中 ssh 10.18.22.164输入 yes就会成功。二、安装JDK8 首先在oracle官网下载jdk1.8 http://www.oracle.com/technetwork/java/javase/downloads/index.html 接下来进行安装与环境变量配置，根据个人电脑系统选择对应版本，我选的是jdk-8u11-linux-x64.tar.gz 123456$ mkdir /usr/lib/jvm #创建jvm文件夹$ sudo tar zxvf jdk-8u11-linux-x64.tar.gz -C /usr/lib #/ 解压到/usr/lib/jvm目录下$ cd /usr/lib/jvm #进入该目录$ mv jdk-8u11-linux-x64.tar.gz java #重命名为java$ vi ~/.bashrc #给JDK配置环境变量注：其中如果权限不够，无法在相关目录下创建jvm文件夹，那么可以使用 $ sudo -i 语句进入root账户来创建文件夹。 另外推荐使用vim来编辑环境变量，即最后一句使用指令1$ vim ~/.bashrc 如果没有vim,可以使用：1$sudo apt-get install vim 来进行下载。最下面添加1234# jdk8export JAVA_HOME=/usr/java/jdk1.8.0_11export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$JAVA_HOME/bin:$PATH source ~/.bashrc之后三、安装hadoop-2.6.0先下载hadoop-2.6.0.tar.gz，链接如下:http://mirrors.hust.edu.cn/apache/hadoop/common/ 下面进行安装：1234$ sudo tar -zxvf hadoop-2.6.0.tar.gz -C /usr/local #解压到/usr/local目录下$ cd /usr/local$ sudo mv hadoop-2.6.0 hadoop #重命名为hadoop$ sudo chown -R hadoop ./hadoop #修改文件权限 给hadoop配置环境变量，将下面代码添加到.bashrc文件:123456# hadoopexport HADOOP_HOME=/usr/local/hadoopexport HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoopexport YARN_CONF_DIR=$HADOOP_HOME/etc/hadoopexport PATH=$PATH:$HADOOP_HOME/binexport PATH=$PATH:$HADOOP_HOME/sbin 同样，执行source ~./bashrc使设置生效，并查看hadoop是否安装成功四、伪分布式配置Hadoop 可以在单节点上以伪分布式的方式运行，Hadoop 进程以分离的 Java 进程来运行，节点既作为 NameNode 也作为 DataNode，同时，读取的是 HDFS 中的文件。Hadoop 的配置文件位于 /usr/local/hadoop/etc/hadoop/ 中，伪分布式需要修改2个配置文件 core-site.xml 和 hdfs-site.xml 。Hadoop的配置文件是 xml 格式，每个配置以声明 property 的 name 和 value 的方式来实现。首先将jdk1.8的路径添（export JAVA_HOME=/usr/java/jdk1.8.0_11）加到hadoop-env.sh文件 进入/usr/local/hadoop/etc/hadoopsudo vim hadoop-env.sh 添加HADOOP_CON_DIR 接下来修改core-site.xml文件： 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt; &lt;description&gt;Abase for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 接下来修改配置文件 hdfs-site.xml 1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 未完]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC初探]]></title>
    <url>%2F%2F2019%2F05%2F30%2F2019-05-30%2F</url>
    <content type="text"><![CDATA[MVC MVC（设计模式） M (model) V (view) C (Controller) M : entity service dao V : JSP html freemarker C : Servlet 简介 Mvc结构图 模型层 视图层 Model1优缺点 Model2 优缺点 Model2模式 结构图]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[监听器]]></title>
    <url>%2F%2F2019%2F05%2F29%2F%E7%9B%91%E5%90%AC%E5%99%A8%2F</url>
    <content type="text"><![CDATA[2019-5-28今天下午又遇到了中文乱码问题， 在Servlet类中的doPost 方法中添加req.setCharacterEncoding(&quot;UTF-8&quot;);（1） Tomcat端更改URLEncoding=UTF-8 最终问题的解决是在 过滤器Filter类中的doFilter方法中让request.setCharacterEncoding(“UTF-8”);（2） 但仍然存在一个问题，filter对于敏感信息不过滤 we仍然输出。猜测应该是web.xml配置Filter还存在问题解决： 在result.jsp结果页面 原为${param.comment} 改为 （因为在servlet中 是req.setAttribute(“comment”,comment) 把字符串comment值 (后) 传给 comment的属性 (前) 所以JSP页面获取用EL表达式应该为） ${requestScope.comment} ======================================================= keySet遍历Hashmap的例子Iterator iterator= (Iterator) hashMap.keySet().iterator(); //获得keyset的iterator，进行遍历整个hashmap。 while(iterator.hasNext()) { Integer key=(Integer) iterator.next(); Integer val=(Integer)hashMap.get(key); System.out.println(key+”: “+val); entrySet对HashMap遍历的例子Iterator&lt;Entry&lt;Integer, Integer&gt;&gt; iterator=hashMap.entrySet().iterator(); while(iterator.hasNext()) { Entry entry= iterator.next(); System.out.println(entry.getKey()+&quot;: &quot;+entry.getValue()); } ==========================================================1.监听器:主要有三种类型,经停气他的初始化一定会比过滤器和Servlet的时机要早。 -接口 -ServletContext (与上下文有关的对象) -ServletContextListener -ServletContextAtrributeListener 在我们的观察者设计模式中，任务的监听器(对象)都会对应监听事件 -ServletContextListenerTest 方法contextDestroyed 方法contextInitialized （1）第一种方式 直接在ServletContextListenerTest类前 加@WebListenner （2）web.xml用标签 直接加载listener &lt;listener&gt; &lt;listener-class&gt;com.neusoft.listener.ServletContextListenerTest&lt;/listener-class&gt; &lt;/listener&gt; (2) 会话有关的监听器 ### HttpSessionListener HttpSessionListener HttpSessionAttributeListener (3) 请求域有关的监听器 网站访问人数可由此实现]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EL(一)]]></title>
    <url>%2F%2F2019%2F05%2F19%2FEL1%2F</url>
    <content type="text"><![CDATA[1.el表达式表达式语言 (Expression language) scriptLess(无脚本的Java),EL目的就是取消Jsp页面中使用脚本和表达式的。2.EL表达式来说JSP内置了对EL表达式语言的支持，设置这个支持isEllgnored=true，那么这个表达式会以字符串的形式进行输出，第二种\${}，el表达式以字符串的形式输出。 3.EL表达式 在数据的显示方法更加简单，简约，EL表达式通常情况下只用于数据的读取。4.当我们使用EL表达式的取值的时候，这个值必须在四大范围域中5.在EL表达式中， 我们可以写常量 变量 隐含的内置对象6.${testone} 通过EL引擎调用pageContext.findAttribute(String)方法从JSP四大作用域范围中寻找。7. 属性用[&quot;&quot;] ${user[username] } ${user.address[&quot;home&quot;] } /* List&lt;String&gt; list = Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;helloworld&quot;); pageContext.setAttribute(&quot;list&quot;, list); */ ${list[1] } /* Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;(); map.put(&quot;test1&quot;,&quot;test1&quot;); map.put(&quot;test2&quot;,&quot;test2&quot;); pageContext.setAttribute(&quot;map&quot;, map); */ ${map[&quot;test1&quot;] } ![无](EL1/6EL隐式对象未上传.jpg) ![无](EL1/7empty运算符.jpg) 8.对于EL表达式来说，我们取值的字符有. [] 、.在实际开发中最常用但是当我们获取List或者Map或者属性值有特殊字符的时候，我们使用[]的方式9.EL表达式会提供错误机制 1)当访问不存在的对象的时候，不管是对这个对象操作还是对不存在的属性操作，EL表达式都会输出字符串 2)而对于已经存在的对象来说，如果访问了该对象不存在的属性，那么他会报错javax.el.PropertyNotFoundException10. EL表达式的隐含对象(内置对象)JSP9大 EL11大5-23日记 empty运算符按如下规则计算其返回值：当操作数只想的对象为null时，表达式返回true；当操作数是空字符串时，返回true；当操作数是集合或数组时，如果操作数中没有任何元素，返回true；当操作数是java.util.Map对象中的一个关键字时，如果Map对象为空、Map对象没有指定的关键字或Map对象的关键字对应的值为空，表达式返回true。 在EL表达式中关系运行，逻辑运行等同样也是()优先 JSTL(javaServer page tag library) JSP标签库，简化JSP页面的开发 JSTL标签库通常情况下和EL表达式结合使用 对于JSTL提供了以下几种类型的标签核心标签： 通用标签 1)c:out JSP表达式 2)c:set 赋值 3)c:remove 4)c:catch 条件标签 c:if c:choose c:when c:otherwise &lt;c:choose&gt; 标签没有属性，他的标签体内容只能有：空白、一个或多个&lt;c:when&gt;、0或多个&lt;c:otherwise&gt; &lt;c:choose&gt; &lt;c:when test=&quot;${1==2}&quot;&gt;hello&lt;/c:when&gt; &lt;c:otherwise&gt;world&lt;/c:otherwise&gt; &lt;/c:choose&gt; otherwise必须在choose标签的内部 迭代标签： &lt;c:foreach&gt; &lt;c:forTokens&gt; &lt;c:forEach begin=&quot;1&quot; end=&quot;100&quot; step=&quot;1&quot; var=&quot;num&quot;&gt; &lt;c:set var=&quot;sum&quot; value=&quot;${sum+num}&quot;&gt;&lt;/c:set&gt; &lt;/c:forEach&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP(三)]]></title>
    <url>%2F%2F2019%2F05%2F15%2FJSP4%2F</url>
    <content type="text"><![CDATA[1.当我们使用exception对象的时候，必须标注当前引用了exception对象的页面为标识错误已二面，page指令中使用isErrorPage=true request response out session application page pageContext config（jsp config获取初始值 web.xml servlet-class jsp-file ） exception、 request的方法setAttribute和getAttribute方法一般都是成对出现的，setAttribute赋值，getAttribute取值(都要乡下类型转换，将属性值转换为真正的对象)，方法都是在服务器内部执行，客户端不知道有这样的方法。4.request的getParameter方法作用 获取客户端的通过表单或者URL请求参数所发送过来的参数值，是客户端和服务器端进行通信的媒介，服务器收到客户端发送过来的数据的时候，request.getParameter方法来获取客户端的值，request对象没有setParameter5.request对象内数据的存活周期就是request作用域范围。当一个客户端向服务器端发送请求，服务器端向客户端返回一个响应，那么该request对象就销毁了，第二次再发送请求，服务器会创建新的request对象，这个第二次的request和第一次的request是没有任何关系的。6.session对象内 数据的存活范围也就是session对象的存活范围（session就代表了浏览器，只要浏览器不关闭，session就一直存在），因此在同一个浏览器当中，无论向服务器发送多少个请求，Session对象只有一个。 application(应用对象 app) 存活范围最大的一个，只要服务不关闭，那么存放在application中的数据就一直存在，那么在服务器的运行过程中，application对象只有一个。 request Session application三个范围是递增的，请求 浏览器窗口 整个服务器的运行过程JavaBean &lt;% User user =new User(); user.setUsername(&quot;zhangsan&quot;); user.setPassword(&quot;123&quot;); %&gt;&lt;%=user.getUsername() %&gt;&lt;%=user.getPassword() %&gt; &lt;jsp:useBean id=”user” class=”com.neusoft.entity.User” &gt;&lt;/jsp:useBean&gt; &lt;jsp:setProperty property=”username” name=”user” value=”zhangsan”/&gt; &lt;jsp:getProperty property=”username” name=”user”/&gt;]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP(二)]]></title>
    <url>%2F%2F2019%2F05%2F14%2FJSP3%2F</url>
    <content type="text"><![CDATA[out对象JSPout内置对象 buffer=”8kb” autoFlush=”true” 缓冲区，autoflush =true时，缓存区满了就输出 autoFlush=”false” 借助于 out.flush(), 用out.close()清空了缓存区（会输出），再关闭 clear 内容输出 清空缓冲 Io流 clear 、clearBuffer 清空当前缓冲区数据 JSPwriter JSP/JSP1.2.jpg getQueryString()以Get方式请求时? 后面的这一部分的值 &lt;%=((HttpServletRequest)pageContext.getRequest()).getQueryString() %&gt; Session Session内置对象 application对象 JSP四种作用域 JSPpageContext 12345&lt;% pageContext.setAttribute("user", "zhangsan",4); /* application.setAttribute("user","zhangsan"); *///（等价）重定向之后&lt;%=application.getAttribute("user") %&gt;能接受到zhangsan 问题：？1. JSP和Servlet有哪些相同点和不同点？ JSP的本质就是Servlet，JSP经过Web服务器编译之后就变成了Servlet，因此他们的生命周期、运行机制完全是相同的。 Servlet和JSP最主要的不同点在于表现形式：Servlet是一个继承HttpServlet的Java类，而JSP则是在HTML页面中嵌入JSP脚本，嵌入之后组合成一个扩展名为.jsp的页面文件。 在实际项目开发当中，JSP侧重于视图，Servlet主要用于控制逻辑。 2. session和application的区别？ Session代表依次用户会话，allication则代表Web应用本身。具体来说，他们存在如下区别： 1)两者的作用范围不同：session是用户会话级别的，application是web应用级别的。因此 application是一个全局作用域。session则对应于一个用户的单词会话，单个用户在同义词会话内访问多个页面共享同一个session。而整个Web应用的所有用户。所有会话都共享同一个application，只要web应用没有重启，application内的数据一直有效。 2)生命周期不同。 session：用户首次访问网站时创建，用户注销、离开网站或者关闭浏览器消亡。 application：启动web服务器创建，关闭web服务器销毁。 3. Cookie和session的作用、区别、应用范围？ 1)cookie数据保存在客户的电脑上，session数据保存在服务器端。 2)cookie不是安全的，别人可以读取、甚至修改客户端电脑上得到cookie，甚至可进行cookie欺骗，因此cookie不适合保存安全性相关的数据，安全性要求较好的数据应使用session保存在服务器端。 3)session会在一定时间内保持在服务器上，但是会占用内存资源，当访问的用户过多，会加重服务器的负载，考虑到减轻服务器的压力，可以将不重复的数据放在cookie中持久的保存。 4)单个cookie保存的数据不能超过4k，很多浏览器都限制站点最多保存20个cookie]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP(一)]]></title>
    <url>%2F%2F2019%2F05%2F13%2FJSP2%2F</url>
    <content type="text"><![CDATA[继续上一篇的总结1) (4)因为Servlet是一个单实例多线程的类，所有当不同请求访问Servlet中全局变量 时候，当前线程对变量 修改会影响到其他线程，而对于局部变量来说，线程都会对局部变量有一份copy，互不影响。 ###总结: 以局部为重，不要用全局变量 (5)注释jsp 元素 &lt;%-- comment--%&gt; 2)当设计到单实例多线程的时候，一定处理好线程共享成员变量的问题3) 指令元素 向JSP容器提供编译信息 不向客户端产生任何输出，所有的指令都只在当前页面有效。 (1)page指令：page指令的目的是描述当前页面信息的，比如导入的类、当前页的字符编码、是否支持Session等，多个属性之间用空格隔开，在JSP的脚本元素中支持Java语言 (2)include 指令:将外部资源导入到当前页面中，file属性=’外部的资源’ JSP1.1 (3)taglib指令：导入第三方taglib cool &lt;%@ taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core&quot; %&gt; 报错 ，需要导入jar包 standard.jar 和 jstl.jar http://static.runoob.com/download/jakarta-taglibs-standard-1.1.2.tar.gz 里面的lib包里4) 动作元素 区别 (1)&lt;jsp:include&gt; 作用都是相同的,不同点:指令的include将外部的资源合并为一个新的Servlet类,&lt;jsp:include&gt;不会将导入的文件合并为一个类，而是在编译的时候动态的引用。 就是&lt;jsp:include&gt;能够传参数，根据参数的不同，合并不同的内容 动作的&lt;jsp:include&gt;与&lt;@include&gt; (2)&lt;jsp:forward&gt;就是进行页面的转发 &lt;jsp:forward&gt;的功能和Servlet的RequestDispatcher对象的forward方法类似，调用者和被调用者共享同一个request对象 &lt;jsp:forward&gt;指令用于转向页面，在该指令后面的所有代码都没有机会执行了，因为页面的流程已经转向了另外一个页面了 usebean=null?nothing：later ============================================================================ 内置对象简介 对于JSP内部我们使用ServletAPI，我们无法实例化，这时候JSP他提供了内置对象的使用。2. 对于JSP来说，有9大内置对象： JSP中九大内置对象为：request 请求对象 类型 javax.servlet.httpServletRequest 作用域 Requestresponse 响应对象 类型 javax.servlet.httpSrvletResponse 作用域 PagepageContext 页面上下文对象 类型 javax.servlet.jsp.PageContext 作用域 Pagesession 会话对象 类型 javax.servlet.http.HttpSession 作用域 Sessionapplication 应用程序对象 类型 javax.servlet.ServletContext 作用域 Applicationout 输出对象 类型 javax.servlet.jsp.JspWriter 作用域 Pageconfig 配置对象 类型 javax.servlet.ServletConfig 作用域 Pagepage 页面对象 类型 javax.lang.Object 作用域 Pageexception 例外对象 类型 javax.lang.Throwable 作用域 pagerequest response session application用的最多 JSP内置对象是指在JSP页面中，不用声明就可以在脚本和表达式中直接使用的对象4.JSP内置对象有如下 ###特点: 内置对象由Web容器自动载入，不需要实例化； 内置对象通过Web容器来实现和管理； 在所有的JSP页面中，直接调用内置对象都是合法的5. 在JSP内置对象中，out的内置对象的类是JSPWriter而不是printWriter，他们都是向客户端输出字符。 PageContext：也是JSP的内置对象，他的主要的任务掌管整个JSP页面的，换句话 可以使用17. ```Page内置对象在实际应用中不常见，代表this关键字]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSP初探]]></title>
    <url>%2F%2F2019%2F05%2F12%2FJSP1%2F</url>
    <content type="text"><![CDATA[JSP本质上就是Servlet (JavaServer pages),JSP就是传统的HTML文件，嵌套了Java程序片段和JSP标签的页面 JSP就是嵌套了Java代码的HTML，Servlet就是嵌套了HTML标签的Java代码 JSP的运行时服务器端的，JSP有两部分构成 1)模板html元素，在服务器端不会被解析 2)脚本元素Java代码 JSP本质的目的就是简化Servlet对于页面的编写 Servlet的简化设计，逻辑与界面设计的分开，开发更加方便,HTML语法的Java扩张，加入新的标签.&lt;% %&gt; 对于 Servlet容器来说，他解析JSP的时候，对于模板文件他会原封不动的输出，对于Java语句需要解析，将结果返回给客户端。 客户端收到的就是HTML文档 脚本元素允许用户将小段的代码(一般情况是Java代码)添加到JSP页面中，例如，可以加入一个if语句，以根据具体情况传送不同的HTML代码。脚本元素在页面被请求时执行。JSP脚本元素包括： 脚本 表达式 声明和注释 对于JSP文件来说包含了三部分： 1)脚本元素(script) (1)小脚本 Java代码&lt;%任何复合Java语法的代码 %&gt; (2)表达式&lt;%= %&gt;类似于System.out.println()，当我打印变量的时候不能使用; (3)声明&lt;%! 方法 变量 %&gt;：通过声明脚本声明的变量是Servlet是一个全局变量(成员变量)，脚本声明的变量是局部变量。 (4)因为Servlet是一个单实例多线程的类，所有当不同请求访问Servlet中全局变量 时候，当前线程对变量 修改会影响到其他线程，而对于局部变量来说，线程都会对局部变量有一份copy，互不影响。###总结: 以局部为重，不要用全局变量 (5)注释jsp 元素 &lt;%-- comment--%&gt; 2)当设计到单实例多线程的时候，一定处理好线程共享成员变量的问题 3) ###指令元素 向JSP容器提供编译信息 不向客户端产生任何输出，所有的指令都只在当前页面有效。(1)page指令：page指令的目的是描述当前页面信息的，比如导入的类、当前页的字符编码、是否支持Session等，多个属性之间用空格隔开，在JSP的脚本元素中支持Java语言 (2)include 指令:将外部资源导入到当前页面中，file属性=&apos;外部的资源&apos; JSP1.1 (3)taglib指令：导入第三方taglib cool &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 报错 ，需要导入jar包 standard.jar 和 jstl.jar http://static.runoob.com/download/jakarta-taglibs-standard-1.1.2.tar.gz 里面的lib包里 4) ###动作元素(1)&lt;jsp:include&gt; 作用都是相同的,不同点:指令的include将外部的资源合并为一个新的Servlet类,&lt;jsp:include&gt;不会将导入的文件合并为一个类，而是在编译的时候动态的引用。 就是&lt;jsp:include&gt;能够传参数，根据参数的不同，合并不同的内容 动作的&lt;jsp:include&gt;与&lt;@include&gt; (2)&lt;jsp:forward&gt;就是进行页面的转发 &lt;jsp:forward&gt;的功能和Servlet的RequestDispatcher对象的forward方法类似，调用者和被调用者共享同一个request对象 &lt;jsp:forward&gt;指令用于转向页面，在该指令后面的所有代码都没有机会执行了，因为页面的流程已经转向了另外一个页面了 usebean=null?nothing：later]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet（四）]]></title>
    <url>%2F%2F2019%2F05%2F11%2FServlet3%2F</url>
    <content type="text"><![CDATA[Cookie12345678Name：一个cookie的名字Value：一个cookie的值Domain：可以访问该cookie的域名。非顶级域名，如二级域名或者三级域名，设置的cookie的domain只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的cookie，否则cookie无法生成；顶级域名只能设置domain为顶级域名，不能设置为二级域名或者三级域名，否则cookie无法生成；二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie。所以要想cookie在多个二级域名中共享，需要设置domain为顶级域名，这样就可以在所有二级域名里面或者到这个cookie的值了；顶级域名只能获取到domain设置为顶级域名的cookie，其他domain设置为二级域名的无法获取Path：可以访问此cookie的页面路径Expires/Max-Age：该cookie的超时时间。若设置为一个具体的时间，那么当到达此时间后，此cookie失效；不设置的话默认值是Session，当前会话结束后该cookie失效（PS：比如关闭浏览器）Size：该cookie的大小HTTP：cookie的httponly属性。若此属性为true，那么在客户端则不能通过脚本（PS：比如JavaScript）来读取该cookie值Secure：若此属性为true，cookie 只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，如果是 HTTP 连接则不会传递该cookie 会话跟踪 Cookie技术会话跟踪技术就是维持服务器和Http协议状态的一种技术。Cookie是指某些网站为了辨别用户身份而储存在用户终端上得到文本信息(通常经过加密)Cookie在用户第一次访问服务器时，由服务器通过响应头的方式发送给哭护短浏览器；当用户再次向服务器发送请求是会附带上这些文本信息。 Cookie是服务器发送给客户端，Cookie是客户端维持会话跟踪技术与Cookie相关的请求报文信息Servlet3.2ServletCookie的作用]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet（三）]]></title>
    <url>%2F%2F2019%2F05%2F10%2FServlet2%2F</url>
    <content type="text"><![CDATA[ServletConfigconfig.getInitParameter(&quot;username&quot;); 获取配置的值 ServletContext也称为Servlet上下文，代表当前Servlet运行 环境(Tomacat)，是Servlet于Servlet容器之间直接通信的接口。 获取服务器文件资源 HttpServletRequest接口 解决GET请求中文乱码/*第一种解决中文乱码 req.setCharacterEncoding(&quot;utf-8&quot;); resp.setCharacterEncoding(&quot;utf-8&quot;); */ /* String str= req.getParameter(&quot;username&quot;); //第二种 str=new String(str.getBytes(),&quot;utf-8&quot;); //第三种Tomcat URIEncoding=&quot;UTF-8&quot; */ 获取网络连接的信息 HTTP协议响应报文 构建响应消息头 输出中文 Http协议 HTTP协议的构成 请求行 请求头 请求正文 Get： 没有正文 Post：请求正文的 Request对象中的getparameter getAttribute之间的区别 parameter：前端的数据 哭护短的 Attribute：服务器端的数据 在JSP、Servlet中当我们使用转发的时候，后面的代码就不会执行]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet（二）]]></title>
    <url>%2F%2F2019%2F05%2F09%2FServlet1%2F</url>
    <content type="text"><![CDATA[Servlet声明配置容器创建的org.apache.catalina.connector.RequestFacade@28b7d2b1org.apache.catalina.connector.ResponseFacade@267029d7Servlet声明配置 1.项目配置文件web.xml1234567891011121314151617181920212223242526272829303132333435 &lt;!-- Servlet声明配置 web.xml &lt;servlet&gt; &lt;description&gt;test&lt;/description&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.neusoft.servlet.LoginServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:test&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:test&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:test&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/LoginServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; --&gt;``` ![处理请求数据](Servlet1/Servlet1.4处理请求数据.jpg) 2. ```bash @WebServlet声明一个类为Servlet //@WebServlet(name="LoginServlet",urlPatterns=&#123;"/loginServlet","/aa"&#125;, initParams=&#123;@WebInitParam(name="jdbc",value="jdbc:test")&#125;,loadOnStartup=2) 3. 123@WebServlet会在程序部署时被Servlet容器处理，容器根据具体的属性配置把响应的类部署为Servlet @WebServlet("/loginServlet") 20. 注解优先当我们即在xml中配置了Servlet，同时也声明了注解，那么注解优先 21.当我们在浏览器输入网址的形式进行服务器的访问时，他的请求方式Get请求连接的方式 Servlet里面的username和password请求LoginServlet 22. 处理请求数据总结1234567891011121314Client-&gt;server 数据提交的Get Post 1)Get会将请求的参数以URL附件的方式并且默认就是明文，安全性会低 最大的值255个字节 2)Post会以报文 的方式，将请求的参数提交到服务器端，不会以地址栏 附件的方式提交，增加了安全性，并且理论上是没有提交参数大小的限制。 String password = req.getParameter("password"); //获取一个值 String[] hobby = req.getParameterValues("hobby");//获取多个值 到一个集合enctype="application/x-www-form-urlencoded"字符串形式进行提交enctype="multipart/form-data"以流的形式进行提交 Servlet来说进行组件的条状就是借助于重定向和转发的是否在服务器内部完成。 重定向 重定向（response） A01页面显示不了 借助A02页面显示 请求转发 转发(request) A01解决不了，问了A02然后告诉A01404客户端问题 关于重定向和转发的相对路径和绝对路径问题1)重定向的时候 resp.sendRedirect location 如果/表示的绝对路径，针对于Tomcat容器，当我们使用重定向资源的时候，我们可以重定向到当前应用，也可以重定向到其他应用。2)转发getRequestDispatcher(“/userDispacher”).forward(req, resp);/ 相对的，是在服务器内部转发]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet（一）]]></title>
    <url>%2F%2F2019%2F05%2F08%2FServlet%2F</url>
    <content type="text"><![CDATA[六个接口和 两个类 13.定义 A servlet is a small Java program that runs within a Web server. Servlets receive and respond to requests from Web clients, usually across HTTP, the HyperText Transfer Protocol. 14.###Servlet 来说他有两个实现类 javax.servlet.GenericServlet 通用的 TCP UDP HTTP请求 javax.servlet.http.HttpServlet. HTTP请求15. ServletRequestDefines an object to provide client request information to a servlet. The servlet container creates a ServletRequest object and passes it as an argument to the servlet’s service method. Servlet中的接口和类的实现或者对象，都不是我们自己new出来的，都是Tomcat或者服务器创建的。 ServletRequest&lt;—依赖Servlet依赖——————–&gt; ServletResponse ^ 实现 ^ ^ (类)GenericServlet 继承-&gt; ServletConfig ^ ^继承 ^继承 ^继承HttpServletRequest &lt;-依赖(类)HttpServlet依赖-&gt; HttpServletResponse17. ###GenericServlet 处理通用的协议独立的Servlet请求18. HttpServlet专门处理Http请求的Servlet方法： doPost doGet19.Servlet有生命周期1) ###实例和创建加载----Tomcat容器加载和创建 2)（1） ### 初始化-------init() Servlet被初始化，因为Servlet是但实例的。 （2）在资源部署描述符中添加 标签的时候，被初始化 （3）重新装入Servlet的时候，服务器重新启动，修改Servlet类 重载 意义：多态 用户的多种选择3)Service()方法处理用户的请求和响应HttpServletRequest HttpServletResponse]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java200个面试题目]]></title>
    <url>%2F%2F2019%2F05%2F07%2FJAVA200%E4%B8%AA%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[一、Java 基础1.JDK 和 JRE 有什么区别？ == 和 equals 的区别是什么？ 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？ final 在 java 中有什么作用？ java 中的 Math.round(-1.5) 等于多少？ String 属于基础的数据类型吗？ java 中操作字符串都有哪些类？它们之间有什么区别？ String str=”i”与 String str=new String(“i”)一样吗？ 如何将字符串反转？ String 类的常用方法都有那些？ 抽象类必须要有抽象方法吗？ 普通类和抽象类有哪些区别？ 抽象类能使用 final 修饰吗？ 接口和抽象类有什么区别？ java 中 IO 流分为几种？ BIO、NIO、AIO 有什么区别？ Files的常用方法都有哪些？ 二、容器 java 容器都有哪些？ Collection 和 Collections 有什么区别？ List、Set、Map 之间的区别是什么？ HashMap 和 Hashtable 有什么区别？ 如何决定使用 HashMap 还是 TreeMap？ 说一下 HashMap 的实现原理？ 说一下 HashSet 的实现原理？ ArrayList 和 LinkedList 的区别是什么？ 如何实现数组和 List 之间的转换？ ArrayList 和 Vector 的区别是什么？ Array 和 ArrayList 有何区别？ 在 Queue 中 poll()和 remove()有什么区别？ 哪些集合类是线程安全的？ 迭代器 Iterator 是什么？ Iterator 怎么使用？有什么特点？ Iterator 和 ListIterator 有什么区别？ 怎么确保一个集合不能被修改？ 三、多线程 并行和并发有什么区别？ 线程和进程的区别？ 守护线程是什么？ 创建线程有哪几种方式？ 说一下 runnable 和 callable 有什么区别？ 线程有哪些状态？ sleep() 和 wait() 有什么区别？ notify()和 notifyAll()有什么区别？ 线程的 run()和 start()有什么区别？44.创建线程池有哪几种方式？45.线程池都有哪些状态？ 线程池中 submit()和 execute()方法有什么区别？ 在 java 程序中怎么保证多线程的运行安全？ 多线程锁的升级原理是什么？ 什么是死锁？ 怎么防止死锁？ ThreadLocal 是什么？有哪些使用场景？ 说一下 synchronized 底层实现原理？ synchronized 和 volatile 的区别是什么？ synchronized 和 Lock 有什么区别？ synchronized 和 ReentrantLock 区别是什么？ 说一下 atomic 的原理？ 四、反射 什么是反射？ 什么是 java 序列化？什么情况下需要序列化？ 动态代理是什么？有哪些应用？ 怎么实现动态代理？ 五、对象拷贝 为什么要使用克隆？ 如何实现对象克隆？ 深拷贝和浅拷贝区别是什么？ 六、Java Web jsp 和 servlet 有什么区别？ jsp 有哪些内置对象？作用分别是什么？ 说一下 jsp 的 4 种作用域？ session 和 cookie 有什么区别？ 说一下 session 的工作原理？ 如果客户端禁止 cookie 能实现 session 还能用吗？ spring mvc 和 struts 的区别是什么？ 如何避免 sql 注入？ 什么是 XSS 攻击，如何避免？ 什么是 CSRF 攻击，如何避免？ 七、异常 throw 和 throws 的区别？ final、finally、finalize 有什么区别？ try-catch-finally 中哪个部分可以省略？ try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？ 常见的异常类有哪些？ 八、网络 http 响应码 301 和 302 代表的是什么？有什么区别？ forward 和 redirect 的区别？ 简述 tcp 和 udp的区别？ tcp 为什么要三次握手，两次不行吗？为什么？ 说一下 tcp 粘包是怎么产生的？ OSI 的七层模型都有哪些？ get 和 post 请求有哪些区别？ 如何实现跨域？ 说一下 JSONP 实现原理？ 九、设计模式 说一下你熟悉的设计模式？ 简单工厂和抽象工厂有什么区别？ 十、Spring/Spring MVC 为什么要使用 spring？ 解释一下什么是 aop？ 解释一下什么是 ioc？ spring 有哪些主要模块？ spring 常用的注入方式有哪些？ spring 中的 bean 是线程安全的吗？ spring 支持几种 bean 的作用域？ spring 自动装配 bean 有哪些方式？ spring 事务实现方式有哪些？ 说一下 spring 的事务隔离？ 说一下 spring mvc 运行流程？ spring mvc 有哪些组件？ @RequestMapping 的作用是什么？ @Autowired 的作用是什么？ 十一、Spring Boot/Spring Cloud 什么是 spring boot？ 为什么要用 spring boot？ spring boot 核心配置文件是什么？ spring boot 配置文件有哪几种类型？它们有什么区别？ spring boot 有哪些方式可以实现热部署？ jpa 和 hibernate 有什么区别？ 什么是 spring cloud？ spring cloud 断路器的作用是什么？ spring cloud 的核心组件有哪些？ 十二、Hibernate 为什么要使用 hibernate？ 什么是 ORM 框架？ hibernate 中如何在控制台查看打印的 sql 语句？ hibernate 有几种查询方式？ hibernate 实体类可以被定义为 final 吗？ 在 hibernate 中使用 Integer 和 int 做映射有什么区别？ hibernate 是如何工作的？ get()和 load()的区别？ 说一下 hibernate 的缓存机制？ hibernate 对象有哪些状态？ 在 hibernate 中 getCurrentSession 和 openSession 的区别是什么？ hibernate 实体类必须要有无参构造函数吗？为什么？ 十三、Mybatis mybatis 中 #{}和 ${}的区别是什么？ mybatis 有几种分页方式？ RowBounds 是一次性查询全部结果吗？为什么？ mybatis 逻辑分页和物理分页的区别是什么？ mybatis 是否支持延迟加载？延迟加载的原理是什么？ 说一下 mybatis 的一级缓存和二级缓存？ mybatis 和 hibernate 的区别有哪些？ mybatis 有哪些执行器（Executor）？ mybatis 分页插件的实现原理是什么？ mybatis 如何编写一个自定义插件？ 十四、RabbitMQ rabbitmq 的使用场景有哪些？ rabbitmq 有哪些重要的角色？ rabbitmq 有哪些重要的组件？ rabbitmq 中 vhost 的作用是什么？ rabbitmq 的消息是怎么发送的？ rabbitmq 怎么保证消息的稳定性？141.rabbitmq 怎么避免消息丢失？ 要保证消息持久化成功的条件有哪些？ rabbitmq 持久化有什么缺点？ rabbitmq 有几种广播类型？ rabbitmq 怎么实现延迟消息队列？ rabbitmq 集群有什么用？ rabbitmq 节点的类型有哪些？ rabbitmq 集群搭建需要注意哪些问题？ rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？ rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？ rabbitmq 对集群节点停止顺序有要求吗？ 十五、Kafka kafka 可以脱离 zookeeper 单独使用吗？为什么？ kafka 有几种数据保留的策略？ kafka 同时设置了 7 天和 10G 清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？ 什么情况会导致 kafka 运行变慢？ 使用 kafka 集群需要注意什么？ 十六、Zookeeper zookeeper 是什么？ zookeeper 都有哪些功能？ zookeeper 有几种部署模式？ zookeeper 怎么保证主从节点的状态同步？ 集群中为什么要有主节点？ 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？ 说一下 zookeeper 的通知机制？ 十七、MySql 数据库的三范式是什么？ 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了一条数据，此时 id 是几？ 如何获取当前数据库版本？ 说一下 ACID 是什么？ char 和 varchar 的区别是什么？ float 和 double 的区别是什么？ mysql 的内连接、左连接、右连接有什么区别？ mysql 索引是怎么实现的？ 怎么验证 mysql 的索引是否满足需求？ 说一下数据库的事务隔离？ 说一下 mysql 常用的引擎？ 说一下 mysql 的行锁和表锁？ 说一下乐观锁和悲观锁？ mysql 问题排查都有哪些手段？ 如何做 mysql 的性能优化？ 十八、Redis redis 是什么？都有哪些使用场景？ redis 有哪些功能？ redis 和 memecache 有什么区别？ redis 为什么是单线程的？ 什么是缓存穿透？怎么解决？ redis 支持的数据类型有哪些？ redis 支持的 java 客户端都有哪些？ jedis 和 redisson 有哪些区别？ 怎么保证缓存和数据库数据的一致性？ redis 持久化有几种方式？189.redis 怎么实现分布式锁？ redis 分布式锁有什么缺陷？ redis 如何做内存优化？ redis 淘汰策略有哪些？ redis 常见的性能问题有哪些？该如何解决？ 十九、JVM 说一下 jvm 的主要组成部分？及其作用？ 说一下 jvm 运行时数据区？ 说一下堆栈的区别？ 队列和栈是什么？有什么区别？ 什么是双亲委派模型？ 说一下类加载的执行过程？ 怎么判断对象是否可以被回收？ java 中都有哪些引用类型？ 说一下 jvm 有哪些垃圾回收算法？ 说一下 jvm 有哪些垃圾回收器？ 详细介绍一下 CMS 垃圾回收器？ 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？ 简述分代垃圾回收器是怎么工作的？ 说一下 jvm 调优的工具？ 常用的 jvm 调优的参数都有哪些？]]></content>
      <categories>
        <category>Java面试</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 队列-完全平方数]]></title>
    <url>%2F%2F2019%2F04%2F28%2FLeetCode%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%2F</url>
    <content type="text"><![CDATA[（昨天溜去看IMAX复联4了(:з」∠)） 描述给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例 1:输入: n = 12输出: 3解释: 12 = 4 + 4 + 4. 示例 2:输入: n = 13输出: 2解释: 13 = 4 + 9. 生成一个sqaures记下level，其实代表是进入的层数记下每一个remain的值，放进queue中，弹出queue的值进行，判断如果之前出现的remain，不需要再次加入到queue中重复计算，使用marked的布尔数组 代码 12345678910111213141516171819202122232425262728293031323334353637383940public int numSquares(int n) &#123; List&lt;Integer&gt; squares = generateSquares(n); Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); boolean[] marked = new boolean[n + 1]; queue.offer(n); marked[n] = true; int level = 0; while (!queue.isEmpty()) &#123; int size = queue.size(); level++; while (size-- &gt; 0) &#123; int cur = queue.poll(); for (int square : squares) &#123; int remain = cur - square; if (remain &lt; 0) &#123; break; &#125; if (remain == 0) &#123; return level; &#125; if (marked[remain]) &#123; continue; &#125; marked[remain] = true; queue.add(remain); &#125; &#125; &#125; return -1; &#125; private List&lt;Integer&gt; generateSquares(int n) &#123; List&lt;Integer&gt; squares = new ArrayList&lt;&gt;(); int base = (int) Math.sqrt(n); for (int i = 1; i &lt;= base; i++) &#123; squares.add((int) Math.pow(i, 2)); &#125; return squares; &#125; 补充队列的常用操作q.empty() 判断队列是否为空，空返回ture，否则返回false。q.size() 返回队列元素个数。q.pop() 删除队首元素，但不返回值。q.front() 返回队头元素，但不删除该元素。q.back() 返回队尾元素，但不删除该元素。q.push() 在队尾压入一个新元素。q.offer() 将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则返回 false，不会抛异常3、定义优先队列Priority_queue&lt;类型名&gt;变量名4、队列的常用操作q.empty() 判断队列是否为空，空返回ture，否则返回false。q.size() 返回队列元素个数。q.pop() 删除队首元素，但不返回值。q.top() 返回具有最高优先级的元素的值，但不删除该元素。q.push() 在基于优先级的适当位置插入新元素。 动态数组 1、定义动态数组Vector&lt;类型名&gt;变量名2、动态数组的操作A[i] 返回动态数组中的第i个元素。a.empty() 判断动态数组是否为空，若为空返回true，否则返回false。a.size 返回动态数组中元素的个数。a.resize() 修改动态数组大小。a.push_back() 向动态数组尾部插入一个元素。a.pop_back() 删除动态数组尾部的一个元素。a.begin() 返回指向vector头部的迭代器（指针）。a.end() 返回指向vector尾部元素的后一个元素的迭代器（指针）。 集合 set是STL中一种标准关联容器（vector,list,string,deque都是序列容器，而set，multiset，map，multimap是标准关联容器），它底层使用平衡的搜索树——红黑树实现，插入删除操作时仅仅需要指针操作节点即可完成，不涉及到内存移动和拷贝，所以效率比较高。set，顾名思义是“集合”的意思，在set中元素都是唯一的，而且默认情况下会对元素自动进行升序排列，支持集合的交(set_intersection),差(set_difference) 并(set_union)，对称差(set_symmetric_difference) 等一些集合上的操作，如果需要集合中的元素允许重复那么可以使用multiset集合的常用运算：sets,t,st;setiterator it;s.begin() 返回set容器的第一个元素s.end() 返回set容器的最后一个元素s.clear() 删除set容器中的所有的元素s.empty() 判断set容器是否为空s.max_size() 返回set容器可能包含的元素最大个数s.size() 返回当前set容器中的元素个数s.insert(x) 集合的插入s.find(x) 查找元素是否存在(s.find(x)==s.end()不存在)s.count(x) 查找元素是否存在，存在true,否则返回false。遍历集合可以看到集合是有序的]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 队列-岛屿的个数]]></title>
    <url>%2F%2F2019%2F04%2F26%2FLeetCode%20%E5%B2%9B%E5%B1%BF%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[描述给定一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。解法 示例 1:输入:11110110101100000000 输出: 1 示例 2:输入:11000110000010000011 输出: 3 代码 12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int numIslands(char[][] grid) &#123; int cnt=0; for(int i=0;i&lt;grid.length;i++) &#123; for(int j =0;j&lt;grid[i].length;j++) &#123; if(grid[i][j]=='1') &#123; depthSearch(grid,i,j); cnt++; &#125; &#125; &#125; return cnt; &#125; public void depthSearch(char[][] grid,int i,int j) &#123; if(grid==null||(i&lt;0||i&gt;=grid.length)||(j&lt;0||j&gt;=grid[i].length)) &#123; return; &#125; if(grid[i][j]!='1') &#123; return; &#125; grid[i][j]='0'; depthSearch(grid,i+1,j); depthSearch(grid,i-1,j); depthSearch(grid,i,j+1); depthSearch(grid,i,j-1); &#125;&#125; 问题：java.lang.IndexOutOfBoundsException 解决： 该异常通常是指数组下标越界异常。 例如：一个ArrayList数组中没有元素，而你想获取第一个元素,运行是就会报此类型的错误。 if(grid==null||(i&lt;0||i&gt;grid.length)||(j&lt;0||j&gt;grid[i].length)) 改为 if(grid==null||(i&lt;0||i&gt;=grid.length)||(j&lt;0||j&gt;=grid[i].length))]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomacat初识]]></title>
    <url>%2F%2F2019%2F04%2F25%2FTomcat%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[http://localhost:8080/Learning8-TomacatTest 动态网站：能与用户进行交互、并根据用户输入的信息产生相应响应的网站。动态网站一般由大量的动态网页、后台处理程序以及用于存储内容的数据库组成。 tomcat（java Serlet）（servlet容器）、Resin、jetty、webolgic（Oracle） webSphere（ibm）、Jboss（应用级服务器） 常见的JavaWeb服务器：Tomcat（Apache）：当前应用最广的JavaWeb服务器；JBoss（Redhat红帽）：支持JavaEE，应用比较广；GlassFish（Orcale）：Oracle开发JavaWeb服务器，应用不是很广；Resin（Caucho）：支持JavaEE，应用越来越广；Weblogic（Orcale）：要钱的！支持JavaEE，适合大型项目；Websphere（IBM）：要钱的！支持JavaEE，上适合大型项目； Tomcat8.0 支持Servlet 3.1 Tomacat配置环境变量1.JAVA_HOME:JDK路径 bin的上一层2.CATALINA_HOME:tomacat的解压路径bin目录的上一层 问题startup.bat会调用catalina.bat，而catalina.bat会调用setclasspath.bat，setclasspath.bat会使用JAVA_HOME环境变量，所以我们必须在启动Tomcat之前把JAVA_HOME配置正确。如果JAVA_HOME配置不正确，就会导致startup.bat一闪而过!（.bat为在windows环境下，.sh为在Linux环境下） 配置端口号打开Tomcat安装目录下的conf/server.xml 端口：web服务器在启动时，实际上是监听了本机上的一个端口，当有客户端向该端口发送请求时，web服务器就会处理请求。但是如果不是向其所监听的端口发送请求，web服务器不会做任何响应。例如：Tomcat启动监听了80端口，而访问的地址是http://localhost:8080，将不能正常访问。 80端口：80端口是http协议默认的端口号，也就是说如果在url中不指定端口号那默认会向80端口发送请求。 （一个端口是一个进程） Tomcat目录结构 bin 存放启动、停止服务器和其他脚本文件 conf 存放服务器的配置文件 lib 存放Tomcat服务器的jar包 logs 存放Tomcat服务器的日志文件 temp 存放Tomcat服务器的临时文件 webapps WEB应用的部署目录 work Tomcat工作目录 bin：该目录下存放的是二进制可执行文件，如果是安装版，那么这个目录下会有两个exe文件：tomcat6.exe、tomcat6w.exe，前者是在控制台下启动Tomcat，后者是弹出GUI窗口启动Tomcat；如果是解压版，那么会有startup.bat和shutdown.bat文件，startup.bat用来启动Tomcat，但需要先配置JAVA_HOME环境变量才能启动，shutdawn.bat用来停止Tomcat； conf：这是一个非常非常重要的目录，这个目录下有四个最为重要的文件： 1.server.xml：配置整个服务器信息。例如修改端口号，添加虚拟主机等；下面会详细介绍这个文件； 2.tomcatusers.xml：存储tomcat用户的文件，这里保存的是tomcat的用户名及密码，以及用户的角色信息。可以按着该文件中的注释信息添加tomcat用户，然后就可以在Tomcat主页中进入Tomcat Manager页面了； 3.web.xml：部署描述符文件，这个文件中注册了很多MIME类型，即文档类型。这些MIME类型是客户端与服务器之间说明文档类型的，如用户请求一个html网页，那么服务器还会告诉客户端浏览器响应的文档是text/html类型的，这就是一个MIME类型。客户端浏览器通过这个MIME类型就知道如何处理它了。当然是在浏览器中显示这个html文件了。但如果服务器响应的是一个exe文件，那么浏览器就不可能显示它，而是应该弹出下载窗口才对。MIME就是用来说明文档的内容是什么类型的！ 4.context.xml：对所有应用的统一配置，通常我们不会去配置它。 lib：Tomcat的类库，里面是一大堆jar文件。如果需要添加Tomcat依赖的jar文件，可以把它放到这个目录中，当然也可以把应用依赖的jar文件放到这个目录中，这个目录中的jar所有项目都可以共享之，但这样你的应用放到其他Tomcat下时就不能再共享这个目录下的jar包了，所以建议只把Tomcat需要的jar包放到这个目录下； logs：这个目录中都是日志文件，记录了Tomcat启动和关闭的信息，如果启动Tomcat时有错误，那么异常也会记录在日志文件中。 temp：存放Tomcat的临时文件，这个目录下的东西可以在停止Tomcat后删除！ webapps：存放web项目的目录，其中每个文件夹都是一个项目；如果这个目录下已经存在了目录，那么都是tomcat自带的。项目。其中ROOT是一个特殊的项目，在地址栏中没有给出项目目录时，对应的就是ROOT项目。http://localhost:8080/examples，进入示例项目。其中examples就是项目名，即文件夹的名字。 work：运行时生成的文件，最终运行的文件都在这里。通过webapps中的项目生成的！可以把这个目录下的内容删除，再次运行时会生再次生成work目录。当客户端用户访问一个JSP文件时，Tomcat会通过JSP生成Java文件，然后再编译Java文件生成class文件，生成的java和class文件都会存放到这个目录下。 LICENSE：许可证。 NOTICE：说明文件。 完整的Web应用还需要在WEB-INF目录下创建： classes； lib目录； webapps |- hello |-index.html |-WEB-INF |-web.xml |-classes |-lib hello：应用目录，hello就是应用的名称； index.html：应用资源。应用下可以有多个资源，例如css、js、html、jsp等，也可以把资源放到文件夹中，例如：hello\html\index.html，这时访问URL为：http://localhost:8080/hello/html/index.html； WEB-INF：这个目录名称必须是大写，这个目录下的东西是无法通过浏览器直接访问的，也就是说放到这里的东西是安全的； web.xml：应用程序的部署描述符文件，可以在该文件中对应用进行配置，例如配置应用的首页： index.html classes：存放class文件的目录；（二进制文件） lib：存放jar包的目录； 当我们使用Eclipse将项目部署到Tomcat的时，我们发现，在Tomcat下的webapps目录下并没有我们创建好的项目，但是当通过Eclipse启动服务器后，项目却真的可以访问到，这是为什么呢？ 实际上，Eclipse在使用Tomcat时，并没有将项目部署到Tomcat的目录下，而是在其工作空间中，创建了一个Tomcat的镜像，Eclipse启动的Tomcat是他自己配置的镜像。 Eclipse镜像所在目录 Java工作空间目录下的.metadata.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps wtpwebapps 各种部署的应用 部署第一个动态WEB时报错 HelloServlet /hello 1.删除tomcat服务器，再重新加载 2.在web.xml 配置文件 找 有没有相同的 例如（SendServlet ） 或者 没有用过的servlet， 全部删掉。 servlet-name的首字母大写]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode17 电话号码的字母组合]]></title>
    <url>%2F%2F2019%2F04%2F24%2FLeetCode17.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[描述给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 1 2abc 3def 4ghi 5jkl 6mno 7pqrs 8tuv 9wxyz *+ 0__ # 示例:输入：”23”输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; list =new ArrayList&lt;&gt;(); String[] s =new String[digits.length()]; int M=digits.length(); if(M==0) &#123; return list; &#125; for(int i =0;i&lt;M;i++) &#123; switch(digits.charAt(i)) &#123; case '2':s[i]="abc";break; case '3':s[i]="def";break; case '4':s[i]="ghi";break; case '5':s[i]="jkl";break; case '6':s[i]="mno";break; case '7':s[i]="pqrs";break; case '8':s[i]="tuv";break; case '9':s[i]="wxyz";break; &#125; &#125; list=getStringWithFor(s,0,list,""); return list; &#125; private static List&lt;String&gt; getStringWithFor(String []s,int i,List&lt;String&gt; list,String stemp) &#123; if(i&lt;s.length-1) &#123; for(int j=0;j&lt;s[i].length();j++) &#123; list=getStringWithFor(s,i+1,list,stemp+s[i].charAt(j)); &#125; i++; &#125;else&#123; for(int j =0;j&lt;s[i].length();j++) &#123; list.add(stemp+s[i].charAt(j)); &#125; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode16最接近的三数之和]]></title>
    <url>%2F%2F2019%2F04%2F24%2FLeetCode16%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[描述给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1. 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).双指针代码：1234567891011121314151617181920212223242526272829303132class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; Arrays.sort(nums); int closestNum = nums[0]+nums[1]+nums[2]; for(int i = 0;i&lt;nums.length-2;i++) &#123; int l=i+1,r = nums.length-1; while(l&lt;r) &#123; int threeSum = nums[l]+nums[r]+nums[i]; if(Math.abs(threeSum-target) &lt; Math.abs(closestNum-target)) &#123; closestNum=threeSum; &#125; if(threeSum&gt;target) &#123; r--; &#125; else if(threeSum&lt;target) &#123; l++; &#125; else&#123; //如果已经等于target，肯定是最接近的 return target; &#125; &#125; &#125; return closestNum; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode14最长公共前缀]]></title>
    <url>%2F%2F2019%2F04%2F23%2FLeetCode14%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%2F</url>
    <content type="text"><![CDATA[描述编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1:输入: [“flower”,”flow”,”flight”]输出: “fl” 示例 2:输入: [“dog”,”racecar”,”car”]输出: “”解释: 输入不存在公共前缀。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; //if(strs==null) return null; int N=strs.length; int maxlen=0; int maxflag=0; for(int i = 0; i&lt;N;i++) &#123; if(strs[i].length()&gt;maxlen) &#123; maxlen=strs[i].length(); maxflag=i; &#125; &#125; List&lt;Character&gt; list=new ArrayList&lt;&gt;(); for(int i = 0;i&lt;maxlen;i++) &#123; list.add(strs[maxflag].charAt(i)); &#125; int num=0; //第num个元素 int min =maxlen; //子字符串截取尾指针 for(int i =0;i&lt;strs.length;i++) &#123; String str = strs[i]; int n = str.length(); if(n==0) return ""; for(int j=0;j&lt;n;j++) &#123; if(str.charAt(j)==list.get(j)) &#123; if(j==n-1 &amp;&amp; n&lt; min) &#123; min = n; num=i; &#125; &#125;else &#123; if(j&gt;0 &amp;&amp; j&lt;min) &#123; min = j; num=i; break; &#125;else if(j == 0) return ""; &#125; &#125; &#125; //System.out.println(num); //System.out.println(min); if(strs.length==0) return ""; else&#123; String string = strs[num]; //return string.substring(0,min); return string.length()==0?"":string.substring(0,min); &#125; &#125;&#125; 方法二：暴力法 1234567891011121314151617181920212223class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if (strs.length == 1)&#123; return strs[0]; &#125; StringBuilder sb = new StringBuilder(); if (strs.length&gt;1) &#123; int len = strs[0].length(); for (int i = 0; i &lt; len; i++) &#123; char curr = strs[0].charAt(i); for (int j = 1; j &lt; strs.length; j++) &#123; if (strs[j].length()&lt;=i ||strs[j].charAt(i) != curr) &#123; return sb.toString(); &#125; if (strs[j].charAt(i) == curr &amp;&amp; j == strs.length - 1) &#123; sb.append(curr); &#125; &#125; &#125; &#125; return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode13罗马数字转整数]]></title>
    <url>%2F%2F2019%2F04%2F22%2FLeetCode13%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[描述：罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1:输入: “III”输出: 3 示例 2：输入: “IV”输出: 4 示例 3:输入: “IX”输出: 9 示例 4:输入: “LVIII”输出: 58解释: L = 50, V= 5, III = 3. 示例 5:输入: “MCMXCIV”输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 代码： 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public int romanToInt(String s) &#123; HashMap&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); map.put("I",1); map.put("IV",4); map.put("V",5); map.put("VI",6); map.put("IX",9); map.put("X",10); map.put("XL",40); map.put("L",50); map.put("XC",90); map.put("C",100); map.put("CD",400); map.put("D",500); map.put("CM",900); map.put("M",1000); int res=0; int i=0; int n =s.length(); while(i&lt;n) &#123; if(i&lt;n-1 &amp;&amp; map.containsKey(s.substring(i,i+2))) &#123; res +=map.get(s.substring(i,i+2)); i+=2; &#125; else if(map.containsKey(s.substring(i,i+1))) &#123; res +=map.get(s.substring(i,i+1)); i+=1; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode12整数转罗马数字]]></title>
    <url>%2F%2F2019%2F04%2F22%2FLeetCode12%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[描述罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1:输入: 3输出: “III” 示例 2:输入: 4输出: “IV” 示例 3:输入: 9输出: “IX” 示例 4:输入: 58输出: “LVIII”解释: L = 50, V = 5, III = 3. 示例 5:输入: 1994输出: “MCMXCIV”解释: M = 1000, CM = 900, XC = 90, IV = 4. 代码：1234567891011121314151617class Solution &#123; public String intToRoman(int num) &#123; int values[] = &#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; String reps[]=&#123;"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"&#125;; String res=""; for(int i = 0;i&lt;13;i++) &#123; while(num&gt;=values[i]) &#123; num -=values[i]; res+=reps[i]; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LEETCode9. 回文数]]></title>
    <url>%2F%2F2019%2F04%2F20%2FLeetCode09.%20%E5%9B%9E%E6%96%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[LEETCode9. 回文数 描述 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1:输入: 121 输出: true 示例 2:输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3:输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶:你能不将整数转为字符串来解决这个问题吗？ 代码 1234567891011121314151617181920class Solution &#123; public boolean isPalindrome(int x) &#123; if(x &lt; 0) return false; else&#123; int reverse = 0; int y =x; while(y!=0) &#123; reverse = reverse*10+ y %10; y/=10; &#125; if(reverse==x) &#123; return true; &#125; else return false; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode10. 正则表达式匹配]]></title>
    <url>%2F%2F2019%2F04%2F20%2FLeetCode10.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[LeetCode10. 正则表达式匹配 描述给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘*’ 的正则表达式匹配。 &apos;.&apos; 匹配任意单个字符。 &apos;*&apos; 匹配零个或多个前面的元素。 匹配应该覆盖整个字符串 (s) ，而不是部分字符串。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例 1:输入:s = “aa”p = “a”输出: false解释: “a” 无法匹配 “aa” 整个字符串。 示例 2:输入:s = “aa”p = “a“输出: true解释: ‘‘ 代表可匹配零个或多个前面的元素, 即可以匹配 ‘a’ 。因此, 重复 ‘a’ 一次, 字符串可变为 “aa”。 示例 3:输入:s = “ab”p = “.“输出: true解释: “.“ 表示可匹配零个或多个(‘*’)任意字符(‘.’)。 示例 4:输入:s = “aab”p = “cab”输出: true解释: ‘c’ 可以不被重复, ‘a’ 可以被重复一次。因此可以匹配字符串 “aab”。 示例 5:输入:s = “mississippi”p = “misisp*.”输出: false 代码 1234567891011121314151617181920class Solution &#123; public boolean isMatch(String s, String p) &#123; int m = s.length(),n = p.length(); boolean[][] result = new boolean[m+1][n+1]; result[0][0]=true; for(int i=0 ;i&lt;=m;i++) for(int j=1; j&lt;=n; j++)&#123; if(p.charAt(j-1)=='*')&#123; //这里i j 可以有三种情况转化而来。 1. s去掉*和*之前字母能够 匹配。也就是*之前字母取0次。2.*和*之前字母取一次,匹配s中第i个字母，（用递归 //所以从1次开始往后几次也是都可以）3.这种情况是&amp; 也就是 一定要匹配s中第i-1 。也是因为*之前字母可以//取0次，换句话说如果不能匹配i-1 那么一定不能匹配[i][j] result[i][j] = result[i][j-2]||((i&gt;0) &amp;&amp; (s.charAt(i-1)==p.charAt(j-2)|| p.charAt(j-2)=='.'))&amp;&amp;result[i-1][j]; &#125;else&#123;// 把. 当成普通字符一起匹配。这个就比较简单当前位置一样，或者是. 并且[i-1][j-1]也是要匹配 result[i][j] = i&gt;0 &amp;&amp; (s.charAt(i-1)==p.charAt(j-1)|| p.charAt(j-1)=='.') &amp;&amp; result[i-1][j-1]; &#125; &#125; return result[m][n]; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode11. 盛最多水的容器]]></title>
    <url>%2F%2F2019%2F04%2F20%2FLeetCode11.%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[描述给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 123456789101112class Solution &#123; public int maxArea(int[] height) &#123; int max = 0; for(int i=0,j=height.length-1;i&lt;j;) &#123; int minHeight= height[i]&lt;height[j]? height[i++]:height[j--]; max=Math.max(max,(j-i+1)*minHeight); &#125; return max; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode08. 字符串转换整数 (atoi)]]></title>
    <url>%2F%2F2019%2F04%2F19%2FLeetCode08.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%20(atoi)%2F</url>
    <content type="text"><![CDATA[LeetCode08. 字符串转换整数 (atoi)描述：请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明：假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，qing返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1:输入: “42”输出: 42 示例 2:输入: “ -42”输出: -42解释: 第一个非空白字符为 ‘-‘, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3:输入: “4193 with words”输出: 4193解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。 示例 4:输入: “words and 987”输出: 0解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5:输入: “-91283472332”输出: -2147483648解释: 数字 “-91283472332” 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 class Solution { public int myAtoi(String str) { str=str.trim(); if(str == null || str.length()==0)return 0; char first = str.charAt(0); if(first !=&apos;-&apos;&amp;&amp;first!=&apos;+&apos;&amp;&amp;(first&lt;&apos;0&apos;||first&gt;&apos;9&apos;))return 0; int num=1; if(first==&apos;-&apos;) { num=-1; } else if(first==&apos;+&apos;) { num=1; }else{ num=(int)(first-48); } int i=1; int fuh=num; if(first==&apos;-&apos;) { fuh=0; } else if(first==&apos;+&apos;) { fuh=0; } else{ fuh=num; } while(i&lt;str.length()) { if(str.charAt(i)&gt;=&apos;0&apos; &amp;&amp; str.charAt(i) &lt;=&apos;9&apos;) { if(fuh&gt;Integer.MAX_VALUE/10) { if(num&lt;0)return Integer.MIN_VALUE; else return Integer.MAX_VALUE; } if(fuh ==Integer.MAX_VALUE/10 &amp;&amp; num&gt;0 &amp;&amp;(int)(str.charAt(i)-48)&gt;Integer.MAX_VALUE %10) return Integer.MAX_VALUE; if(fuh ==Integer.MAX_VALUE/10 &amp;&amp; num&lt;0 &amp;&amp;(int)(str.charAt(i)-48) &gt;8) return Integer.MIN_VALUE; fuh=fuh*10 +((int)(str.charAt(i)-48)); i++; } else break; } return num&lt;0?num*fuh:fuh; } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA 异常]]></title>
    <url>%2F%2F2019%2F04%2F19%2FJava%E5%BC%82%E5%B8%B8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%BE%85%E8%A1%A5%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JAVA 异常JAVA 异常：就是程序在运行时出现不正常情况。&nbsp; &nbsp; 异常由来：问题也是现实生活中一个具体的事务，也可以通过java的类的形式进行描述，并封装成对象。 其实就是java对不正常情况就行描述后的对象的体现。 &nbsp; &nbsp; 对于问题的划分 严重问题：java通过 Error类进行描述对于Error一般不编写针对性的代码对其进行处理 非严重问题： Exception类进行描述针对性的代码对其进行处理 无论Error或者Exception都具有一些共性Throwable &nbsp; &nbsp; &nbsp; &nbsp; |–Error &nbsp; &nbsp; &nbsp; &nbsp; |–Exception OutofMemory 内存溢出。Errortry{ 需要被检测的代码} catch{ 处理异常的代码}finally{一定会执行的语句；} 3、对捕获到的异常对象进行常见方法操作String getMessage(); 异常信息 e.toString 异常名称 e.printStackTrace(); 异常名称 异常信息 异常出现的位置 默认的异常处理机制 在函数上声明异常。便于提高安全性， throws 多异常处理项目中出现特有的问题，未被java所描述并封装对象。将特有的问题。进行自定义的异常封装。 自定义异常自定义的异常在打印的时候 没有异常的信息。因为自定义的异常并未定义信息.如何定义异常信息呢？父类中已经把异常信息的操作都完成了所以子类在构造的时候，讲异常信息传递给父类通过super();语句那么就可以直接通过getMessage语句获取继承Exception原因；异常体系有一个特点：因为异常类和异常对象都被抛出。他们都具备可抛型。这个可抛型是Throwable这个体系中独有特点。 class FushuException extends Exception() { private int value; FushuException(String msg,int value) { super(msg); this.value = value ; } public int getValue() { return value; } } } class Throwable { private String msg; Throwable(Sttring msg) { this.msg=msg; } public String getMessage() { return msg; } } class Exception extends Throwable { Exception(String message) { super(message); } } 自定义异常定义 类继承Exception或者RuntimeExcertion 2,让该类具备操作异常的共性方法定义自定义异常的信息时,可以使用父类已经定义好的功能异常异常信息传递给父类的构造函数 class MYException extends Exception { MyException(String message) { super(message) } } 自定义异常按照java的面向对象思想,将程序中出现的特有问题进行封装异常的好处1,将问题进行封装2,将正常流程代码和问题处理代码相分高,方便于阅读 异常的处理原则1,处理方式有两种try或者throws2,调用到抛出异常的功能时,抛出几个,就处理几个。一个xy对应多个catch3,多个cat类的catch放到最下面4,catch内,需要定义针对性的处理方式。不要简单的定义printstackfrace,输出语句也不要不写. 当捕获到的异常，本功能处理布料是，可以继续在catch中抛出。 try { throws new AException } catch(AException e) { throw e; } 如果该异常处理不了，但比不属于该功能出现的异常。 可以将异常转换后，在抛出和该功能相关的异常。 或者异常可以处理，当需要将异常产生的和本功能相关的问题提供出去，当调用者知道，并处理。也可以将捕获异常处理后，转换新的异常。 try { throws new AException } catch(AException e) { //对AException处理 throw new BException(); } 比如汇款的例子。 异常的注意 1.子类抛出的异常必须是父类的异常的子类或者子集 2.如果父类或者接口没有异常抛出时,子类覆盖出现异常,只能try不不能抛。 final关键字1、修饰类 变量（成员变量，静态变量，局部变量），函数2、修饰的类不可以被继承。3、修饰的函数不可以被覆盖。4、修饰的变量是一个常量，只能赋值一次内部类只能访问局部当中的 fina修饰的变量 class Circle { private static double pi=3.14; private double radius; public Circle(double r) { radius =r; } public static double compare(Circle[] cir) { //补全代码，求数组中的最大值。 int max=0; for(int x =1;x&lt;cir.length;x++) { if(cir[x].radius&gt;cir[max].radius) max =x; } return cir[max].radius; } } class TC { public static void main(String[] args) { Circle cir[]=new Circle[3];//创建了一个类类型数组 System.out.println(&quot;最大的半径值是：&quot;+Circle.compare(cir)); } } 在一个类中编写一个方法,这个方法搜索一个字符数组中是否存在某个字符如果存在,则返回这个字符在字符数组中第一次出现的位置(序号从0开始计算否则,返回-1。要搜索的字符效组和字符都以参数形式传递传递给该方法,如果传入的数组为nu11,应抛出I11ega1ArgumentException异常在类的main方法中以各种可能出现的憤况测试验证该方法编写得是否正确例如,字符不存在,字符存在,传入的数组为mu11等无序数组 public int getIndex(Char[] arr,Char key) { if(arr==null) throw new IillegalArgumentException(); for(int x = 0;x&lt;arr.length;x++) { if(arr[x]==key) return x; } return -1; }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Web学习笔记html]]></title>
    <url>%2F%2F2019%2F04%2F17%2F%E7%AC%94%E8%AE%B0HTML%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[JavaWeb HTML123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536Web基本概念常用的Web术语互联网(Internet)万维网(wwy)超文本(HyperText) 超链接超媒体(HyperMedia)WEB服务器(WebServer)WEB客户端(Webclient)WEB浏览器(Webbrowser)超文本传输协议(HTTP)HyperText Transfer Protocol统一资源定位符(URL)统一资源标识符(UR)HTML(Hyper Text Markup Language)B/S（Browser Server） C/S （Client Server）B/S架构本质上就是C/S结构 理论上JAVA EE web开发 URL 统一资源定位符 Uniform Resource LocatorJavaWEB(request response)前端开发的IDE(Hbulider WebStrom Eclipse Dreamweaver Notepad++)html head body&lt;head&gt;表示网页中的设置项的，设置编码方式，搜素引擎等，head在网页中只有一个，必须作为Html标签的子标签&lt;body&gt; 设置网页中的内容，我们在“网页中”所看到的的内容放在body标签中&lt;title&gt;设置标题，优化搜素引擎的一种方式&lt;meta&gt;标签：head 设置网页的属性的name ="keywords"hx 表示网页中的标题hr 表示的是横线 size 表示高度 width 表示的宽度任何HTML标签都有 属性Key=value实体 &amp;开头&amp;实体的名字;==============================================================================空格 &amp;nbsp;大于&gt; &amp;gt;小于&lt; &amp;lt;引号" &amp;quot;版权符号@ &amp;copy;==============================================================================伪连接，唤醒某些本地应用&lt;a href="#marker"&gt;nihao&lt;/a&gt;&lt;a name = "marker"&gt;hello&lt;/a&gt;&lt;ul&gt;无序列表 unordered list type="disc" 默认实心圆 square circle&lt;/ul&gt;&lt;ol&gt;有序列表 ordered list 123 abc ABC&lt;/ol&gt;&lt;dl&gt; &lt;dt&gt;学校&lt;/dt&gt; &lt;dd&gt;专业&lt;/dt&gt; &lt;dt&gt;qingdao&lt;/dt&gt; &lt;dd&gt;jisuanji&lt;/dd&gt;&lt;/dl&gt;table &lt;tr&gt; div +css +盒子模式+float+列表盒子间距cellpadding="10px" cellspacing="10px"单元格填充（上下） （单元格间距） border 边框的厚度==============================================================================type类型 文本框 默认的值 maxlength最大长度username:&lt;input type="text" name="username" value="zhangsan" size="20" maxlength="10"/&gt;&lt;br&gt;==============================================================================post规定如何发送表单数据常用值：Get|Post action表示向何处发送表单数据&lt;form action="result.html" method="post"&gt; &lt;p&gt;username:&lt;input type="text" name="username"/&gt;&lt;br&gt;&lt;/p&gt; &lt;p&gt;password:&lt;input type="password" name="password"/&gt;&lt;br&gt;&lt;/p&gt; &lt;p&gt;age:&lt;input type="text" name="age"/&gt;&lt;/p&gt; &lt;input type="submit" name="Button" value="提交" /&gt; &lt;input type="reset" name="Reset" value="重填"&gt;&lt;/form&gt;==============================================================================复选框hobby:&lt;input type="checkbox" value="basketball" name="hobby"/&gt;篮球&lt;input type="checkbox" value="volleyball" name="hobby"&gt;排球&lt;input type="checkbox" value="football" name="hobby"/&gt;足球checked 默认值==============================================================================列表框address:&lt;select name="address"&gt; &lt;option value ="sd"&gt;山东&lt;/option&gt; &lt;option value ="sx1"&gt;陕西&lt;/option&gt; &lt;option value ="sx2"&gt;山西&lt;/option&gt; &lt;option value ="bj"&gt;北京&lt;/option&gt; &lt;option value ="sh"&gt;上海&lt;/option&gt;&lt;/select&gt;==============================================================================多行文本域 cols 列 rows 行comment:&lt;textarea name="showText" cols="x" rows="y"&gt;&lt;/textarea&gt;multipart/form-data流的方式application/x-www-form-urlencoded String 类型readonly ="true" 只读disabled="true" 禁用，当前文本框不会向服务器提交&lt;input type="hidden" value="1" /&gt; 隐藏域&lt;fieldset &gt; &lt;legend&gt;用户登录&lt;/legend&gt; &lt;input type="hidden" value="1" /&gt; username:&lt;input type="text" name="username" value="zhangsan" maxlength="10"/&gt;&lt;br&gt; password:&lt;input type="password" name="password"/&gt;&lt;br&gt; &lt;input type="submit" value="submit" /&gt; &lt;/fieldset&gt;?=id label 增强了用户实用 点击标签，焦点&lt;label for="?"&gt;&lt;input type="XX" id=?&gt;&lt;label for="username"&gt;username&lt;/label&gt;:&lt;input type="text" id="username" name="username" value="zhangsan" maxlength="10"/&gt;&lt;br&gt;==============================================================================CSS 层叠样式表框架：内联框架和框架集声明块：&#123;&#125; 一组组声明， key value 多个声明之间使用;结束，最后的一组声明可以不需要。外部样式CSS的声明 统一定义成一个文件 .css 结束的，外部样式表，真正的做到了结构和表现的分离，可以让多个页面共享同一个样式表，link标签进行导入&lt;link rel = "stylesheet" type="test/css" href ="css/common.css"&gt;==============================================================================### 对于CSS选择器1)标签选择器 2)Id选择器 #nav3)类选择器 .nav==============================================================================4CSS选择器优先级 行内样式表&gt;内部样式表&gt;外部样式表行内样式表（1000)&gt;ID(100)&gt;class(10)&gt;标签(1)==============================================================================5复合选择器1）并集选择器可以同时选中多个元素，为当前元素设置样式语法 选择器1,选择器2，选择器3&#123;&#125;2）交集选择器可以同时满足多个选择器的元素 语法 选择器1选择器2(第一个选择器必须是标签选择器，第二个为类或ID)3）子父关系（层次）选择（后代选择器 子选择器）后代选择器使用空格选择器1 空格 选择器2子选择器选择器1&gt;选择器2==============================================================================CSS中的选择器是由继承性的除了背景颜色之外color:字体颜色rgb()英文单词#ffffont-size 浏览器默认16pxfont-family font-stylefont：属性简化字体的设置，顺序 字体的大小 字体的类型放到最后，这两个属性的位置不能发生改变 &#123;color: red; /* font-size: 16px; font-family: "楷体"; font-style: inherit; font-weight: normal; */ font: bold italic 20px "楷体"; &#125;============================================================================= 伪类选择器（）用来表示元素的一种状态的选择器，比如元素的选中，选中划过等。标签名：伪类名&#123;属性;&#125;&#123; a:link&#123; color: green; &#125; a:visited&#123; color: red; &#125; a:hover&#123; color: darkturquoise; &#125; a:active&#123; color: lightcyan; &#125; &#125; 默认：1 浏览过的：2 放上去：3 点击：4div+css+盒子模式+浮动+定位=============================================================================盒子模式元素的分类：块级元素、行内元素（内联元素）、内联块级元素1）块级元素 div p hx ul dl table form2）内联元素 span a em label &lt;br&gt;3）内联块级元素 img input块级元素1）html独占一行 2）可以使用height和width设置宽和高内联元素1）他和其他的元素都在一行上 2）对于内联元素来说他的宽度和高度是不可以设置的，他的宽度和高度就是内容的宽度和高度内联块级元素 同时具备内联和块级元素的特点 1）他和其他的元素都在同一行上 2）他的高度和宽度都可以设置 margin(外边距)padding(内边距)height width 内容高度 宽度盒子边框 他能影响盒子的总长度 width color style盒子的内边距盒子的外边距：支持负值，当在外边距中发送垂直的外边距重合的时候，我们选中其中最大的值。在外边距中我们可以给水平方向设置auto值，会将外边距设置为最大值。=============================================================================overflow：auto 自动加一个滚动条 超过宽度 水平+||超过高度 垂直加hidden 子元素长度超过父元素长度 子元素隐藏scroll 无论超不超 水平垂直都加。默认overflow：auto=============================================================================浮动 float 目的：实现（块级元素）横向多列的网页布局浮动的例外： 浮动的元素永远不会覆盖文字。 对于一个内联元素来说一旦浮动了之后，就变成了块级元素。父元素包含子元素的时候，子元素一旦发送浮动，那么父元素的高度就会消失，避免？1）/* overflow: hidden; */默认开启一种规则， 父元素能包含浮动的子元素2）浮动的清除=============================================================================盒子之间的移动不借助外边距的方法(很麻烦)通过一个属性position1.定位：将html元素定位任意位置的2.定位 使用position### absolute生成绝对定位的元素，相对于static定位意外的第一个父元素进行定位。（1.设置一个元素是绝对定位，那么这个元素一定会脱离标准文档流）（2.当设置为相对定位的时候，他的Z轴会提升一个层次）(3.对于绝对定位来说，他如果没有定位的父元素进行包裹的，那么他默认的参照物是浏览器窗口)（4.绝对定位，如果我给一个内联元素进行了绝对定位，那么绝对定位会修改当前行内元素的性质，将他转换为块级元素）元素的位置通过 "left" "top" "right " "bottom" 属性进行规定。### relative生成相对定位的元素，相对于其正常位置进行定位。（他的参照物相对于自身，当设置为相对定位的时候，他的Z轴会提升一层）因此Left: 20px; 会向元素的Left位置添加20像素。### fixed生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 "left" "top" "right " "bottom" 属性进行规定。他也是一个绝对定位，他对内联元素的影响也是讲内联转换为块级元素### static（默认 没有定位，元素出现在正常的流中（忽略top，bottom，left，right或者 z-index声明））总结：1.绝对定位来说，他的参照物是已经定位好的父元素2.固定定位来说，他参照物永远都是浏览器窗口本身3.通常情况下，相对定位和绝对定位都是一起配合使用可以使用CSS的z-index属性设置属性的层级关系，值数值 值越大 层级越高当我们使用z-index属性设置层级的时候，前提是这个元素必须是定位的元素，在子父类系中层级是失效的。opacity 设置元素的透明度，0-1之间 0表示完全透明。0.5半透明=============================================================================JavaScript 基于对象的编程语言1、JS是门动态语言，静态语言2、JS是基于函数式编程3、没有类的概念4、 JS是一种弱类型的语言，强类型Java int a String bvar 表示所有类型[variable(变量)]var a=1;a=true;a="string"5、JS目的：进行网页的前端校验6、是一门解释性语言： 边解释边执行组成： ECMAScript DOM BOM 欧洲计算机 Document object module Browse obeject module7、对于JS的构成有DOM对象和BOM对象，BOM包含DOM对象事件驱动（单击按钮、键盘event） 页面驱动 Ajax&lt;script type="text/Javascript"&gt; &lt;!-- JavaScript语句--&gt;&lt;/script&gt;// 加入var之后 局部变量 否则全局变量(弱类型) function test()&#123; local="localVariable "; document.write(globel); document.write(local); &#125; document.write(globel); document.write(local);JavaScript来说， 定义在函数外的变量一定是全局变量，定义在函数内的变量，如果声明了var，那么是局部变量，不声明var则是全局变量基于面向对象，没有类的概念。============================================================================= 使用方式1)&lt;script&gt;标签 内部定义 &lt;/script&gt;2)在&lt;body&gt;里 javascript： 协议 &lt;a href="#" onclick="javascript:alert('点我干啥')"&gt;点我&lt;/a&gt;3)外部.js1.JS有五种基本数据类型 typeof 检测变量的返回值，变量类型的名字1)String2)Number3)Null4)Boolean5)Undefined2)JS中的NULL是undefined类型的一种演变 in other words Null=Undefined2.Object类型称为引用类型。3.在JS中对于字符串类型的数据" '4.在JS中我们有with关键字，with关键字为一段程序建立默认的对象document5.JS赋值的方式有三种 //第一种赋值方式,空间可写可不写 var fruit=new Array(3); fruit[0]="橘子"; fruit[1]="苹果"; fruit[2]="香蕉"; //下标越界 性能强 var fruit=new Array(); fruit2.push("橘子"); fruit2.push("2"); //第二种赋值方式 var fruit3=["橘子","苹果","草莓"]; //第三种赋值方式 var fruit4=new Array("juzi","pingguo","caomei"); function validateEmail(object) &#123; var valueForEmail=object.value; if(valueForEmail=="" || valueForEmail.lastIndexOf("@")==-1) &#123; alert("请输入正确的Email地址"); &#125; else &#123; alert("当前邮箱可用"); &#125; &#125;统计字符串的个数 统计包含a或A的个数/* var str="123"; //js 内置方式 var str = parseInt(str);//整型 str=parseFloat(str);//浮点型 isNaN(str); document.write(isNaN(str)+"&lt;br&gt;"); document.write(typeof str) */6.在JS中进行Boolean类型转换的时候， 非NULL就是true，非0就是true; 非""就是truevar a; falsevar a = new String(); truevar a=123; truevar a=""; truea=new Boolean(a);document.write(a);7.在JS中，遍历数组的函数式遍历方式 var array=new Array("橘子","苹果","草莓"); array.forEach(function(value,index,obj) &#123; document.write(value+index); /*1)value表示的是当前遍历的对象2)变量的索引3)变量的对象*/ &#125;);8.包装类 Boolean String Number JS有三个，java8个9.JS的对象的分类：1)内置对象 String Array Date Math Function Object Boolean2) DOM、BOM对象 浏览器来提供的对象Document history location3) 用户自定义对象Peson Student10.BOM(broswer object model)浏览器对象1)windows 窗体2)Document 3)history 放回上一页/下一页4)location 刷新、地址栏11.DOM（Document object model）文档对象模型 html整个结构常用方法getElementById() 返回对拥有指定id的第一个对象的引用 唯一id getElmentsByName() 返回带有指定名称的对象的集合 相同namegetElementsByTagName() 返回带有指定标签名的对象的集合 相同元素write() 向文档写文本、HTML表达式或JavaScript代码### 12.value属性只能作用于表单元素中 element.id element.value element.class但是只有一个是例外的： element.className13.？如何获取非表单元素中值呢 获取内容 获取所有里面HTML元素使用innerText和innerHTML获取非表单元素的值，那么他们之间的区别是？区别是 是否执行解析元素中HTML标签 全选 /全不选 function getAll() &#123; var allInputs=document.getElementsByName("book"); for(var i =0;i&lt;allInputs.length;i++) &#123; allInputs[i].checked=document.getElementById("all").checked; &#125; &#125;============================复杂 显示当前时间script： function time() &#123; var myDate=new Date(); var day=myDate.getDay(); if(day==0) &#123; day="日"; &#125; document.getElementById("time").innerHTML="当前时间："+myDate.getFullYear()+"年"+(myDate.getMonth()+1)+"月"+myDate.getDate()+"日"+"星期"+day+" "+myDate.getHours()+":"+myDate.getMinutes()+":"+myDate.getSeconds(); timeout(); &#125; var timeId; function timeout() &#123; timeId= setTimeout("time()",1000); &#125; window.onload=timeout();body： &lt;input type="button" value="stop" onclick="javascript:window.clearTimeout(timeId);"&gt;持续显示当前时间script： function time() &#123; var myDate=new Date(); var day=myDate.getDay(); if(day==0) &#123; day="日"; &#125; document.getElementById("time").innerHTML="当前时间："+myDate.getFullYear()+"年"+(myDate.getMonth()+1)+"月"+myDate.getDate()+"日"+"星期"+day+" "+myDate.getHours()+":"+myDate.getMinutes()+":"+myDate.getSeconds(); &#125; function timeinterval() &#123; timeId= setInterval("time()",1000); &#125; window.onload=timeinterval();body： &lt;div id="time"&gt;&lt;/div&gt; &lt;input type="button" value="stop" onclick="javascript:window.clearInterval(timeId)"&gt;Date对象的方法getDate() 返回1-31getDay() 返回0-6getHours() 返回0-23getMinutes() 返回0-59getSeconds() 返回0-59getMonth() 返回0-11getFullYear()getTime() 1970以来的毫秒数====================================================================Math对象 console.log(Math.PI); console.log(Math.abs(-1)); console.log(Math.round(3.4)); //0-n之间的数字 math.random()*n //0-n console.log(Math.random()*20); //m-n之间的数字 math.random()*(m-n)+m //1-10 console.log(Math.random()*9+1); console.log(Math.pow(2,-1/2));==================================================================RegExp对象1.正则表达式：定义字符串的规则的var regEx=new RegExp(参数1,参数2);//构造函数参数1:正则表达式参数2:匹配模式第一种方式var reg= new RegExp("a","i");第二种方式 var reg=/a/i2.正则表达式是根据各种符号来进行字符串的约束的3.[]表示的就是或者的意思/[a-z]/[A-Z]/[A-z]/[^A-z]/[0-9]4.正则表达式中符号的使用1) n+表示 至少一次2) n*表示0次或多次3) n？表示0或1次5.在HTML中节点就是元素 标签6.只能选择一个var div=document.querySelector(".title"); console.log(div.innerHTML);================================================]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>Java笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Se学习笔记]]></title>
    <url>%2F%2F2019%2F04%2F16%2F%E7%AC%94%E8%AE%B0JAVASe%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[ru:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856861、java的集合体系来说Collection是一个顶级接口,JDK并没有直接提供实现类来实现接而是间接的提供了Set和Lst接口进行实现2、List接口ArrayListLinkedList1)ArrayList有序的,重复的集合可以通过索引进行数据的访问,常用的APIgetaddremoveclearcontains…,如果遍历集合的长度使用sie()方法,数组中的Length属性区分。arraylist中有toArray方法,他的作用是将集合转换为数组的,(版本的不同7以下classCastException,7以上的版本进行自动的拆箱装箱)。2)ArrayList源码,ArrayList底层的实现是有数组实现的,当我们使用ArrayList默认的构造方法的时候,底层会生出一个长度为10的Object类型的数组,如果说长度超过10个,底层会生成新的数组,数组的长度(扩容)数组*15+1(针对JDK6JDK7是使用的自动扩容机制)。3)当我们直接打印Ls变量的时候,ust中每个元素的toString(方法,在我们的实际开发中,我们通常都会重写tostring方法,方便我们后续的调试4)ArrayList进行固定位置的添加和删除的时候,尽量不要用remove和add(@,@)方法,如果进行添加和删除,必须整体移动集合,代价是比较高的。5)LinkedListt时于LinkedList来说,也是Lt的实现类,我们建议使用ad第二个方法重载进行数据的添加6)Linkedlist源码Linlist底层是由链表实现的(双向链表),源码中的Node元素就是我们演示中的Element元素,7)集合转换为数组使用集合的toArray方法,数组转换为集合使用Arrays.asList(可变参数),可变参数可以使用数组赋值。8)ArrayList适合于读取数据,LinkedList适合于操作数据(添加删除等)9)使用LinkedList实现Stack的数据的存取10)ArrayList和LinkedList的比较List接口的实现类ArrayList与LinkedList的比较存储结构Arrayist是线性顺序存储LinkedList对象间彼此串连起来的一个链表操作性能ArrayList适合随机查询的场合LinkedList元素的插入和删除操作性高LinkedList要多一些3、当使用HashSet时hashcode(就会调用,hashset判断已经存储在集合中的对象的hashcode值是否与新添加的hashcode值一致,不一致,直接添加。如果一样,再进行equals方法的比较,如果equals方法返回true,说明对象存在了,就不会添加新的元素,否则添加进去。4、Treeset是一个遵循自然排序的集合,我们需要在声明TreeSet的时候必须定义一个规范而这个规范就是Computor接口的实现类5、set的遍历,我们使用Iterator进行遍历has Next next1)第一种使用Whle去遍历Iteratorhashnext判断是否有下一个值,ne对t方法进行值的读取2)for循环，进行Set元素的获取无重复 一两个对象e1和e2,如果e1.equals(e2)返回true,则认为e1和e2重复lesson21、Map(映射)K,V键值对的映射,在Map结构中Key是不允许重复的,Value是可以重复的,每一个键最多只能映射一个值2、HashMap中的key的集合可以使用set接口进行表示,Value的集合可以使用Collectionlist3、HashMap遍历的方式有两种1)思路通过map中keyset()方法获取所有的set集合,遍历set集合,通过map.get(key)获取到valueSet setKey = map.keySet();//所有的Key for (Iterator iter = setKey.iterator();iter.hasNext();) &#123; String key = (String)iter.next(); String value = (String) map.get(key); System.out.println(key+"="+value); &#125;2)、Map中的内部类Entry对象,Entry对象维护了HashMap中的kv键值对,也就是说Kv组成了一个Entry对象,所以我在遍历HashMap的时候,我们hashMap中的所有的Entry对象遍历出来,然后利用Entry对象的getKey getvalue方法获取到K v值Set set = map.entrySet();//entry 对象 for (Iterator iter = set.iterator(); iter.hasNext();)&#123; Map.Entry entry = (Map.Entry)iter.next(); String key = (String) entry.getKey(); String value = (String)entry.getValue(); System.out.println(key+"="+value); &#125;3)、HashMap和HashTable比较arraylist vector Map线程不安全性能高Table线程安全率低。HashMap与Hashtable的比较√Hashtable是基于陈旧的Dictionary类的,HashMap是Java1.2引进的Map接口的一个实现。√Hashtable是线程安全的,也就是说是同步的,而HashMap是线程序不安全的,不是同步的。√HashMap允许将null作为一个entry的key或者vaue,而Hashtable不允许。如何选择集合类Set内存放的元素不允许重复,List存放的元素有一定的顺序。√Map的应用主要在利用键/值对进行快速查询ArrayList和LinkedList的区别在于随机查询性能上ArrayList要好,但LinkedList的中间元素的插入与删除性能好。√HashSet和TreeSet的区别在于集合内元素是否排序。]4泛型就是变量类型的参数化,目标编译时候不报错,运行的时候一定不会报错泛型是实现通用框架的基础定义一个类的时候&lt;&gt;定义当前类的变量的类型 A T ,声明这个类的对象的时候,你传具体的变量的类型。5.补充:HashSet底层的实现是由 HashMap 实现的,当我们调用 HashSet 中的 add 方法时,本质上是往 HashMap 中的 Key 放入了我们添加的值,而 HashMap 中的 vue 永远常量值,Object6对于Java中常量的命名规范所有的单词都是大写的,如果有多个单词,那么每个单词之间使用下划线连接public static final String JAVA_CLASSS_TEST=100;Lesson31、JavaFile是独立于操作系统,\表示的目录结构 /目录结构linux文件路径分隔符为 / ，windows的文件路径分隔符为 \ file.separator=\2、Fil类的对象,表示了磁盘上的文件或者目录,当使用File进行创建文件的时候,创建文件的父目录必须存在3、递归方法自身调用自身,对于递归来说,一定要有出口,避免死循环4、使用Fle进行文件创建的时候createNewFilel)fle,dirmkdirs.5、对于Nio下的包中的Paths Files辅助类,进行文件和目录的创建的,paths目录 files文件 files move copy WatcherService 监控文件状态的类6、流是一种资源,Java程序通过流来完成输入和输岀。流向输入流和输岀流,参照物是程序。7、数据流指的是所有数据通信通道中数据的起点和终点。8、字符流是基于字节流的,Java中所有输入输出的基础都是字节流, 字节流inputstream outputstream 字符流reader writer.9、在流的层级结构中,只要是以Stream结尾的流成为字节流 Reader Writer 字符流10、字节流字节流用于向字节流读写8位二进制的字节,字节流,通用用于图像或者音频等二进制数据。11、字符流用于向字符流读写16位的二进制字符。12、节点流直接跟目标资源交互的流为节点流过滤流(包裝流、处理流) 包装节点流,为节点流添加功能。13、如何将缓冲区中的内容写入到目标资源中。1)bos.close()2)bos默认缓冲区满3)flush(强制的将缓冲区的资源输出到目标资源14、inputstream有三个read方法,当我们使用无参的read法的时候,他的返回值是独到的具体的那个字节数据Lesson4把字符串转化为字符数组char[] ch = new char[str.length()]; //字符str.getChars(0, str.length(), ch, 0);1字符流如何将字节流转换为字符流1)InputstreamReader 将输入字节流转换为输入字符流2)OutputstreamWriter 将输出的字符流转换为输出的字节流3)Filereader 以字符的方法进行文件的读取(输入)Fileinputstream4)Fillewriter 将字符写入到目标文件FileOutputStream2 ByteArrayInputstream CharArrayReader☆3 源码 :当我们使用inputstream方法的read方法读取字节的时候,Java并没有提供read方法的实现,而是交由底层操作系统来实现的。4、inputstream outputstream reader writer.字节Fileinputstream bytearrayInpustream处理流bufferedinputstrem datainputstream5.System.in out 在流系统中称为标准的输入和输出 键盘就是标准的输入 控制台就是标准的输出6.序列化：对象转换为字节保存起来，然后再以后还原这对象，这种机制就叫做对象的序列化。7.一个类的对象要想实现序列化必须实现Serializable接口8.流：ObjectInputStream ObjectOutputStream9.序列化的过程中，static类型的变量是无法序列化的，如果在序列化的过程中,A包含了对B的引用，那么B也会同A一并的序列化，如果B不允许序列化，那么这时A序列化的时候，就会发生异常，这时候必须将B类型的变量使用transient关键字进行标注。### OutputStreamWriter、PrintWriter和BufferedWriter区别================================================================================================================================================================ 1. PrintWriter无追加模式，若写入已有文件，将清空原文件，重新写入； 其println自动换行； OutputStreamWriter与BufferedWriter有追加模式，append设置为true时，在已有文件末尾追加；append=false时，从已有文件第一行开始覆盖写入，若写入内容比原有文件短，则只覆盖部分内容； BufferedWriter需手动换行，bw.newLine(); OutputStreamWriter和BufferedWriter的缺省buffer size,OutputStreamWriter是8k bytes，BufferedWriter是8k chars。 2. OutputStreamWriter，PrintWriter能控制编码，BufferedWriter不能。OutputStreamWriter底层使用的是StreamEncoder，也就是对charset进行了编 码，举个例子，你是完全可以本地采用比如gb2312的编码而写到一个utf-8文件里去的，这个时候你会用OutputStreamWriter。当然缺省的话是 使用本地的charset。即使使用缺省的charset，OutputStreamWriter是会把没法转码的字符转成malformed surrogate，而BufferedWriter是不会的; 3. BufferedWriter能控制封包大小，OutputStreamWriter，PrintWriter不能。假设你操作socket，采用buffer可以使得封包大小更合理； 4. BufferedWriter封装的是writer，也就是当buffer满了让别的writer去处理输出，而OutputStreamWriter封装的事数据流(OutputStream)，它是让数据流去处理输出。 stream和writer的不同不用说. 一个是二进制数据，一个是字符数据，这两个根本就不一样了。示例程序如下：************************************************************************************************************OutputStreamWriter osw=null; PrintWriter pw=null; BufferedWriter bw=null; try&#123; osw=new OutputStreamWriter(new FileOutputStream("D:/test/write1.txt",false),"GBK"); pw=new PrintWriter("D:/test/write1.txt","GBK"); bw=new BufferedWriter(new FileWriter("D:/test/write1.txt",false)); String str="9． 分别使用OutputStreamWriter、PrintWriter和BufferedWriter"; String str2="类将三行字符串写入到文本文件中，"; String str3="仔细分析有何差别"; String str4="youedkdkdkdkdlkaldalelrladl"; String str5="youedkdkdkdkdlkaldalelrladl"; String str6="youedkdkdkdkdlkaldalelrladl"; String str7="ssssssssssssssssssdtfwserewdd"; String str8="ssssssssssssssssssdtfwserewdd"; String str9="ssssssssssssssssssdtfwserewdd"; pw.println(str); pw.println(str2); pw.println(str3); pw.flush(); pw.close(); osw.write(str4+"\r\n"); osw.write(str5+"\r\n"); osw.write(str6+"\r\n"); osw.close(); bw.write(str7); bw.newLine(); bw.write(str8); bw.newLine(); bw.write(str9); bw.flush(); bw.close(); &#125; catch(UnsupportedEncodingException e)&#123; e.printStackTrace(); &#125; catch(IOException e)&#123; e.printStackTrace(); &#125;================================================================================================================================================================private void writeObject(java.io.ObjectOutputStream out) throws Exception&#123;&#125;private void readObject(java.io.ObjectInputStream in) throws IOException,ClassNotFoundException&#123;&#125;lesson51、进程运行中的程序。(程序是静态的概念,进程是动态的概念)。独立性、动态性、并发性。2、进程是由线程来组成的。3、目的最大化的使用CUP,提高当前应用的性能。4、程和线程的区√每个进程都有独立的代码和数据空间,进程的切换会有很大的开销√同一类线程共享代码和数据空间,每个线程有独立运行的栈和程序计数器,线程切换的开销小多进程和多线程 示例 HostAParty.java√多进程在操作系统中能同时运行多个任务(程序)√多线程在同一应用程序中有多个顺序流同时执行5.优点：1)多线程共享内存，节约系统 资源成本2)充分利用CPU，执行并发任务，效率高3)java内置多线程编程6、Java如何实现多线程？1）Thread类2）Runnable3）Calable接口4）Futrue接口7、对于我们的Java系统来说都是针对于多线程运行的,我们的main方法就是一个主线程8、线程的实现有两种方式1)继承Thread类2)实现Runnable接口run方法就是线程执行的代码start()才是真正的执行线程的方法9、Thread类和Runnable接口的区别1)Thread类也实现了Runnable接口,因此他实现了Runnable接口中的run方法。2)Thread类中有Runnable接口的引用,这个变量名字叫做target☆3)当我们使用第一种方式生成线程的时候，我们需要重写run方法，因为Thread类继承了Runnable接口，而且run方法中如果没有传递实现了Runnable接口实现类的话，run方式就是个空方法，什么都不做。☆4）使用第二种方式创建线程的时候，我们需要Runnable接口，然后实现类Runnable接口的实现类以参数的方式传递到Thread类中，那么当调用Thread类中的run方法的时候，我们就是调用的实现类Runnable接口的那个run方法10、对于线程的执行是不可控的，那么我通常会通过一些手段来控制线程1)循环11、多线程对同一资源进行访问的注意点：1)如果一个类中的变量是一个全局变量，多线程对这个对象的变量进行操作的时候，他们对成员变量的操作会影响到其他的线程(如果说一个线程修改了全局变量，那么其他线程访问该变量的时候，一定会受到影响，比如A a=1 ，B访问a=1 对于成员变量来说，线程是共享成员变量的)2)如果一个类的变量是局部变量，多线程对这个对象的局部变量进行访问的时候，每一个线程都会对局部变量进行一次赋值(copy)，换句话说，每一个线程都有自己的一份局部变量，对于局部变量的改变不会影响到其他线程。12、线程的同步：（并发问题）我们使用Synchrionized关键字进行线程的同步，Synchronized就是一个锁。13、synchronized：当使用多线程访问同一个资源的时候，有可能会发生线程的同步问题，那么我使用Synchronized关键字进行同步的解决14、Java中每一个对象都有一个默认的锁或者是监视器(monitor)。当访问某个对象的Synchronized方法的时候，表将该对象上锁，这时候任何的线程都无法访问这个Synchronized方法了，直到该线程运行完毕或者发生异常的时候，该线程就会释放锁。15、使用Static和Synchronized关键字修饰方法的时候，他上锁的对象是当前对象的Class对象。因此当线程分别访问同一个类的两个对象的Static \synch 方法时，他们执行的是顺序。☆用Synchronized关键字声明的静态方法，同时只能被一个执行线程访问，但是其他线程可以访问这个对象的非静态方法。即：两个线程可以同时访问一个对象的两个不同的Synchronized方法，其中一个是静态方法，另一个是非静态方法。在一个对象被某个线程锁定之后，其他线程都是可以访问这个对象的所有非同步方法的。线程中常用的一些方法方法 功能isAlive() △判断线程是否还活〃着,即线程是否还未终止getpriority()③获得线程的优先级数值setpriority() ⑦设置线程的优先级数值Thread.sep() ⑤(将当前线程睡眠指定毫秒数调用某线程的该方法,将当前线程与该线程\合并〃,即等待join()①该线程结束,再恢复当前线程的运行。yield() √让出cPU,当前线程进入就绪队列等待调度。17、当使用Sleep方法进行线程休眠的时候，线程不会让出资源的。18、wait()、notify()通常情况是结合在一起的，他们必须定义在Synchronized块或者synchronized修饰的方法中的。锁@对象的锁标志---每个对象都有一个锁标志---使用Synchronized可与锁标志交互@Synchronized关键字的用法有两种：---Synchronized语句---Synchronized方法@synchronized语句synchronized(obj) &#123; //synchronized语句块 //对obj的成员只能进行同步访问 ...... &#125;public synchronized void calc2() &#123;....&#125;public void calc()&#123; synchronized(this) &#123; ...... &#125;&#125; --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------2019.3.18groovy swiftscale sparkJDK8 ☆函数式：Java 方法传方法 return 一个方法☆Lambda表达式和函数式接口1、StreamAPI 2、Funtional 3、(Predicate) 4、optional 5、方法的引用 6、JDK8时间类JDK四个函数式接口1)Consumer 2）Function3)predicate4)optional什么是函数式接口？被标注了@functionalInterface的注解的接口就是一个函数式接口☆1)函数接口中只有一个抽象方法☆2）对于函数式接口的实现，Lambda\方法引用\构造方法引用☆3）如果一个接口中声明了一个抽象方法，但是这个接口没有使用FunctionalInterface注解标注，那么编译器也会把他当做函数式接口处理实现：Lambda在Java 中 他既是一个操作符也是一个对象，Lisp-&gt;---------------------------------------------------------------------------------------------------------------------------------------------Lesson7Lamba是由 -&gt; 操作符构成的，左边是 方法的参数 ，右边是 值执行体。（）-&gt; 参数的类型即可以明确的声明，也可以根据上下文推断：（Integer integer） （integer）Lambada的语法结构：右侧的执行体中，有两种表现方式1)表达式 return 根据JDK8 的类型推断 expression2)statement&#123;return 方法体&#125;Stream 和Lambda 和集合是密切相关的。Function 函数式接口，就是进行函数的转换，给定一个输入得到一个产出Stream在linux 管道 PipeLineoptionalif(null!=student)&#123; student.address //条件不为空，address可能为空 &#125;Optional--------NullPointerExcption，是一个包装类(容器类)，他主要的作用就是包装将要发生空指针异常的对象对于Optional对象来说他没有public类型的构造方法，他的对象的实例必须借助于三个Static类型的方法1)empty() 创建一个值为空的optional2)of() 创建一个值为value的optional3)ofnullable() 如果你给我一个value值，如果不为空 of(T value) 如果为空 empty()Optional类中的ifPresent\orElse\orElseGet 来确保空指针异常的方法。方法引用： 本质上就是一个Lambda表达式，方法应用也是函数指针，Function pointer☆方法引用的类型☆1)静态 方法引用 --类型::静态方法名☆2)对象的实例方法 --对象名::实例方法名3)任意对象的实例方法 --对象::实例方法4)构造方法引用 --类名::newcalender simpledateformatjdk8 joda-Time框架的使用，因为JDK8来说，本质上是借助于Joda进行封装的JDK8中的时间类有LocalDate\LocalTime1)LocalDate:表示的是年月日 LocalDate没有Public的构造方法，要想实例化它 使用LocalDate.now of2)LocalTime:表示的是时分秒1、JDBc(Javadatabaseconnection,JDBC就是使用Java操作数据库的简称。1)DriverManager管理数据驱动的2)Connection建立应用和数据库的连接的3)Statement(prepredStatme\t发送各种soQL语句和返回结果集的。4)Resultset丛Statement中执行的各种结果3、进行数据库的连接。1)加载驱动类Mysql:com.mysqljdbcDriver.Oracleoracle.jdbc.driver.OracleDriver.2)使用DriverManager进行连接Mysql:jdbc:mysql://localhost:3306/neusoftOracle:jdbc:oracle:thin:@localhost:1521:orcl4、Driver 接口：他出现的目的就是为各个供应商提供一种标准。5、JDBC中如果执行增删改 就用 statement.execute(sql)sql executeQueryJDBC java database connection JDBC就是使用java 操作数据库的简称。2、1）DriverManager :管理数据驱动的2)Connection：建立应用和数据库的连接的3)Statement(prepredStatment):发送各种SQL语句和返回结果集的。4)ResultSet:从Statment中执行的各种结果Dao模型 3、在JDBC中如果想返回主键，我们需要在conn.preparedStatement()的方法重载中使用Statement.RETURN_GENERATED_KEYS进行标注。然后用PreparedStatement.getGeneratedKeys();获取主键的值if(rs.next()) &#123; System.out.println(rs.getObject(1)); &#125; BLOB的存储大小MYSQL对于大数据的存放TinyBlob 255KBlob 65KMediumBlob 16MLongBlob 4G对于JDBC中的事务的提交是自动的，如果修改事务的提交 我们需要修改Conn.setAutocommit(false)方法.Serializable 同步 事务操作完，下一个事务才能开始repeatable Read 可重复读 避免幻读和重复读 (Mysql)Read Commited 读提交 第一次没提交，第二次就读不到 (sql server Oracle)Read Uncommited 读未提交 第一个没提交，第二个能读，出现脏读现象DBUtils：1）QueryRunner类 Update通用的增删改 query查2) DBUtils 处理器ResultSetHandler:精细化的获取那些字段封装到返回的类型中，ResultSetHandler中handle方法返回值的类型就是这个处理器所返回的类型。BeanHandler:返回一个对象，返回一个（数据库中记录中对应的一个对象）beanHandler(class),Class类型代表的就是返回的类型BeanListHandle:返回一个对象的集合，集合是在数据库中的。Maphandler:把数据库中一条记录转换为Map集合中的一条记录MapListHandler：所有的集合转换为一个MapListScalarHandler:返回指定列的值，或者一个统计函数的值。1、泛型定义在类 接口 方法2、泛型的限制Textends Object (? extends Object)(T super List)3/ 泛型限制的两种情况 1定义类的时候， 定义好 泛型2、初始化的时候， 限定泛型反射【1】类加载器 bootstrap根类加载器 Extension扩展类加载器 System系统加载器【2】 反射Constructor ：newInstance()Field : set(obj,value)Method : invoke(obj,obj...)动态代理 Proxy invocatonHandlerJAVA 异常：就是程序在运行时出现不正常情况。异常由来：问题也是现实生活中一个具体的事务，也可以通过java的类的形式进行描述，并封装成对象。其实就是java对不正常情况就行描述后的对象的体现。对于问题的划分严重问题：java通过 Error类进行描述 对于Error一般不编写针对性的代码对其进行处理非严重问题： Exception类进行描述 针对性的代码对其进行处理无论Error或者Exception都具有一些共性Throwable |--Error |--ExceptionOutofMemory 内存溢出。Error try&#123; 需要被检测的代码&#125; catch&#123; 处理异常的代码&#125;finally&#123;一定会执行的语句；&#125;3、对捕获到的异常对象进行常见方法操作 String getMessage(); 异常信息 e.toString 异常名称 e.printStackTrace(); 异常名称 异常信息 异常出现的位置 默认的异常处理机制在函数上声明异常。便于提高安全性， throws多异常处理项目中出现特有的问题，未被java所描述并封装对象。将特有的问题。进行自定义的异常封装。自定义的异常在打印的时候 没有异常的信息。因为自定义的异常并未定义信息.如何定义异常信息呢？父类中已经把异常信息的操作都完成了所以子类在构造的时候，讲异常信息传递给父类通过super();语句那么就可以直接通过getMessage语句获取继承Exception原因；异常体系有一个特点：因为异常类和异常对象都被抛出。他们都具备可抛型。这个可抛型是Throwable这个体系中独有特点。class FushuException extends Exception()&#123; private int value; FushuException(String msg,int value) &#123; super(msg); this.value = value ; &#125; public int getValue() &#123; return value; &#125;&#125;&#125;class Throwable&#123;private String msg;Throwable(Sttring msg) &#123; this.msg=msg; &#125;public String getMessage() &#123; return msg; &#125;&#125;class Exception extends Throwable&#123;Exception(String message)&#123; super(message); &#125;&#125;自定义异常定义类继承Exception或者RuntimeExcertion2,让该类具备操作异常的共性方法定义自定义异常的信息时,可以使用父类已经定义好的功能异常异常信息传递给父类的构造函数class MYException extends Exception &#123;MyException(String message) &#123; super(message) &#125;&#125;自定义异常按照java的面向对象思想,将程序中出现的特有问题进行封装异常的好处1,将问题进行封装2,将正常流程代码和问题处理代码相分高,方便于阅读异常的处理原则1,处理方式有两种try或者throws2,调用到抛出异常的功能时,抛出几个,就处理几个。一个xy对应多个catch3,多个cat类的catch放到最下面4,catch内,需要定义针对性的处理方式。不要简单的定义printstackfrace,输出语句也不要不写. 当捕获到的异常，本功能处理布料是，可以继续在catch中抛出。 try &#123; throws new AException &#125; catch(AException e) &#123; throw e; &#125; 如果该异常处理不了，但比不属于该功能出现的异常。 可以将异常转换后，在抛出和该功能相关的异常。 或者异常可以处理，当需要将异常产生的和本功能相关的问题提供出去，当调用者知道，并处理。也可以将捕获异常处理后，转换新的异常。 try &#123; throws new AException &#125; catch(AException e) &#123; //对AException处理 throw new BException(); &#125; 比如汇款的例子。 异常的注意1,子类抛出的异常必须是父类的异常的子类或者子集2,如果父类或者接口没有异常抛出时,子类覆盖出现异常,只能try不不能抛。final关键字1、修饰类 变量（成员变量，静态变量，局部变量），函数2、修饰的类不可以被继承。3、修饰的函数不可以被覆盖。4、修饰的变量是一个常量，只能赋值一次内部类只能访问局部当中的 fina修饰的变量class Circle&#123; private static double pi=3.14; private double radius; public Circle(double r) &#123; radius =r; &#125; public static double compare(Circle[] cir) &#123; //补全代码，求数组中的最大值。 int max=0; for(int x =1;x&lt;cir.length;x++) &#123; if(cir[x].radius&gt;cir[max].radius) max =x; &#125; return cir[max].radius; &#125;&#125;class TC&#123; public static void main(String[] args) &#123; Circle cir[]=new Circle[3];//创建了一个类类型数组 System.out.println("最大的半径值是："+Circle.compare(cir)); &#125;&#125;在一个类中编写一个方法,这个方法搜索一个字符数组中是否存在某个字符如果存在,则返回这个字符在字符数组中第一次出现的位置(序号从0开始计算否则,返回-1。要搜索的字符效组和字符都以参数形式传递传递给该方法,如果传入的数组为nu11,应抛出I11ega1ArgumentException异常在类的main方法中以各种可能出现的憤况测试验证该方法编写得是否正确例如,字符不存在,字符存在,传入的数组为mu11等无序数组public int getIndex(Char[] arr,Char key)&#123; if(arr==null) throw new IillegalArgumentException(); for(int x = 0;x&lt;arr.length;x++) &#123; if(arr[x]==key) return x; &#125; return -1;&#125;]]></content>
      <categories>
        <category>Java笔记</category>
      </categories>
      <tags>
        <tag>Java笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode06. Z字形变换]]></title>
    <url>%2F%2F2019%2F04%2F16%2FLeetCode%E7%AC%AC%E5%85%AD%E9%A2%98%E4%B9%8BZ%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[LeetCode06. Z字形变换将字符串 “PAYPALISHIRING” 以Z字形排列成给定的行数：P A H N A P L S I I G Y I R 之后从左往右，逐行读取字符：”PAHNAPLSIIGYIR” 实现一个将字符串进行指定行数变换的函数: string convert(string s, int numRows); 示例 1: 输入: s = &quot;PAYPALISHIRING&quot;, numRows = 3 输出: &quot;PAHNAPLSIIGYIR&quot; 示例 2: 输入: s = &quot;PAYPALISHIRING&quot;, numRows = 4 输出: &quot;PINALSIGYAHRPI&quot; 解释: P I N A L S I G Y A H R P I R=3 P A H N A P L S I I G Y I R 1 5 9 13 2 4 6 8 10 12 14 3 7 11 R=4 P I N A L S I G Y A H R P I 1 7 13 2 6 8 12 14 3 5 9 11 4 10 假设当前行数是r，总行数R，I(n)表示某行第n个字母在原字符串中的index，n从0开始：r=1,R时，I(n+1) = I(n)+2(R-1)1&lt;r&lt;R时，I(n+1) = I(n)+2(R-r) n为偶数时，I(n+1) = I(n)+2(r-1) n为奇数代码： if(s==null||s.length()==0||numRows==1||numRows&gt;=s.length()) { return s; } StringBuilder sb = new StringBuilder(); for(int i=1;i&lt;s.length()+1;i+=2*(numRows-1)) { sb.append(s.charAt(i-1)); } for(int i=2;i&lt;numRows;i++) { boolean k = true; for(int j=i;j&lt;s.length()+1;j+=(k)?2*(numRows-i):2*(i-1),k=!k) { sb.append(s.charAt(j-1)); } } for(int i=numRows;i&lt;s.length()+1;i+=2*(numRows-1)) { sb.append(s.charAt(i-1)); } return sb.toString(); 感谢https://blog.csdn.net/jek123456/article/details/80061119]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode5. 最长回文子串]]></title>
    <url>%2F%2F2019%2F04%2F14%2FLeetCode%205.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[5. 最长回文子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。示例 2： 输入: “cbbd”输出: “bb” 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344public String longestPalindrome(String s) &#123; int center = 0; int rightSide = 0; int index = 0; int radius = 0; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append("@"); for (int i = 0; i &lt; s.length(); i++) &#123; stringBuilder.append(s.charAt(i)); stringBuilder.append("@"); &#125; String newString = stringBuilder.toString(); int[] ints = new int[newString.length()]; for (int i = 0; i &lt; ints.length; i++) &#123; if (rightSide &gt; i) &#123; int left = 2 * center - i; ints[i] = ints[left]; if (ints[left] + i &lt; rightSide) &#123; ints[i] = ints[left]; continue; &#125; else &#123; ints[i] = rightSide - i; &#125; &#125; while (i - ints[i] - 1 &gt;= 0 &amp;&amp; i + ints[i] + 1 &lt; ints.length) &#123; if (newString.charAt(i - ints[i] - 1) == newString.charAt(i + ints[i] + 1)) &#123; ints[i]++; &#125; else &#123; break; &#125; &#125; rightSide = i + ints[i]; center = i; if (radius &lt; ints[i]) &#123; radius = ints[i]; index = i; &#125; &#125; StringBuffer sb = new StringBuffer(); for (int i = index - radius + 1; i &lt;= index + radius; i += 2) &#123; sb.append(newString.charAt(i)); &#125; return sb.toString(); &#125; 问题： CCC 是cc]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode43. 字符串相乘]]></title>
    <url>%2F%2F2019%2F04%2F10%2FLeetCode43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98%2F</url>
    <content type="text"><![CDATA[43. 字符串相乘 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public String multiply(String num1, String num2) &#123; char[] nums1=num1.toCharArray(); char[] nums2=num2.toCharArray(); int n=num1.length(),m=num2.length(),i,j,k; //一般来说两个数相乘，其最大位数也不会大于啷个位数之和 StringBuilder sb=new StringBuilder(n+m); int[] result =new int [n+m]; //转为数字 for( i=0;i&lt;n;i++) &#123; nums1[i]-='0'; &#125; for( j=0;j&lt;m;j++) &#123; nums2[j]-='0'; &#125; for( i=0;i&lt;m;i++) &#123; int carry=0; for( j=0;j&lt;n;j++) &#123; //用nums2的每一位去乘nums1 累加到result result[i+j]+=nums1[n-1-j]*nums2[m-1-i]+carry; carry=result[i+j]/10; result[i+j]%=10; &#125; k=i+j; //进位处理 while(carry!=0) &#123; result[k]+=carry; carry=result[k]/10; result[k]%=10; k++; &#125; &#125; i=n+m-1; while(i&gt;0 &amp;&amp; result[i]==0) i--; while(i&gt;=0) sb.append(result[i--]); return sb.toString(); &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 445两数相加 II]]></title>
    <url>%2F%2F2019%2F04%2F09%2FLeetCode445.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%20II%2F</url>
    <content type="text"><![CDATA[445. 两数相加 II 解法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; Stack&lt;ListNode&gt; s1=new Stack&lt;&gt;(); Stack&lt;ListNode&gt; s2=new Stack&lt;&gt;(); Stack&lt;ListNode&gt; result=new Stack&lt;&gt;(); //入栈 while(l1!=null) &#123; s1.push(l1); l1=l1.next; &#125; while(l2!=null) &#123; s2.push(l2); l2=l2.next; &#125; int carried = 0; while(!s1.isEmpty()||!s2.isEmpty()) &#123; int sum=carried;//进位，初始化 if(!s1.empty()) &#123; sum+=s1.pop().val; &#125; if(!s2.empty()) &#123; sum+=s2.pop().val; &#125; carried=sum/10; sum%=10; result.push(new ListNode(sum)); &#125; //需要进位 if(carried!=0) &#123; result.push(new ListNode(carried)); &#125; ListNode node = new ListNode(-1); ListNode dummpy = node; while(!result.isEmpty()) &#123; node.next=result.pop(); node = node.next; &#125; return dummpy.next; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode15.3sum]]></title>
    <url>%2F%2F2019%2F04%2F09%2FLeetCode15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[1. LeetCode15.3sum## 我们对原数组进行排序，然后开始遍历排序后的数组，这里注意不是遍历到最后一个停止，而是到倒数第三个就可以了。## 这里我们可以先做个剪枝优化，就是当遍历到正数的时候就break，为啥呢，因为我们的数组现在是有序的了，如果第一个要fix的数就是正数了，那么后面的数字就都是正数，就永远不会出现和为0的情况了。 然后我们还要加上重复就跳过的处理，处理方法是从第二个数开始，如果和前面的数字相等，就跳过，因为我们不想把相同的数字fix两次。对于遍历到的数，用0减去这个fix的数得到一个target，然后只需要再之后找到两个数之和等于target即可。 ## 我们用两个指针分别指向fix数字之后开始的数组首尾两个数，如果两个数和正好为target，则将这两个数和fix的数一起存入结果中。然后就是跳过重复数字的步骤了，两个指针都需要检测重复数字。如果两数之和小于target，则我们将左边那个指针i右移一位，使得指向的数字增大一些。同理，如果两数之和大于target，则我们将右边那个指针j左移一位，使得指向的数字减小一些。 public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { Arrays.sort(nums); //[ -1, -4,-1, 0, 1, 2] List&lt;List&lt;Integer&gt;&gt; ls =new ArrayList&lt;&gt;(); for(int i =0;i&lt;nums.length-2;i++) { if (i == 0 || (i &gt; 0 &amp;&amp; nums[i] != nums[i - 1])) { int l=i +1,r=nums.length-1,sum=0-nums[i]; while(l&lt;r) { if(nums[l]+nums[r]==sum) { ls.add(Arrays.asList(nums[i],nums[l],nums[r])); while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++; while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) r--; l++; r--; } else if (nums[l] + nums[r] &lt; sum) { while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++; // 跳过重复值 l++; } else { while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) r--; r--; } } } } return ls; }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode03无重复字符的最长子串]]></title>
    <url>%2F%2F2019%2F04%2F08%2FLeetCode03%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[2 LeetCode03无重复字符的最长子串注意先想到的解决思路是先遍历整个字符串，然后对遍历到的每个字符后的字符做处理（检查是否有重复元素），我们通过建立一个空的字符串，如果检查的字符在这个空的字符串中没有的话，我们将他加入这个空字符串中，并且记录这个空字符串的长度。解法 123456789101112131415161718192021222324252627class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int resultLength=0; int n = s.length(); for(int i=0;i&lt;n;i++) for(int j=i+1;j&lt;=n;j++) if(judgeresult(s,i,j)) resultLength = Math.max(resultLength,j-i);//取length最长 return resultLength; &#125; public boolean judgeresult(String s,int i,int j) &#123; Set&lt;Character&gt; set=new HashSet&lt;&gt;(); for(int k=i;k&lt;j;k++) &#123; char charStr=s.charAt(k); if(set.contains(charStr)) &#123; return false; &#125; else set.add(charStr); &#125; return true; &#125;&#125; 此方法超时 字符串String类中有一个charAt方法来获取字符串中的字符 String s = &quot;nihaoHHH换行&quot;; s.charAt(1); HashMap 123456789101112131415161718class Solution &#123; public static int lengthOfLongestSubstring(String s) &#123; if(s.length()==0) return 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int max = 0; for(int i=0,j=0;i&lt;s.length();i++)&#123; if(map.containsKey(s.charAt(i)))&#123; j = Math.max(j,map.get(s.charAt(i))+1); &#125; map.put(s.charAt(i),i); max = Math.max(max,i-j+1); &#125; return max; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode066加一]]></title>
    <url>%2F%2F2019%2F04%2F08%2FLeetCode066%E5%8A%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[LeetCode067加一给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例 2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。 代码 class Solution { public int[] plusOne(int[] digits) { int n=digits.length-1,i; digits[n]+=1; while(n&gt;0) { if(digits[n]&lt;10)break; digits[n]-=10; digits[n-1]+=1; n--; } if(digits[0]&gt;=10) { digits[0]-=10; int[] ans=new int[digits.length+1]; ans[0] =1; System.arraycopy(digits,0,ans,1,digits.length); return ans; } else return digits; } }]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 03两数相加]]></title>
    <url>%2F%2F2019%2F04%2F08%2FLeetCode02%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[2 两数相加给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 Java：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode head,p=head=new ListNode(-1); int flag=0; while(l1!=null&amp;&amp;l2!=null)&#123; p.next=l1; p=p.next; int t=l1.val; p.val=( l1.val+ l2.val + flag)%10;//个位 flag=(t +l2.val+flag)/10;//进位 l1=l1.next; l2=l2.next; &#125; //如 111 + 11 while(l1!=null) &#123; p.next=l1; p=p.next; int t=l1.val; p.val=(t+flag)%10; flag=(t+flag)/10; l1=l1.next; &#125; while(l2!=null) &#123; p.next=l2; p=p.next; int t=l2.val; p.val=(t+flag)%10; flag=(t+flag)/10; l2=l2.next; &#125; if(flag==1) &#123; p.next=new ListNode(1); &#125; return head.next; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 67二进制字符串求和（用二进制表示）。]]></title>
    <url>%2F%2F2019%2F04%2F08%2FLeetCode67.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C-Java%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[给定两个二进制字符串，返回他们的和（用二进制表示）。输入为非空字符串且只包含数字 1 和 0。 示例 1:12输入: a = "11", b = "1"输出: "100" 示例 2:12输入: a = "1010", b = "1011"输出: "10101" 1234567891011121314151617181920212223242526272829class Solution &#123; public String addBinary(String num1, String num2) &#123; StringBuilder sb =new StringBuilder(); int carry = 0,i =num1.length()-1,j=num2.length()-1; while(i&gt;=0||j&gt;=0) &#123; int sum=carry; if(i&gt;=0) &#123; sum+=(num1.charAt(i) - '0'); i--; &#125; if(j&gt;=0) &#123; sum+=(num2.charAt(j)-'0'); j--; &#125; sb.append(sum%2); //相加结果 carry=sum/2; //进位，如果是1那么carry=0，如果是2则要进位给下面一位+1 &#125; if(carry!=0) sb.append(1); //都加完还要进位的情况 return sb.reverse().toString(); //先翻转再输出 &#125;&#125; 错误Line 10: error: cannot find symbol [in __Driver__.java] String ret = new Solution().addBinary(param_1, param_2); ^ symbol: method addBinary(String,String) location: class Solution 太蠢了 该错误是solution 方法是addBinary我自己改了addString。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 04寻找两个有序数组的中位数]]></title>
    <url>%2F%2F2019%2F04%2F08%2FLeetCode04%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[4. 寻找两个有序数组的中位数 解题思路寻找中位数，最终定位为寻找第K位的值。k是根据总体数据量的奇、偶性计算得到的。 1 、假设nums1.length = m, nums2.length = n; m &lt; n。 2、若(m + n) % 2 == 0, 表示两数组之和为偶数，应该是有两个中位数，需要求均值。如果和为奇数，则只有一位，在代码设计最初考虑该问题。 3、为了使得方法的统一，在最初时，对数组进行处理，统一使得传进方法的短数组为nums1，这样在后续进行k/2与。 4、如果len1-start1 == 0,则表示nums1已经全部加入前k个了，则第k个为nums2[k -1]; 在方法findKth（）中的k是一直变化的，初始时，k为两个数组中排序之后的第k个数的位置；k在方法中的真正含义为“还需要找到多少个数才能达到k个”；因此假设nums1.length ==0;,此时len1-start1 == 0, 则中位数就是nums2[k - 1],即在nums1中找到了0个数，还需要找k个数，第k个数就是nums[k - 1]; 5、 如果k == 1,则表示前k-1小的数已经找过了，则第k个数肯定是nums1[start1]和nums2[start2]中较小的那个数。 6、 下面接着就是常规的情况：即nums1中包含一部分k,nums2中也包含一部分的k,因此就从每个数组的k/2那里开始比较（也相当于每次都会有一半的数被加入前k个，因此时间复杂度为O（log(m + n)））。 采用p1和p2分别记录当前nums1和nums2需要比较的那个位，由于nums1比较短，因此有可能k/2的位置已经超出了nums1的长度，因此nums1还需要做特殊处理，即求解p1处所示；由于p1做了特殊处理，那p2也就要做特殊处理。总之，start1~p1和start2~p2的和一定为k。 1）若nums1[p1 - 1] &lt; nums[p2 - 1],则表明【start1, p1)之间的值在前k个数中；2）若nums[p1 - 1] &gt; nums2[p2- 1],则表明【start2, p2)之间的值在前k个数中；3）若两值相等，则表明【start1, p1)+【start2， p2）的个数为k,则结果直接返回其中一个即可。 边界问题1、为什么比较的p1和p2的前一个位的数，而不是p1和p2位置的数呢？这就是边界问题。 举例说明：假设start1== start2 == 0, 则p1 = Math.min(len1, k / 2); p2 = k - p1,即p1 + p2 == k;；假设p1 = 5, p2 = 7; 则k = 12; 在数组中nums[5]其实是第6个数，nums[7]其实是第8个数，所以我们比较的是nums1[p1 - 1]与nums2[p2 - 1]的值。 2、注意每个数组的start位置，其实是有效数据的前一位，因此可以直接做差来求数据的个数。例如[1,3,4,5]，记录为start=0,length=4。在后续进行推进修改时，start仍旧为有效数据位的前一位。 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int len1 = nums1.length; int len2 = nums2.length; int size = len1 + len2; if(size % 2 == 1) return findKth(nums1, 0, len1, nums2, 0, len2, size / 2 + 1); else return (findKth(nums1, 0, len1, nums2, 0, len2, size / 2) + findKth(nums1, 0, len1, nums2, 0, len2, size / 2 + 1)) /2; &#125; public double findKth(int[] nums1, int start1, int len1, int[] nums2, int start2, int len2, int k) &#123; if(len1 - start1 &gt; len2 -start2) // 传进来的时候统一让短的数组为nums1 return findKth(nums2, start2, len2, nums1, start1, len1, k); if(len1 - start1 == 0) // 表示nums1已经全部加入前K个了，第k个为nums2[k - 1]; return nums2[k - 1]; if(k == 1) return Math.min(nums1[start1], nums2[start2]); // k==1表示已经找到第k-1小的数，下一个数为两个数组start开始的最小值 int p1 = start1 + Math.min(len1 - start1, k / 2); // p1和p2记录当前需要比较的那个位 int p2 = start2 + k - p1 + start1; if(nums1[p1 - 1] &lt; nums2[p2 - 1]) return findKth(nums1, p1, len1, nums2, start2, len2, k - p1 + start1); else if(nums1[p1 - 1] &gt; nums2[p2 -1]) return findKth(nums1, start1, len1, nums2, p2, len2, k - p2 + start2); else return nums1[p1 - 1]; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vultr+shadowsockR+谷歌BBR]]></title>
    <url>%2F%2F2019%2F04%2F02%2FVultr%2BshadowsockR%2B%E8%B0%B7%E6%AD%8CBBR%20%E6%90%AD%E5%BB%BA%E5%8F%8B%E5%A5%BD%E8%AE%BF%E9%97%AEyoutube%E8%BD%AF%E4%BB%B6%2B%E9%98%B2%E6%AD%A2SSHD%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Let’s begin这里我们推荐VULTR超值服务器（支持支付宝付款），按小时付费，用多少扣多少，$3.5刀每月，500GB流量随便用，IP被墙了，不想用了直接删掉所有建立的主机，余额还在账户里可以买新的没被墙的IP！(VULTR升级了，以前的2.5刀只支持IPV6，放弃使用，所以只能购买3.5刀每月的。) 如果优惠码没了，失效了，可以找自己的朋友2-3人一起负担费用，流量什么的完全够了，我们即使每天看YOUTUBE，一个月一个人也可能才100GB流量不到！所以3.5刀的服务器 1-3人完全OK！！ 1.限时活动 充值10美元送25美元 (如果注册账户看不到赠送，则活动结束) vultr新用户冲5刀送25刀，很少见到这么大的优惠额度了。因为这次送的钱有效期一年，以往送的只有两三个月的有效期。如果买新泽西之类的冷门机房是2.5刀一个月，足够你用一年了。当然如果你追求速度想买日本机房的话是5刀一个月，只能用半年。 优惠直达地址：Vultr 注意！如果你用paypal付款可以直接拿到25刀，支付宝付款现在不给这25刀了！切记切记！自己去注册一个paypal就好了。paypal的用法和支付宝完全一样（支付宝就是山寨版paypal），国外vps基本都只支持paypal付款和信用卡付款 2.第二个活动：冲5刀送50刀Vultr​点连接进去你注册个号，不要填入优惠码，然后登陆就发现，提示你充值5刀送100刀。 但是这个送的50刀有个缺陷：有效期一个月。意思是你必须要在1个月的时间里花掉这100刀，不然一个月之后送的额度就没有了。相当鸡肋 另外VULTR还有一个长期可用的优惠活动：关注它家推特，获得3刀。High Performance Cloud Servers另外VULTR还有一个长期可用的优惠活动：关注它家推特，获得3刀。 点击右侧service，然后在点击图示的Good News，关注一下它家的推特就能拿3刀的代金券。 可以选择3.5$的Atlanta服务器 最好选CentOS4.2日测试为300延迟。 部署后会提示完成。PING全国检测地址：http://ping.chinaz.com 注意，上面只是检查服务器速度，以及是否被墙，但是现在Q升级搞了TCP阻断，国内明显的就是SSH连接不上。检查网址： http://port.ping.pe/按提示输入：你的IP:22 （例子： 111.222.333.444:22 部署教程：下载XSHELL软件并安装后，打开软件 连接国外IP即服务器时，软件会先后提醒你输入用户名和密码，用户名默认都是根，密码是你购买的服务器系统的密码。 如果XSHELL连不上服务器，没有弹出让你输入用户名和密码的输入框，表明你开到的IP是一个被墙的IP，遇到这种情况，重新开新的服务器，直到能用XSHELL连上为止，耐心点哦！如果同一个地区开了多台服务器还是不行的话，可以换其它地区。———————————————————————————————————————————————连接成功后，会出现如上图所示，之后就可以复制粘贴代码部署了。 CentOS6 / Debian6 / Ubuntu14 ShadowsocksR一键部署管理脚本： yum -y install wget wget -N –no-check-certificate https://raw.githubusercontent.com/hombo125/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 备用脚本： yum -y install wget wget -N –no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh ——————-代码分割线—————- 复制上面的代码到VPS服务器里，按回车键，脚本会自动安装，以后只需要运行这个快捷命令就可以出现下图的界面进行设置，快捷管理命令为：bash ssr.sh 如上图出现管理界面后，输入数字1来安装SSR服务端。如果输入1后不能进入下一步，那么请退出xshell，重新连接vps服务器，然后输入快捷管理命令bash ssr.sh再尝试。 根据上图提示，依次输入自己想设置的端口和密码（密码建议用复杂点的字母组合，端口号为40-65535之间的数字），回车键用于确认 注：关于端口的设置，总的网络总端口有6万多个，理论上可以任意设置但是有的地区需要设置特殊的端口才有效，一些特殊的端口比如80,143,443,1433,3306,3389,8080。如上图，选择想设置的加密方式，比如10，按回车键确认 接下来是选择协议插件，如下图： 选择并确认后，会出现上图的界面，提示你是否选择兼容原版，这里的原版指的是SS客户端（SS客户端没有协议和混淆的选项），可以根据需求进行选择，演示选择ÿ 之后进行混淆插件的设置。 注意：。如果协议是原点，那么混淆也必须是纯;如果协议不是原点，那么混淆可以是任意的有的地区需要把混淆设置成平纹才好用因为混淆不总是有效果，要看各地区的策略，有时候不混淆（plain）让其看起来像随机数据更好。（特别注意：tls 1.2_ticket_auth容易受到干扰！请选择除tls开头以外的其他混淆!!!） 进行混淆插件的设置后，会依次提示你对设备数，单线程限速和端口总限速进行设置，默认值是不进行限制，个人使用的话，选择默认即可，即直接敲回车键。 注意：关于限制设备数，这个协议必须是非原版且不兼容原版才有效，也就是必须使用SSR协议的情况下，才有效！之后代码就正式自动部署了，到下图所示的位置，提示你下载文件，输入为：y 脚本演示结束。 此脚本是开机自动启动，部署一次即可。最后可以重启服务器确保部署生效（一般情况不重启也可以）。重启需要在命令栏里输入reboot，输入命令后稍微等待一会服务器就会自动重启，一般重启过程需要2〜5分钟，重启过程中XSHELL会自动断开连接，等VPS重启好后才可以用XSHELL软件进行连接。如果部署过程中卡在某个位置超过10分钟，可以用XSHELL软件断开，然后重新连接你的IP，再复制代码进行部署。———————————————————————————————————————————————第三步：一键加速VPS服务器此加速教程为谷歌BBR加速，Vultr的服务器框架可以装BBR加速，加速后对速度的提升很明显，所以推荐部署加速脚本。该加速方法是开机自动启动，部署一次就可以了。 按照第二步的步骤，连接服务器ip，登录成功后，在命令栏里粘贴以下代码： 【谷歌BBR加速教程】 yum -y install wget wget –no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh chmod +x bbr.sh ./bbr.sh 把上面整个代码复制后粘贴进去，不动的时候按回车，然后耐心等待，最后重启vps服务器即可。 演示开始，如图： 复制并粘贴代码后，按回车键确认 服务器重启成功并重新连接服务器后，输入命令lsmod | grep bbr 如果出现tcp_bbr字样表示bbr已安装并启动成功。如图： 打开了SSR之后 在对应的位置，填上服务器ip、服务器端口、密码、加密方式、协议和混淆，最后将浏览器的代理设置为（http）127.0.0.1和1080即可。账号的端口号就是你自己设置的，而要上网的浏览器的端口号是1080，固定的，谷歌浏览器可以通过 SwitchyOmega 插件来设置。 启动SSR客户端后，右键SSR客户端图标，选择第一个“系统代理模式”，里面有3个子选项，选择”全局模式“，之后就可以用浏览器设置好了的代理模式（http）127.0.0.1和1080翻墙，此模式下所有的网站都会走SSR代理。（适合新手） VPS如何设置拒绝被暴力登录-本周登录vps速度非常慢，整个科学上网过程都很慢。 调查了一下，发现/var/log/secure文件大幅度增长，里面大量这种暴力攻击的log：1、先把始终允许的IP填入 /etc/hosts.allow ，这很重要！比如： sshd:yourip:allow 2、脚本 /usr/local/bin/secure_ssh.sh 复制代码 12345678910111213#! /bin/bashcat /var/log/secure|awk '/Failed/&#123;print $(NF-3)&#125;'|sort|uniq -c|awk '&#123;print $2"="$1;&#125;' &gt; /usr/local/bin/black.listfor i in `cat /usr/local/bin/black.list`do IP=`echo $i |awk -F= '&#123;print $1&#125;'` NUM=`echo $i|awk -F= '&#123;print $2&#125;'` if [ $&#123;#NUM&#125; -gt 1 ]; then grep $IP /etc/hosts.deny &gt; /dev/null if [ $? -gt 0 ];then echo "sshd:$IP:deny" &gt;&gt; /etc/hosts.deny fi fidone 复制代码3、将secure_ssh.sh脚本放入cron计划任务，每1分钟执行一次。 crontab -e */1 * * * * sh /usr/local/bin/secure_ssh.sh 最后查看 /etc/hosts.deny 可以看到如下IP，目测是被当成了肉鸡： 123456789101112131415sshd:114.112.83.142:denysshd:117.135.131.60:denysshd:151.11.201.3:denysshd:180.97.220.3:denysshd:185.110.132.202:denysshd:185.110.132.93:denysshd:198.154.63.79:denysshd:198.154.63.81:denysshd:205.209.191.54:denysshd:218.83.155.86:denysshd:219.83.163.183:denysshd:221.229.172.103:denysshd:221.229.172.35:denysshd:91.224.161.69:denysshd:93.158.200.107:deny 或参考 单机运行环境搭建之 －－Centos6.4下使用Denyhosts禁止针对linux sshd的暴力破解-当你的linux服务器暴露在互联网之中，该服务器将会遭到互联网上的扫描软件进行扫描，并试图猜测SSH登录口令你会发现，每天会有多条SSH登录失败纪录。那些扫描工具将对你的服务器构成威胁，你必须设置复杂登录口令，并将尝试多次登录失败的IP给阻止掉，让其在一段时间内不能访问该服务器。简单方法也可以修改22端口号. 用DenyHosts可以阻止试图猜测SSH登录口令，它会分析/var/log/secure等日志文件，当发现同一IP在进行多次SSH密码尝试时就会记录IP到/etc/hosts.deny文件，从而达到自动屏蔽该IP的目的。last命令的信息来自/var/log/wtmp,如果对有经验的人可能会删除掉这个。但是还是会留下痕迹，使用nmap命令扫描端口， nmap -PO -sS ip,使用lsof命令，停掉一些不必要的服务，多关注漏洞，配置强有力的iptables来保护自己的系统或者尝试使用Chkrootkit应用程序对rootkit的跟踪，尝试AIDE来检查文件系统的完整性。服务器上除了root外，Linux用户越少越好，如果非要添加就添加shell为nologin。 DenyHosts安装 1.环境检查：安装环境Centos x64 6.4下载到/usr/src目录中，查询一下系统是否符合要求 ldd /usr/sbin/sshd|grep libwrap //查看libwrap动态链接库文件。 libwrap.so.0 =&gt; /lib64/libwrap.so.0 (0x00007f4b2a1b9000) python -V //查询版本为2.6.5 Python 2.6.6 2、安装步骤： cd /usr/src yum install wget -y wget http://ncu.dl.sourceforge.net/sourceforge/denyhosts/DenyHosts-2.6.tar.gz tar -xzvf DenyHosts-2.6.tar.gz cd DenyHosts-2.6 python setup.py install //安装Denyhost 切换目录进入/usr/share/denyhosts目录 1cd /usr/share/denyhosts/ 拷贝一份denyhosts.cfg1cp denyhosts.cfg-dist denyhosts.cfg 5、DenyHosts参数配置 vi denyhosts.cfg 切换到命令行模式 :1,$d 清空内容,然后输入如下内容：12345678910111213141516171819SECURE_LOG = /var/log/secure# format is: i[dhwmy]# Where i is an integer (eg. 7)# m = minutes# h = hours# d = days# w = weeks# y = years## never purge:PURGE_DENY=50mHOSTS_DENY=/etc/hosts.denyBLOCK_SERVICE=sshdDENY_THRESHOLD_INVALID=1 DENY_THRESHOLD_VALID=10 DENY_THRESHOLD_ROOT=5 WORK_DIR=/usr/local/share/denyhosts/dataDENY_THRESHOLD_RESTRICTED =1 LOCK_FILE=/var/lock/subsys/denyhostsHOSTNAME_LOOKUP=NOADMIN_EMAIL=10402852@qq.comDAEMON_LOG=/var/log/denyhostsDAEMON_PURGE=10m 解释如下：1234567891011121314151617181920212223SECURE_LOG = /var/log/secure #ssh日志文件 # format is: i[dhwmy] # Where i is an integer (eg. 7) # m = minutes # h = hours # d = days # w = weeks # y = years # # never purge: PURGE_DENY = 50m #过多久后清除已阻止IP HOSTS_DENY = /etc/hosts.deny #将阻止IP写入到hosts.deny BLOCK_SERVICE = sshd #阻止服务名 DENY_THRESHOLD_INVALID = 1 #允许无效用户登录失败的次数 DENY_THRESHOLD_VALID = 10 #允许普通用户登录失败的次数 DENY_THRESHOLD_ROOT = 5 #允许root登录失败的次数 WORK_DIR = /usr/local/share/denyhosts/data #将deny的host或ip纪录到Work_dir中 DENY_THRESHOLD_RESTRICTED = 1 #设定 deny host 写入到该资料夹 LOCK_FILE = /var/lock/subsys/denyhosts #将DenyHOts启动的pid纪录到LOCK_FILE中，已确保服务正确启动，防止同时启动多个服务。 HOSTNAME_LOOKUP=NO #是否做域名反解 ADMIN_EMAIL =10402852@qq.com #设置管理员邮件地址 DAEMON_LOG = /var/log/denyhosts #自己的日志文件 DAEMON_PURGE = 10m #该项与PURGE_DENY 设置成一样，也是清除hosts.deniedssh 用户的时间。 注意：不能把带注释的配置文件粘贴上去，会报错！！！- 5.DenyHosts启动文件配置 cd /usr/share/denyhosts cp daemon-control-dist daemon-control chown root daemon-control chmod 700 daemon-control ./daemon-control start #启动DenyHosts 如果要使DenyHosts每次重起后自动启动还需做如下设置： ln -s /usr/share/denyhosts/daemon-control /etc/init.d/denyhosts #建立符号链接 chkconfig --add denyhosts #增加denyhosts服务进程 chkconfig denyhosts on #设置开机启动denyhosts chkconfig --list denyhosts denyhosts 0:off 1:off 2:on 3:on 4:on 5:on 6:off 6.查看日志异常信息 tail -f /var/log/secure Feb 27 18:43:10 localhost login: pam_unix(login:auth): authentication failure; logname=LOGIN uid=0 euid=0 tty=tty1 ruser= rhost= user=test Feb 27 18:43:12 localhost login: FAILED LOGIN 1 FROM (null) FOR test, Authentication failure Feb 27 18:43:15 localhost login: FAILED LOGIN 2 FROM (null) FOR test, Authentication failure Feb 27 18:43:21 localhost login: FAILED LOGIN 3 FROM (null) FOR test, Authentication failure Feb 27 18:43:26 localhost login: pam_unix(login:session): session opened for user test by LOGIN(uid=0) Feb 27 18:43:26 localhost login: LOGIN ON tty1 BY test Feb 27 18:45:32 localhost su: pam_unix(su:auth): authentication failure; logname=test uid=500 euid=0 tty=tty1 ruser=test rhost= user=root Feb 27 18:45:47 localhost su: pam_unix(su-l:session): session opened for user root by test(uid=500) Feb 27 19:00:03 localhost sshd[19861]: Accepted password for root from 192.168.40.41 port 4289 ssh2 设置入侵检测工具之PortSentry ========有可能用到：================= 更改DenyHosts的默认配置之后，重启DenyHosts服务即可生效:/etc/init.d/daemon-control restart #重启denyhosts 为防止自己的IP被屏蔽，可以：echo “你的IP” &gt;&gt; /usr/share/denyhosts/allowed-hosts 将你的IP加入白名单，再重启DenyHosts：/etc/init.d/denyhosts ，如果已经被封，需要先按下面的命令删除被封IP后再加白名单。 如有IP被误封，可以执行下面的命令解封：wget http://soft.vpser.net/security/denyhosts/denyhosts_removeip.sh &amp;&amp; bash denyhost_removeip.sh 要解封的IP 更多的说明请查看自带的README文本文件，好了以后维护VPS就会省一些心了，但是各位VPSer们注意了安全都是相对的哦，没有绝对安全，将密码设置的更Strong，并请定期或不定期的检查你的VPS主机，而且要定时备份你的数据哦。 与DenyHosts类似的软件还有fail2ban功能上更多，还可以对ftp进行保护，自己可以搜索看一下。 3.启动服务 service denyhosts start denyhos使用 如果不想让主机拒绝某一个ip，做法如下： vi /etc/hosts.allow sshd： 192.168.0.1 #允许192.168.0.1访问该主机的ssh服务 如果想拒绝某一个ip同样使用vi /etc/hosts.deny添加就Ok ========================= 如何得知自己的VPS曾经或正在遭受账号暴力破解登录呢？执行以下命令，查询出来的结果中包含了“ip地址=数量”就是攻击者信息。 cat /var/log/secure|awk &apos;/Failed/{print $(NF-3)}&apos;|sort|uniq -c|awk &apos;{print $2&quot;=&quot;$1;}&apos; 常见问题参考解决方法：-1、用了一段时间发现ssr账号用不了了 首先ping一下自己的ip，看看能不能ping的通，ping不通那么就是ip被墙了，ip被墙时，xshell也会连接不上服务器，遇到这种情况重新部署一个新的服务器，新的服务器就是新的ip。关于怎么ping ip的方法，可以自行网上搜索，或者用xshell软件连接服务器来判断，连不上即是被墙了。vultr开通和删除服务器非常方便，新服务器即新ip，大多数vps服务商都没有这样的服务，一般的vps服务商可能会提供免费更换1次ip的服务。 2、刚搭建好的ssr账号，ip能ping通，但是还是用不了 首选排除杀毒软件的干扰，尤其是国产杀毒软件，比如360安全卫生、360杀毒软件、腾讯管家、金山卫生等。这些东西很容易干扰翻墙上网，如果你的电脑安装了这样的东西，建议至少翻墙时别用，最好卸载。其次，检查下SSR信息是否填写正确。浏览器的代理方式是否是ssr代理，即（HTTP）127.0.0.1 和1080。如果以上条件都排除，还是用不了，那么可以更换端口、加密方式、协议、混淆，或者更换服务器位置。另外，如果你的vps服务器配置的是SSR账号，即有协议和混淆且没有兼容原版(SS版），那么你必须使用SSSR客户端来使用账号，因为SS客户端没有填写协议和混淆的选项。 3、有的地区需要把混淆参数设置成plain才好用。因为混淆不总是有效果，要看各地区的策略，有时候不混淆（plain）让其看起来像随机数据更好。 4、电脑能用但手机用不了 如果你的手机用的是SS客户端，SS客户端没有填协议和混淆的地方，如果你部署的协议和混淆的时候没有选择兼容原版（SS版），因此手机是用不了的。这个时候你把协议弄成兼容原版、混淆也设置成兼容原版即可。或者直接将协议设置成origin且混淆设置成plain。 5、vps的服务器操作系统不要用的太高，太高可能会因为系统的防火墙问题导致搭建的SSR账号连不上，如果你用的centos系统，建议用centos6，不要用centos7。如果你前面不小心装了centos7系统，那么只能重装系统或者重新部署新的vps服务器。 6、vultr服务商提供的vps服务器是单向流量计算，有的vps服务商是双向流量计算，单向流量计算对于用户来说更实惠。因为我们是在vps服务器上部署SSR服务端后，再用SSR客户端翻墙，所以SSR服务端就相当于中转，比如我们看一个视频，必然会产生流量，假如消耗流量80M，那么VPS服务器会产生上传80M和下载80M流量，vultr服务商只计算单向的80M流量。如果是双向计算流量，那么会计算为160M流量。 7、如果你想把搭建的账号给多人使用，不用额外设置端口，因为一个账号就可以多人使用。一般5美元的服务器可以同时支持40人在线使用。 如果想实现支持每个用户(端口)不同的加密方式/协议/混淆等，并且管理流量使用，可以参考多用户配置脚本：wget -N –no-check-certificate https://raw.githubusercontent.com/hombo125/doubi/master/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh 备用脚本：wget -N –no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh 安装后管理命令为：bash ssrmu.sh注意：这个多用户配置脚本和教程内容的脚本无法共存！要想用这个脚本，把之前的脚本卸载，输入管理命令bash ssr.sh ，选择3，卸载ShadowsocksR即可卸载原脚本。 8、vultr服务器每月有流量限制，超过限制后服务器不会被停止运行，但是超出的流量会被额外收费。北美和西欧地区的服务器超出流量后，多出的部分收费为0.01美元/G。新加坡和日本东京（日本）为0.025美元/G，悉尼（澳大利亚）为0.05美元/G。把vultr服务器删掉，开通新的服务器，流量会从0开始重新计算。 9、vultr怎样才能申请退款呢？ 与其他国家商家一样输入你的退款理由。比如：请退还我账户中的所有余额。工单提交以后一般很快就可以给你确认退款，若干个工作日后就会退回你的支付方式。（全额退）款结束后，账号可能会被删除） 如果英语水平不好，但是想和客服进行交流，可以用百度在线翻译，自动中文转英文和英文转中文。 10，路由器也可以配置ss / ssr账号，详见openwrt-ssr项目地址：https://github.com/ywb94/openwrt-ssr 以上资料参考转自：https://www.vpscn.net/40.htmlhttps://my.oschina.net/u/703355/blog/775658https://my.oschina.net/u/1038053/blog/611012]]></content>
      <categories>
        <category>VPS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DBUtils简介]]></title>
    <url>%2F%2F2019%2F04%2F01%2FJava%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93(1)%E2%80%94%E2%80%94DbUtils%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[DBUtils Commons DbUtils是Apache组织提供的一个对JDBC进行简单封装的开源工具类库，使用它能够简化JDBC应用程序的开发，同时也不会影响程序的性能。 DBUtils简介DBUtils是java编程中的数据库操作实用工具，小巧简单实用， 1.对于数据表的读操作，可以把结果转换成List，Array，Set等java集合，便于程序员操作。 2.对于数据表的写操作，也变得很简单（只需写sql语句）。 DBUtils包括主要类 DbUtils类：启动类 ResultSetHandler接口：转换类型接口，用于你想要将取出的数据转换成什么类型，以下为该接口的实现类 –ArrayHandler类：返回一行记录，把记录中的每个值存放到一个Object数组中并返回。 –ArrayListHandler类：返回多行记录，每一行记录存放入一个Object数组中，然后将数组封装到List集合中返回。 –ColumnListHandler类：取某一列的数据。封装到List中。 –ScalarHandler类：适合获取一行一列数据，一般用于接收返回的统计结果。比如count(*)统计行数。 –BeanHandler类：把记录保存到相应的JavaBeen中转成对象。 –BeanListHandler类：把记录转化成List，使记录为JavaBean类型的对象 –MapHandler类：实现类，返回一行数据，将列名称作为key，对应的值作为value –MapListHandler类：返回多行数据，每一行记录为一个Map集合，然后将Map集合封装到List当中返回。 QueryRunner类：执行SQL语句的类 实例化该类时需要传入一个数据库的连接(Connection的对象)DBUtils的使用步骤： 创建项目 导入jar包 工具类 配置文件 commons-dbutils-1.6.jar 创建QueryRunner对象 使用对象执行SQL语句 实例： 使用Druid连接池常见工具类，具体方法见JDBC数据库连接池 1234567891011121314151617public class DataSourceUtils &#123; public static DataSource ds = null ; static &#123; InputStream is = DataSourceUtils.class.getClassLoader().getResourceAsStream("druid.properties") ; Properties pro = new Properties() ; try &#123; pro.load(is); ds = DruidDataSourceFactory.createDataSource(pro) ; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public static DataSource getDataSource() &#123; return ds ; &#125;&#125; 编写测试类对DbUtils进行测试：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class DbUtilsTest &#123; @Test //查询一行数据ArrayHandler public void testArrayHandler() throws Exception&#123; //创建QueryRunner对象 QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource()) ; //执行SQL语句，使用预编译SQL语句 ：qr.query(String sql, ResultSetHandler rsh,Object...params); //使用完整SQL语句：qr.query(String sql, ResultSetHandler rsh); Object[] o = qr.query("select * from emp where empno=?", new ArrayHandler(),9898) ; for (Object object : o) &#123; System.out.print(object + " "); &#125; &#125; @Test //查询多行数据ListArrayHandler public void testListArrayHandler() throws Exception&#123; QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource()) ; List&lt;Object[]&gt; list = qr.query("select * from emp", new ArrayListHandler()) ; list.forEach(object -&gt;&#123; for (Object o : object) &#123; System.out.print(o + " "); &#125; System.out.println(); &#125;); &#125; @Test //查询一行数据BeanHandler public void testBeanHandler() throws Exception&#123; QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource()) ; Employee emp = qr.query("select * from emp where empno=9898", new BeanHandler&lt;Employee&gt;(Employee.class)) ; System.out.println(emp); &#125; @Test //查询多行数据BeanListHandler public void testBeanListHandler() throws Exception&#123; QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource()) ; List&lt;Employee&gt; list = qr.query("select * from emp", new BeanListHandler&lt;&gt;(Employee.class)) ; list.forEach(System.out::println); &#125; @Test //查询一列数据ColumnListHandler public void testColumnListHandler() throws Exception&#123; QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource()) ; List&lt;String&gt; ename = qr.query("select ename from emp", new ColumnListHandler&lt;String&gt;(1)) ; ename.forEach(System.out::println); &#125; @Test //返回一行一列数据ScalarHandler() public void testScalarHandler() throws Exception&#123; QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource()) ; long count = qr.query("select count(*) from emp", new ScalarHandler&lt;Long&gt;()) ; System.out.println(count); &#125; @Test //插入一条数据update() public void testInsert() throws Exception&#123; QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource()) ; Employee e = new Employee(9896, "李春华", "歌姬", 6565, new Date(), 2000, 0, 70) ; int len = qr.update("INSERT INTO emp VALUES (?,?,?,?,?,?,?,?)", e.getEmpno(),e.getEname(),e.getJob(),e.getMgr(),e.getHiredate(),e.getSal(),e.getComm(),e.getDeptno()) ; if (len&gt;0) &#123; System.out.println("添加成功"); &#125; else &#123; System.out.println("添加失败"); &#125; &#125; @Test //更新一条数据Update() public void testUpdate() throws Exception&#123; QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource()) ; int len = qr.update("UPDATE emp SET job=? WHERE empno=?", "歌姬",9896) ; if (len &gt; 0) &#123; System.out.println("更改成功"); &#125; else &#123; System.out.println("更改失败"); &#125; &#125; @Test //删除一条数据Update() public void testDelete() throws Exception&#123; QueryRunner qr = new QueryRunner(DataSourceUtils.getDataSource()) ; int len = qr.update("DELETE FROM emp WHERE empno = ?",9896) ; if (len &gt; 0) &#123; System.out.println("删除成功"); &#125; else &#123; System.out.println("删除失败"); &#125; &#125;&#125; 注：当我们使用预编译SQL语句时，要在对应方法的最后面加入相应的值。More info: Gihub]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习百度OCR文字识别]]></title>
    <url>%2F%2F2019%2F04%2F01%2F%E7%99%BE%E5%BA%A6OCR%E6%96%87%E5%AD%97%E8%AF%86%E5%88%ABJava%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[学习百度OCR文字识别识别图片转换为字体，需要json-2060810.jar 、log4j-1.2.17.jar、aip-java-sdk-4.10.2.jaraccessToken = getAuth 得到两个参数由百度得到贴代码 1.BaiduOCR.java点击显/隐内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 package test; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.HttpURLConnection; import java.net.URL; import java.net.URLEncoder; import java.util.List; import java.util.Map; import java.util.regex.Matcher; import java.util.regex.Pattern; import org.json.JSONObject; import test.FileUtil; import test.HttpUtil; import test.Base64Util; public class BaiduOCR &#123; public static void main(String[] args) &#123; String otherHost = "https://aip.baidubce.com/rest/2.0/ocr/v1/general_basic"; // 本地图片路径 String filePath = "D:/1.jpg"; try &#123; byte[] imgData = FileUtil.readFileByBytes(filePath); String imgStr = Base64Util.encode(imgData); String params = URLEncoder.encode("image", "UTF-8") + "=" + URLEncoder.encode(imgStr, "UTF-8"); /** * 线上环境access_token有过期时间， 客户端可自行缓存，过期后重新获取。 */ String accessToken = getAuth("Mr6PljojDwza3pVQaKGD3EtF", "5yqQjwkKVpXonr47W9i9thfLra4P9K4W"); String result = HttpUtil.post(otherHost, accessToken, params); // System.out.println(result); String str = result; //正则表达式过滤"[]" String regEx = "[&#125;:\"\\s]";// String regEx = "[`~!@#$%^&amp;*()\\-+=&#123;&#125;':;,\\[\\]&lt;&gt;/?￥%…（）_+|【】‘；\"：”“’。，、？\\s]"; Pattern p = Pattern.compile(regEx); Matcher m = p.matcher(str); System.out.println(m.replaceAll("").replaceAll(",\\&#123;words","")); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static String getAuth(String ak, String sk) &#123; // 获取token地址 String authHost = "https://aip.baidubce.com/oauth/2.0/token?"; String getAccessTokenUrl = authHost // 1. grant_type为固定参数 + "grant_type=client_credentials" // 2. 官网获取的 API Key + "&amp;client_id=" + ak // 3. 官网获取的 Secret Key + "&amp;client_secret=" + sk; try &#123; URL realUrl = new URL(getAccessTokenUrl); // 打开和URL之间的连接 HttpURLConnection connection = (HttpURLConnection) realUrl.openConnection(); connection.setRequestMethod("GET"); connection.connect(); // 获取所有响应头字段 Map&lt;String, List&lt;String&gt;&gt; map = connection.getHeaderFields(); // 遍历所有的响应头字段 for (String key : map.keySet()) &#123; System.err.println(key + "---&gt;" + map.get(key)); &#125; // 定义 BufferedReader输入流来读取URL的响应 BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream())); String result = ""; String line; while ((line = in.readLine()) != null) &#123; result += line; &#125; /** * 返回结果示例 */ System.err.println("result:" + result); JSONObject jsonObject = new JSONObject(result); String access_token = jsonObject.getString("access_token"); return access_token; &#125; catch (Exception e) &#123; System.err.printf("获取token失败！"); e.printStackTrace(System.err); &#125; return null; &#125; &#125; 2.Base64Util.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package test; /** * Base64 工具类 */public class Base64Util &#123; private static final char last2byte = (char) Integer.parseInt("00000011", 2); private static final char last4byte = (char) Integer.parseInt("00001111", 2); private static final char last6byte = (char) Integer.parseInt("00111111", 2); private static final char lead6byte = (char) Integer.parseInt("11111100", 2); private static final char lead4byte = (char) Integer.parseInt("11110000", 2); private static final char lead2byte = (char) Integer.parseInt("11000000", 2); private static final char[] encodeTable = new char[]&#123;'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'&#125;; public Base64Util() &#123; &#125; public static String encode(byte[] from) &#123; StringBuilder to = new StringBuilder((int) ((double) from.length * 1.34D) + 3); int num = 0; char currentByte = 0; int i; for (i = 0; i &lt; from.length; ++i) &#123; for (num %= 8; num &lt; 8; num += 6) &#123; switch (num) &#123; case 0: currentByte = (char) (from[i] &amp; lead6byte); currentByte = (char) (currentByte &gt;&gt;&gt; 2); case 1: case 3: case 5: default: break; case 2: currentByte = (char) (from[i] &amp; last6byte); break; case 4: currentByte = (char) (from[i] &amp; last4byte); currentByte = (char) (currentByte &lt;&lt; 2); if (i + 1 &lt; from.length) &#123; currentByte = (char) (currentByte | (from[i + 1] &amp; lead2byte) &gt;&gt;&gt; 6); &#125; break; case 6: currentByte = (char) (from[i] &amp; last2byte); currentByte = (char) (currentByte &lt;&lt; 4); if (i + 1 &lt; from.length) &#123; currentByte = (char) (currentByte | (from[i + 1] &amp; lead4byte) &gt;&gt;&gt; 4); &#125; &#125; to.append(encodeTable[currentByte]); &#125; &#125; if (to.length() % 4 != 0) &#123; for (i = 4 - to.length() % 4; i &gt; 0; --i) &#123; to.append("="); &#125; &#125; return to.toString(); &#125;&#125; 3.FileUtil.java点击显/隐内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package test; import java.io.*; /** * 文件读取工具类 */public class FileUtil &#123; /** * 读取文件内容，作为字符串返回 */ public static String readFileAsString(String filePath) throws IOException &#123; File file = new File(filePath); if (!file.exists()) &#123; throw new FileNotFoundException(filePath); &#125; if (file.length() &gt; 1024 * 1024 * 1024) &#123; throw new IOException("File is too large"); &#125; StringBuilder sb = new StringBuilder((int) (file.length())); // 创建字节输入流 FileInputStream fis = new FileInputStream(filePath); // 创建一个长度为10240的Buffer byte[] bbuf = new byte[10240]; // 用于保存实际读取的字节数 int hasRead = 0; while ( (hasRead = fis.read(bbuf)) &gt; 0 ) &#123; sb.append(new String(bbuf, 0, hasRead)); &#125; fis.close(); return sb.toString(); &#125; /** * 根据文件路径读取byte[] 数组 */ public static byte[] readFileByBytes(String filePath) throws IOException &#123; File file = new File(filePath); if (!file.exists()) &#123; throw new FileNotFoundException(filePath); &#125; else &#123; ByteArrayOutputStream bos = new ByteArrayOutputStream((int) file.length()); BufferedInputStream in = null; try &#123; in = new BufferedInputStream(new FileInputStream(file)); short bufSize = 1024; byte[] buffer = new byte[bufSize]; int len1; while (-1 != (len1 = in.read(buffer, 0, bufSize))) &#123; bos.write(buffer, 0, len1); &#125; byte[] var7 = bos.toByteArray(); return var7; &#125; finally &#123; try &#123; if (in != null) &#123; in.close(); &#125; &#125; catch (IOException var14) &#123; var14.printStackTrace(); &#125; bos.close(); &#125; &#125; &#125;&#125; 4.HttpUtil.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576package test;import java.io.BufferedReader;import java.io.DataOutputStream;import java.io.InputStreamReader;import java.net.HttpURLConnection;import java.net.URL;import java.util.List;import java.util.Map; /** * http 工具类 */public class HttpUtil &#123; public static String post(String requestUrl, String accessToken, String params) throws Exception &#123; String contentType = "application/x-www-form-urlencoded"; return HttpUtil.post(requestUrl, accessToken, contentType, params); &#125; public static String post(String requestUrl, String accessToken, String contentType, String params) throws Exception &#123; String encoding = "UTF-8"; if (requestUrl.contains("nlp")) &#123; encoding = "GBK"; &#125; return HttpUtil.post(requestUrl, accessToken, contentType, params, encoding); &#125; public static String post(String requestUrl, String accessToken, String contentType, String params, String encoding) throws Exception &#123; String url = requestUrl + "?access_token=" + accessToken; return HttpUtil.postGeneralUrl(url, contentType, params, encoding); &#125; public static String postGeneralUrl(String generalUrl, String contentType, String params, String encoding) throws Exception &#123; URL url = new URL(generalUrl); // 打开和URL之间的连接 HttpURLConnection connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod("POST"); // 设置通用的请求属性 connection.setRequestProperty("Content-Type", contentType); connection.setRequestProperty("Connection", "Keep-Alive"); connection.setUseCaches(false); connection.setDoOutput(true); connection.setDoInput(true); // 得到请求的输出流对象 DataOutputStream out = new DataOutputStream(connection.getOutputStream()); out.write(params.getBytes(encoding)); out.flush(); out.close(); // 建立实际的连接 connection.connect(); // 获取所有响应头字段 Map&lt;String, List&lt;String&gt;&gt; headers = connection.getHeaderFields(); // 遍历所有的响应头字段 for (String key : headers.keySet()) &#123; System.err.println(key + "---&gt;" + headers.get(key)); &#125; // 定义 BufferedReader输入流来读取URL的响应 BufferedReader in = null; in = new BufferedReader( new InputStreamReader(connection.getInputStream(), encoding)); String result = ""; String getLine; while ((getLine = in.readLine()) != null) &#123; result += getLine; &#125; in.close(); System.err.println("result:" + result); return result; &#125;&#125; More info: Gihub]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[My NEW Post]]></title>
    <url>%2F%2F2019%2F04%2F01%2FMy-NEW-Post%2F</url>
    <content type="text"><![CDATA[tags: categories: Test Hello WorldWelcome to Jack’s Pesonal Blog! This is my very first post. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a First part 11111111111111111111111111 Secend part12222222222222222222222222222222 third part13333333333333333333333 fourth part14444444444444444444444 More info: Gihub]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java随笔 （？：）条件运算符]]></title>
    <url>%2F%2F2019%2F03%2F31%2FJava%E9%9A%8F%E7%AC%94-%EF%BC%9F%EF%BC%9A%2F</url>
    <content type="text"><![CDATA[条件运算符（?:）条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。 1variable x = (expression) ? value if true : value if false 实例 12345678910public class Test &#123; public static void main(String args[])&#123; int a , b; a = 10; b = (a == 1) ? 20: 30; System.out.println( "Value of b is : " + b ); b = (a == 10) ? 20: 30; System.out.println( "Value of b is : " + b ); &#125;&#125; 以上编译结果如下： 12Value of b is : 30Value of b is : 20 instanceOf 运算符该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。 instanceof运算符使用格式如下： ( Object reference variable ) instanceOf (class/interface type) 如果运算符左侧变量所指的对象，是操作符右侧类或接口(class/interface)的一个对象，那么结果为真。 下面是一个例子： String name = &apos;James&apos;; boolean result = name instanceOf String; // 由于name是Strine类型，所以返回真 如果被比较的对象兼容于右侧类型,该运算符仍然返回true。 看下面的例子： class Vehicle {} public class Car extends Vehicle { public static void main(String args[]){ Vehicle a = new Car(); boolean result = a instanceof Car; System.out.println( result); } } 以上实例编译运行结果如下： true Java运算符优先级当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。 例如，（1+3）＋（3+2）*2，这个表达式如果按加号最优先计算，答案就是 18，如果按照乘号最优先，答案则是 14。 再如，x = 7 + 3 2;这里x得到13，而不是20，因为乘法运算符比加法运算符有较高的优先级，所以先计算3 2得到6，然后再加7。 下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
</search>
