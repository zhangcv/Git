<!DOCTYPE html><html class="theme-next muse use-motion" lang="en"><head><meta name="generator" content="Hexo 3.8.0"><script type="text/javascript" src="/js/love.js"></script><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><script src="/VEN/pace/pace.min.js?v=1.0.2"></script><link rel="stylesheet" href="/VEN/pace/pace-theme-minimal.min.css?v=1.0.2"><link rel="stylesheet" href="/VEN/font-awesome/css/font-awesome.min.css?v=4.6.2"><link rel="stylesheet" href="/css/main.css?v=7.0.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.1"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1"><link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"7.0.1",sidebar:{position:"left",display:"hide",offset:12,onmobile:!1,dimmer:!0},back2top:!0,back2top_sidebar:!1,fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="赫夫曼树重要概念 二叉树应用之二，一为堆排序    举例： 1. 路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根节点的层数为1，则从根节点到第L层结点的路径长度为L-1 2. 结点的权及带权路径长度： 若将树中结点赋值给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长"><meta name="keywords" content="数据结构"><meta property="og:type" content="article"><meta property="og:title" content="赫夫曼树"><meta property="og:url" content="http://zhangcv.github.io/2019/07/23/2019-07-23-02/index.html"><meta property="og:site_name" content="Zhangcv&#39;s Personal Website"><meta property="og:description" content="赫夫曼树重要概念 二叉树应用之二，一为堆排序    举例： 1. 路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根节点的层数为1，则从根节点到第L层结点的路径长度为L-1 2. 结点的权及带权路径长度： 若将树中结点赋值给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长"><meta property="og:locale" content="en"><meta property="og:image" content="http://zhangcv.github.io/2019/07/23/2019-07-23-02/1.jpg"><meta property="og:image" content="http://zhangcv.github.io/2019/07/23/2019-07-23-02/1.jpg"><meta property="og:image" content="http://zhangcv.github.io/2019/07/23/2019-07-23-02/3.jpg"><meta property="og:image" content="http://zhangcv.github.io/2019/07/23/2019-07-23-02/4.jpg"><meta property="og:image" content="http://zhangcv.github.io/2019/07/23/2019-07-23-02/5.jpg"><meta property="og:image" content="http://zhangcv.github.io/2019/07/23/2019-07-23-02/6.jpg"><meta property="og:image" content="http://zhangcv.github.io/2019/07/23/2019-07-23-02/6.jpg"><meta property="og:updated_time" content="2019-08-02T07:34:30.777Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="赫夫曼树"><meta name="twitter:description" content="赫夫曼树重要概念 二叉树应用之二，一为堆排序    举例： 1. 路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根节点的层数为1，则从根节点到第L层结点的路径长度为L-1 2. 结点的权及带权路径长度： 若将树中结点赋值给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长"><meta name="twitter:image" content="http://zhangcv.github.io/2019/07/23/2019-07-23-02/1.jpg"><link rel="canonical" href="http://zhangcv.github.io/2019/07/23/2019-07-23-02/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>赫夫曼树 | Zhangcv's Personal Website</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="en"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Zhangcv's Personal Website</span><span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"> <button aria-label="Toggle navigation bar"><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i><br>Tags<span class="badge">17</span></a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i><br>Categories<span class="badge">18</span></a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives<span class="badge">99</span></a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-question-circle"></i><br>Commonweal 404</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav><script>window.onload=function(){for(var t="https://zhangcv.github.io/",o=String(window.location).split(t)[1],l=document.querySelectorAll("#menu > li > a"),i=0;i<l.length;i++){var n=String(l[i].href).split(t)[1];n==o&&null!=n&&l[i].setAttribute("style","border-bottom:1px solid black")}}</script></div> <a href="https://github.com/zhangcv" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://zhangcv.github.io/2019/07/23/2019-07-23-02/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Jack"><meta itemprop="description" content="Jack's Ideas & Blogs"><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Zhangcv's Personal Website"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">赫夫曼树</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">Posted on</span> <time title="Created: 2019-07-23 21:31:30" itemprop="dateCreated datePublished" datetime="2019-07-23T21:31:30+08:00">2019-07-23</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="赫夫曼树"><a href="#赫夫曼树" class="headerlink" title="赫夫曼树"></a>赫夫曼树</h3><h4 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h4><p> 二叉树应用之二，一为堆排序<br> 举例：</p><pre><code>1. 路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根节点的层数为1，则从根节点到第L层结点的路径长度为L-1
2.
结点的权及带权路径长度： 若将树中结点赋值给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。
3.    树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length),权值越大的结点离根结点越近的二叉树才是最优二叉树。
4.
WPL最小的就是赫夫曼树
</code></pre><p><img src="/2019/07/23/2019-07-23-02/1.jpg" alt="无"><br> 权值最大的结点离根结点越近</p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><p>构建赫夫曼树：<br>1)从小到大进行排序，将每一个数据，每个数据都是一个结点，每个结点可以看成一颗最简单的二叉树<br>2)取出根结点权值最小的两颗二叉树<br>3)组成一颗新的二叉树，该新的二叉树的根结点的权值是前面两颗二叉树根结点权值的和<br>4)再将这颗新的二叉树，以根结点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理，得到一颗赫夫曼树。</p><p>13,7,8,3,29,6,1<br>排序<br>1,3,6,7,8,13,29<br>构建的赫夫曼树应为<br><img src="/2019/07/23/2019-07-23-02/1.jpg" alt="无"></p><p>实现代码<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">public class HuffmanTree &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		int arr[] = &#123; 13, 7, 8, 3, 29, 6, 1 &#125;;</span><br><span class="line">		Node root = createHuffmanTree(arr);</span><br><span class="line"></span><br><span class="line">		// 测试</span><br><span class="line">		preOrder(root);// 67,29,38,15,7,8,23,10,4,1,3,6,13</span><br><span class="line">	&#125;</span><br><span class="line">	public static void preOrder(Node root) &#123;</span><br><span class="line">		<span class="keyword">if</span> (root != null) &#123;</span><br><span class="line">			root.preOrder();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"是空树，不能遍历~~"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * </span><br><span class="line">	 * @param arr 需要创建赫夫曼树的的数组</span><br><span class="line">	 * @<span class="built_in">return</span>  创建好后赫夫曼树的root结点</span><br><span class="line">	 */</span><br><span class="line">	public static Node createHuffmanTree(int arr[]) &#123;</span><br><span class="line">		// 1.遍历arr数组</span><br><span class="line">		// 2.将arr的每个元素构成成一个Node</span><br><span class="line">		// 将Node放入到ArrayList中</span><br><span class="line">		List&lt;Node&gt; nodes = new ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (int value : arr) &#123;</span><br><span class="line">			nodes.add(new Node(value));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (nodes.size() &gt; 1) &#123;</span><br><span class="line">			// 排序 从小到大</span><br><span class="line">			Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">			// 取出根结点权值最小的两颗二叉树,需要注意的是：如果从大到小，取的是最后一个，最后两个。CompareTo 变-</span><br><span class="line">			// 1)取出权值最小的结点(二叉树)</span><br><span class="line">			Node leftNode = nodes.get(0);</span><br><span class="line">			// 2)取出权值第二小的结点(二叉树)</span><br><span class="line">			Node rightNode = nodes.get(1);</span><br><span class="line">			// 3)构建一颗新的二叉树</span><br><span class="line">			Node parentNode = new Node(leftNode.value + rightNode.value);</span><br><span class="line">			parentNode.left = leftNode;</span><br><span class="line">			parentNode.right = rightNode;</span><br><span class="line"></span><br><span class="line">			// 4)从ArrayList中删除处理过的二叉树</span><br><span class="line">			nodes.remove(leftNode);</span><br><span class="line">			nodes.remove(rightNode);</span><br><span class="line">			// 5)将parentNode加入到ArrayList中</span><br><span class="line">			nodes.add(parentNode);</span><br><span class="line">		&#125;</span><br><span class="line">		// 返回root结点，处理最后只剩一个权值</span><br><span class="line">		<span class="built_in">return</span> nodes.get(0);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//为了让Node 对象支持排序Collections集合排序</span><br><span class="line">//让Node 实现Comparable 接口</span><br><span class="line">class Node implements Comparable&lt;Node&gt; &#123;</span><br><span class="line">	int value;// 结点权值</span><br><span class="line">	Node left;</span><br><span class="line">	Node right;</span><br><span class="line"></span><br><span class="line">	public Node(int value) &#123;</span><br><span class="line">		this.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 前序遍历</span><br><span class="line">	public void <span class="function"><span class="title">preOrder</span></span>() &#123;</span><br><span class="line">		System.out.println(this);</span><br><span class="line">		<span class="keyword">if</span> (this.left != null) &#123;</span><br><span class="line">			this.left.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (this.right != null) &#123;</span><br><span class="line">			this.right.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public String <span class="function"><span class="title">toString</span></span>() &#123;</span><br><span class="line">		<span class="built_in">return</span> <span class="string">"Node [value="</span> + value + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 从小到大进行排序</span><br><span class="line">	@Override</span><br><span class="line">	public int compareTo(Node o) &#123;</span><br><span class="line">		<span class="built_in">return</span> this.value - o.value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>1)赫夫曼编码翻译为 赫夫曼编码，是一种编码方式，属于程序算法。<br>2)赫夫曼编码式赫夫曼树在电讯通信中最经典的应用之一。<br>3)赫夫曼编码广泛用于 数据文件压缩。 压缩率20%~90%之间<br>4) 可变字长编码(VLC)的一种。<br><img src="/2019/07/23/2019-07-23-02/3.jpg" alt="无"><br><img src="/2019/07/23/2019-07-23-02/4.jpg" alt="无"><br>1)i like like like java do you like a java<br>2)d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 (空格):9 //<br>3)按照上面出现次数构建一颗赫夫曼树，次数作为权值<br>注意事项：如果排序方法不同，也可能构建不一样，但WPL都是一样，都是最小。比如：如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个。<br>构建的应该是如图<br><img src="/2019/07/23/2019-07-23-02/5.jpg" alt="无"><br>编码如图<br><img src="/2019/07/23/2019-07-23-02/6.jpg" alt="无"><br>向左的路径为0，向右的路径为1<br><img src="/2019/07/23/2019-07-23-02/6.jpg" alt="无"><br>压缩率(359-133)/359=62.9%<br>满足前缀编码，字符的编码都不能是其他字符编码的前缀，不会造成匹配的多义性。无损的压缩方式。</p><h3 id="创建赫夫曼树"><a href="#创建赫夫曼树" class="headerlink" title="创建赫夫曼树"></a>创建赫夫曼树</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>1)Node{ data存放数据，weight权重，left，right}<br>2)得到XX对应的 byte[]数组<br>3)编写一个方法，将构建赫夫曼树的Node结点放到List中 形式[Node[data=97，weight5]，Node[data=32，weight=9]]<br>4)通过List创建对应的赫夫曼树</p><p>生成的赫夫曼树已经完成<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">结果：</span><br><span class="line">40</span><br><span class="line">[Node [data=32, weight=9], Node [data=97, weight=5], Node [data=100, weight=1], Node [data=101, weight=4], Node [data=117, weight=1], Node [data=118, weight=2], Node [data=105, weight=5], Node [data=121, weight=1], Node [data=106, weight=2], Node [data=107, weight=4], Node [data=108, weight=4], Node [data=111, weight=2]]</span><br><span class="line">赫夫曼树</span><br><span class="line">Node [data=null, weight=40]</span><br><span class="line">Node [data=null, weight=17]</span><br><span class="line">Node [data=null, weight=8]</span><br><span class="line">Node [data=108, weight=4]</span><br><span class="line">Node [data=null, weight=4]</span><br><span class="line">Node [data=106, weight=2]</span><br><span class="line">Node [data=111, weight=2]</span><br><span class="line">Node [data=32, weight=9]</span><br><span class="line">Node [data=null, weight=23]</span><br><span class="line">Node [data=null, weight=10]</span><br><span class="line">Node [data=97, weight=5]</span><br><span class="line">Node [data=105, weight=5]</span><br><span class="line">Node [data=null, weight=13]</span><br><span class="line">Node [data=null, weight=5]</span><br><span class="line">Node [data=null, weight=2]</span><br><span class="line">Node [data=100, weight=1]</span><br><span class="line">Node [data=117, weight=1]</span><br><span class="line">Node [data=null, weight=3]</span><br><span class="line">Node [data=121, weight=1]</span><br><span class="line">Node [data=118, weight=2]</span><br><span class="line">Node [data=null, weight=8]</span><br><span class="line">Node [data=101, weight=4]</span><br><span class="line">Node [data=107, weight=4]</span><br><span class="line">生成的赫夫曼编码表=&#123;32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011&#125;</span><br><span class="line">******</span><br><span class="line">huffmanCodeBytes=[-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]</span><br></pre></td></tr></table></figure><p></p><h4 id="整合一个类"><a href="#整合一个类" class="headerlink" title="整合一个类"></a>整合一个类</h4><p>整合成一个方法：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">main函数</span><br><span class="line">		String content = <span class="string">"i like like like java do you like a java"</span>;</span><br><span class="line">		byte[] contentBytes = content.getBytes();</span><br><span class="line">		System.out.println(contentBytes.length); // 40</span><br><span class="line">		byte[] huffmanCodesBytes=huffmanZip(contentBytes);</span><br><span class="line">		System.out.println(<span class="string">"压缩后的结果是： "</span>+Arrays.toString(huffmanCodesBytes)+<span class="string">" ,长度为"</span>+huffmanCodesBytes.length);</span><br><span class="line">================================</span><br><span class="line">//编写一个方法，将前面的方法封装起来，便于调用</span><br><span class="line">	/**</span><br><span class="line">	 * </span><br><span class="line">	 * @param bytes 原始的字符串对应的数组</span><br><span class="line">	 * @<span class="built_in">return</span> 返回是经过  赫夫曼编码处理后的字节数组(压缩后)</span><br><span class="line">	 */</span><br><span class="line">	private static byte[] huffmanZip(byte[] bytes) &#123;</span><br><span class="line">		</span><br><span class="line">		List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">		Node huffmanTreeRoot = createHuffmanTree(nodes);</span><br><span class="line">		Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTreeRoot);</span><br><span class="line">		byte[] huffmanCodeBytes =zip(bytes, huffmanCodes);</span><br><span class="line">		<span class="built_in">return</span> huffmanCodeBytes;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="数据解压，解码"><a href="#数据解压，解码" class="headerlink" title="数据解压，解码"></a>数据解压，解码</h4><p>数据解压，解码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">========================================</span><br><span class="line">main函数中：</span><br><span class="line">		byte[] sourceBytes = decode(huffmanCodes,huffmanCodesBytes);</span><br><span class="line">		System.out.println(<span class="string">"解码- ："</span>+new String(sourceBytes)); //i like like like java <span class="keyword">do</span> you like a java</span><br><span class="line">		</span><br><span class="line">========================================</span><br><span class="line">//完成数据的解压</span><br><span class="line">	//思路</span><br><span class="line">	//1.将huffmanCodeBytes [-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28] ,长度为17</span><br><span class="line">	//     重写先转成对应的二进制的字符串</span><br><span class="line">	//2. 赫夫曼编码对应的字符串<span class="string">"1010100.."</span>===&gt;按照赫夫曼编码 ===&gt;<span class="string">"i like like like java do you like a java"</span></span><br><span class="line">	</span><br><span class="line">	//编写一个方法，完成对压缩数据的解码</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * @param huffmanCodes 赫夫曼编码表 map</span><br><span class="line">	 * @param huffmanBytes 赫夫曼编码得到的字节数组</span><br><span class="line">	 * @<span class="built_in">return</span> 就是原来的字符串对应的数组</span><br><span class="line">	 */</span><br><span class="line">	private static byte[] decode(Map&lt;Byte, String&gt; huffmanCodes, byte[] huffmanBytes) &#123;</span><br><span class="line">		// 1、先得到huffmanBytes 对应的二进制的 字符串，形如1010111..</span><br><span class="line">		StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">		// 将byte数组转成 二进制的字符串</span><br><span class="line">		<span class="keyword">for</span> (int i = 0; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line">			byte b = huffmanBytes[i];</span><br><span class="line">			// 判断是不是最后一个字节</span><br><span class="line">			boolean flag = (i == huffmanBytes.length - 1);</span><br><span class="line">			stringBuilder.append(byteToBitString(!flag, b));</span><br><span class="line">		&#125;</span><br><span class="line">		// 2、把字符串按照指定的赫夫曼编码进行解码</span><br><span class="line">		// 进行调换，因为反向查询a-&gt;100,100-&gt;a</span><br><span class="line">		Map&lt;String, Byte&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">			map.put(entry.getValue(), entry.getKey());</span><br><span class="line">		&#125;</span><br><span class="line">		// 创建一个集合，存放byte</span><br><span class="line">		List&lt;Byte&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (int i = 0; i &lt; stringBuilder.length();) &#123;</span><br><span class="line">			int count = 1;</span><br><span class="line">			boolean flag = <span class="literal">true</span>;</span><br><span class="line">			Byte b = null;</span><br><span class="line">			<span class="keyword">while</span> (flag) &#123;</span><br><span class="line">				// 取出一个<span class="string">'1'</span>或者<span class="string">'0'</span></span><br><span class="line">				String key = stringBuilder.substring(i, i + count);// i不动，让count移动，直到匹配到一个字符</span><br><span class="line">				b = map.get(key);</span><br><span class="line">				<span class="keyword">if</span> (b == null) &#123;// 未匹配</span><br><span class="line">					count++;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					// 匹配</span><br><span class="line">					flag = <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			list.add(b);</span><br><span class="line">			i += count;// i 直接移动到count</span><br><span class="line">		&#125;</span><br><span class="line">		// <span class="keyword">for</span>循环结束，list就存放了所有的字符<span class="string">"i like like..."</span></span><br><span class="line">		// 把list 数据放入 byte[] 并返回</span><br><span class="line">		byte b[] = new byte[list.size()];</span><br><span class="line">		<span class="keyword">for</span> (int i = 0; i &lt; b.length; i++) &#123;</span><br><span class="line">			b[i] = list.get(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	/**</span><br><span class="line">	 * 功能 ： 将一个以字符串 转换为二进制串</span><br><span class="line">	 * @param flag 标识 是否 需要补高位，如果是<span class="literal">true</span>，表示需要补高位，如果是<span class="literal">false</span>表示不补,即最后一个字节，无需补高位</span><br><span class="line">	 * @param b 传一个数组</span><br><span class="line">	 * @<span class="built_in">return</span>  是该b 对应的二进制的字符串(注意按补码返回)</span><br><span class="line">	 */</span><br><span class="line">	private static String byteToBitString(boolean flag, byte b) &#123;</span><br><span class="line">		// 使用变量保存 b</span><br><span class="line">		int temp = b;// b转为 int</span><br><span class="line">		// 如果是正数我们还存在补高位</span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">			temp |= 256;// 按位与256 1 000 0000 | 0000 0001 =&gt;1000 0001</span><br><span class="line">		&#125;</span><br><span class="line">		String str = Integer.toBinaryString(temp);</span><br><span class="line">		// System.out.println(str);</span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">			<span class="built_in">return</span> str.substring(str.length() - 8);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> str;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">=================================</span><br><span class="line">结果</span><br><span class="line"></span><br><span class="line">解码- ：i like like like java <span class="keyword">do</span> you like a java</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对文件进行压缩 ，压缩的文件 普通Zip解压不了，需要特有的编码才能解压文件。</p><p>####代码<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">=================================</span><br><span class="line">结果</span><br><span class="line">压缩文件ok~~</span><br><span class="line">解压成功!</span><br><span class="line">=================================</span><br><span class="line">main函数</span><br><span class="line"></span><br><span class="line">		String srcFile = <span class="string">"d:/test/tupian.jpg"</span>;</span><br><span class="line">		String dstFile = <span class="string">"d:/test/1.zip"</span>;</span><br><span class="line"></span><br><span class="line">		zipFile(srcFile, dstFile);</span><br><span class="line">		System.out.println(<span class="string">"压缩文件ok~~"</span>);</span><br><span class="line"></span><br><span class="line">		// 测试解压文件</span><br><span class="line">		String zipFile = <span class="string">"d:/test/1.zip"</span>;</span><br><span class="line">		String dstFile2 = <span class="string">"d:/test/xin.docx"</span>;</span><br><span class="line">		unZipFile(zipFile, dstFile2);</span><br><span class="line">		System.out.println(<span class="string">"解压成功!"</span>);</span><br><span class="line">===================================</span><br><span class="line">//编写方法，对文件进行压缩</span><br><span class="line">	/**</span><br><span class="line">	 * </span><br><span class="line">	 * @param srcFile 源文件路径</span><br><span class="line">	 * @param dstFile 目标路径</span><br><span class="line">	 */</span><br><span class="line">	public static void zipFile(String srcFile,String dstFile) &#123;</span><br><span class="line">		// 创建输出流</span><br><span class="line">		FileOutputStream os = null;</span><br><span class="line">		//创建一个对象输出流</span><br><span class="line">		ObjectOutputStream oos = null;</span><br><span class="line">		// 创建输入流</span><br><span class="line">		FileInputStream is = null;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			is = new FileInputStream(srcFile);</span><br><span class="line">			byte[] b = new byte[is.available()];// 创建一个大小一样的byte[]</span><br><span class="line">			is.read(b); // 读文件</span><br><span class="line">			byte[] huffmanBytes = huffmanZip(b); // 源文件压缩</span><br><span class="line">			os = new FileOutputStream(dstFile);	// 创建文件输出流，存放压缩文件</span><br><span class="line">			oos = new ObjectOutputStream(os);//创建一个和文件输出流关联的ObjectOutputStream</span><br><span class="line">			//赫夫曼编码的字节数组写入压缩文件</span><br><span class="line">			oos.writeObject(huffmanBytes);</span><br><span class="line">			//这里我们以对象流的方法写入赫夫曼编码，是为了以后恢复源文件时使用</span><br><span class="line">			//一定要把赫夫曼编码 写入压缩文件</span><br><span class="line">			oos.writeObject(huffmanCodes);</span><br><span class="line">			</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			// e.printStackTrace();</span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				is.close();</span><br><span class="line">				os.close();</span><br><span class="line">				oos.close();</span><br><span class="line">			&#125; catch (IOException e) &#123;</span><br><span class="line">				System.out.println(e.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 编写一个放，完成对压缩文件的解压</span><br><span class="line">	public static void unZipFile(String zipFile, String dstFile) &#123;</span><br><span class="line">		// 定义文件输入流</span><br><span class="line">		InputStream is = null;</span><br><span class="line">		// 定一个对象输入流</span><br><span class="line">		ObjectInputStream ois = null;</span><br><span class="line">		OutputStream os = null;</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			is = new FileInputStream(zipFile);</span><br><span class="line">			ois = new ObjectInputStream(is);</span><br><span class="line">			byte[] huffmanBytes = (byte[]) ois.readObject();</span><br><span class="line">			Map&lt;Byte, String&gt; codes = (Map&lt;Byte, String&gt;) ois.readObject();</span><br><span class="line">			byte[] bytes = decode(huffmanCodes, huffmanBytes);</span><br><span class="line">			os = new FileOutputStream(dstFile);</span><br><span class="line">			os.write(bytes);</span><br><span class="line"></span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				os.close();</span><br><span class="line">				ois.close();</span><br><span class="line">				is.close();</span><br><span class="line">			&#125; catch (IOException e) &#123;</span><br><span class="line">				System.out.println(e.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><p></p></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/数据结构/" rel="tag"># 数据结构</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/07/23/2019-07-23/" rel="next" title="SpringMVC拦截器及国际化、异常处理"><i class="fa fa-chevron-left"></i> SpringMVC拦截器及国际化、异常处理</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2019/07/24/2019-07-24/" rel="prev" title="SpringMVC对Json的支持、文件上传">SpringMVC对Json的支持、文件上传<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> Overview</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Jack"><p class="site-author-name" itemprop="name">Jack</p><div class="site-description motion-element" itemprop="description">Jack's Ideas & Blogs</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">99</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories"><span class="site-state-item-count">18</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags"><span class="site-state-item-count">17</span> <span class="site-state-item-name">tags</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3poYW5nY3Y=" title="GitHub &rarr; https://github.com/zhangcv"><i class="fa fa-fw fa-github"></i> GitHub</span></span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS96aGFuZ2N2MjAxNw==" title="Twitter &rarr; https://twitter.com/zhangcv2017"><i class="fa fa-fw fa-twitter"></i> Twitter</span></span></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#赫夫曼树"><span class="nav-number">1.</span> <span class="nav-text">赫夫曼树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重要概念"><span class="nav-number">1.1.</span> <span class="nav-text">重要概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#思路分析"><span class="nav-number">1.2.</span> <span class="nav-text">思路分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#赫夫曼编码"><span class="nav-number">2.</span> <span class="nav-text">赫夫曼编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本介绍"><span class="nav-number">2.1.</span> <span class="nav-text">基本介绍</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建赫夫曼树"><span class="nav-number">3.</span> <span class="nav-text">创建赫夫曼树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#思路"><span class="nav-number">3.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#整合一个类"><span class="nav-number">3.2.</span> <span class="nav-text">整合一个类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据解压，解码"><span class="nav-number">3.3.</span> <span class="nav-text">数据解压，解码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">3.4.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span><span class="with-love" id="animate"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">Jack</span></div> "<div class="powered-by">Powered by <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> v3.8.0</div> <span class="post-meta-divider">|</span><div class="theme-info">Theme – <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZw==">NexT.Muse</span> v7.0.1</div> "<br><script type="text/javascript">var cnzz_s_tag=document.createElement("script");cnzz_s_tag.type="text/javascript",cnzz_s_tag.async=!0,cnzz_s_tag.charset="utf-8",cnzz_s_tag.src="https://w.cnzz.com/c.php?id=1276883782&async=1";var root_s=document.getElementsByTagName("script")[0];root_s.parentNode.insertBefore(cnzz_s_tag,root_s)</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span> <span class="post-meta-divider">|</span> <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人</span><br> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("04/01/2019 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="Run for "+dnum+" Days ",document.getElementById("times").innerHTML=hnum+" Hours "+mnum+" m "+snum+" s"}setInterval("createtime()",250)</script></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/VEN/jquery/index.js?v=2.1.3"></script><script src="/VEN/velocity/velocity.min.js?v=1.2.1"></script><script src="/VEN/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/utils.js?v=7.0.1"></script><script src="/js/motion.js?v=7.0.1"></script><script src="/js/schemes/muse.js?v=7.0.1"></script><script src="/js/next-boot.js?v=7.0.1"></script><script src="/js/exturl.js?v=7.0.1"></script><script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script></body></html>